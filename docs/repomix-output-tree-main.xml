This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where comments have been removed, empty lines have been removed, line numbers have been added, security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Security check has been disabled - content may contain sensitive information
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    build.yml
    release.yml
src/
  __mocks__/
    ws.ts
  api/
    __mocks__/
      events.ts
    events/
      __tests__/
        action.test.ts
        system.test.ts
      action.ts
      device.ts
      encoder.ts
      index.ts
      keypad.ts
      system.ts
      ui.ts
    registration/
      __mocks__/
        index.ts
      index.ts
      info.ts
      parameters.ts
      ui.ts
    command.ts
    device.ts
    i18n.ts
    index.ts
    layout.ts
    target.ts
  common/
    __tests__/
      disposable.test.ts
      enumerable.test.ts
      event-emitter.test.ts
      i18n.test.ts
      promises.test.ts
      utils.test.ts
    events/
      action-event.ts
      event.ts
      index.ts
      settings-event.ts
    logging/
      __tests__/
        console-target.test.ts
        format.test.ts
        logger.test.ts
        routing.test.ts
      console-target.ts
      format.ts
      index.ts
      level.ts
      logger.ts
      routing.ts
      target.ts
    messaging/
      __tests__/
        gateway.test.ts
        message.test.ts
        responder.test.ts
      gateway.ts
      index.ts
      message.ts
      responder.ts
    disposable.ts
    enumerable.ts
    event-emitter.ts
    i18n.ts
    json.ts
    promises.ts
    utils.ts
  plugin/
    __mocks__/
      connection.ts
      manifest.ts
    __tests__/
      connection.test.ts
      i18n.test.ts
      index.test.ts
      manifest.test.ts
      profiles.test.ts
      settings.test.ts
      system.test.ts
      validation.test.ts
    actions/
      __mocks__/
        store.ts
      __tests__/
        action.test.ts
        decorators.test.ts
        dial.test.ts
        key.test.ts
        service.test.ts
      action.ts
      context.ts
      decorators.ts
      dial.ts
      index.ts
      key.ts
      service.ts
      singleton-action.ts
      store.ts
    common/
      __tests__/
        utils.test.ts
        version.test.ts
      utils.ts
      version.ts
    devices/
      __mocks__/
        index.ts
      __tests__/
        service.test.ts
      device.ts
      index.ts
      service.ts
      store.ts
    events/
      __tests__/
        deep-link-event.test.ts
      application-event.ts
      deep-link-event.ts
      device-event.ts
      index.ts
      ui-message-event.ts
    logging/
      __mocks__/
        index.ts
      __tests__/
        file-target.test.ts
        index.test.ts
      file-target.ts
      index.ts
    ui/
      __mocks__/
        router.ts
      __tests__/
        controller.test.ts
        property-inspector.test.ts
        route.test.ts
        router.test.ts
      controller.ts
      index.ts
      message.ts
      property-inspector.ts
      route.ts
      router.ts
    connection.ts
    i18n.ts
    index.ts
    manifest.ts
    profiles.ts
    settings.ts
    system.ts
    tsconfig.build.json
    validation.ts
  ui/
    __mocks__/
      connection.ts
      logging.ts
    __tests__/
      connection.test.ts
      i18n.test.ts
      index.test.ts
      logging.test.ts
      plugin.test.ts
      settings.test.ts
      system.test.ts
    action.ts
    connection.ts
    events.ts
    i18n.ts
    index.ts
    logging.ts
    plugin.ts
    settings.ts
    system.ts
    tsconfig.build.json
    tsconfig.json
tests/
  __setup__/
    global.ts
  utils.ts
.editorconfig
.gitignore
.npmrc
CHANGELOG.md
eslint.config.mjs
jest.config.js
LICENSE
package.json
README.md
rollup.config.mjs
tsconfig.json
UPGRADE.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/build.yml">
 1: name: Build
 2: on:
 3:   push:
 4:     branches:
 5:       - "main"
 6:       - "features/*"
 7:     paths-ignore:
 8:       - "assets/**"
 9:       - "**.md"
10:   pull_request:
11:     branches:
12:       - "main"
13:       - "features/*"
14:     paths-ignore:
15:       - "assets/**"
16:       - "**.md"
17: defaults:
18:   run:
19:     shell: bash
20: jobs:
21:   Build:
22:     strategy:
23:       matrix:
24:         node_version: ["20.18.0"]
25:         os: ["macos-latest", "windows-latest"]
26:     runs-on: ${{ matrix.os }}
27:     steps:
28:       - name: "üì• Checkout"
29:         uses: actions/checkout@v4
30:       - name: "üóÉÔ∏è Setup Node"
31:         uses: actions/setup-node@v4
32:         with:
33:           node-version: ${{ matrix.node_version }}
34:       - name: "üìê Install dependencies"
35:         run: npm ci
36:       - name: "üèóÔ∏è Build"
37:         run: npm run build
38:       - name: "üñåÔ∏è Lint"
39:         run: npm run lint
40:       - name: "üß™ Test"
41:         run: npm run test
</file>

<file path=".github/workflows/release.yml">
 1: name: Release
 2: on:
 3:   push:
 4:     tags:
 5:       - "*"
 6: defaults:
 7:   run:
 8:     shell: bash
 9: jobs:
10:   Release:
11:     runs-on: "windows-latest"
12:     permissions:
13:       contents: read
14:       id-token: write
15:     steps:
16:       - name: "üì• Checkout"
17:         uses: actions/checkout@v4
18:       - name: "üóÉÔ∏è Setup Node"
19:         uses: actions/setup-node@v4
20:         with:
21:           node-version: "20.18.0"
22:           registry-url: "https://registry.npmjs.org"
23:       - name: "üìê Install dependencies"
24:         run: npm ci
25:       - name: "üèóÔ∏è Build"
26:         run: npm run build
27:       - name: "üñåÔ∏è Lint"
28:         run: npm run lint
29:       - name: "üß™ Test"
30:         run: npm run test
31:       - name: "üìñ Retrieve package information"
32:         uses: geekyeggo/npm-pkg@v1
33:         id: pkg
34:       - name: "üì§ Publish"
35:         run: npm publish --provenance --access public --tag ${{ steps.pkg.outputs.version-tag }}
36:         env:
37:           NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
38:   Documentation:
39:     runs-on: "ubuntu-latest"
40:     needs: [Release]
41:     steps:
42:       - name: "üìÑ Deploy documentation"
43:         run: curl --silent --output /dev/null -X POST "${{ secrets.DOCS_DEPLOY_HOOK }}"
</file>

<file path="src/__mocks__/ws.ts">
1: export { WebSocket as default } from "mock-socket";
</file>

<file path="src/api/__mocks__/events.ts">
  1: import { DeviceType } from "../device";
  2: import type * as events from "../events";
  3: const action = "com.elgato.test.one";
  4: const context = "context123";
  5: const device = "device123";
  6: export const applicationDidLaunch: events.ApplicationDidLaunch = {
  7: 	event: "applicationDidLaunch",
  8: 	payload: {
  9: 		application: "notepad.exe",
 10: 	},
 11: };
 12: export const applicationDidTerminate: events.ApplicationDidTerminate = {
 13: 	event: "applicationDidTerminate",
 14: 	payload: {
 15: 		application: "cmd.exe",
 16: 	},
 17: };
 18: export const deviceDidConnect: events.DeviceDidConnect = {
 19: 	event: "deviceDidConnect",
 20: 	device,
 21: 	deviceInfo: {
 22: 		name: "Test Device",
 23: 		size: {
 24: 			columns: 8,
 25: 			rows: 4,
 26: 		},
 27: 		type: DeviceType.StreamDeckXL,
 28: 	},
 29: };
 30: export const deviceDidDisconnect: events.DeviceDidDisconnect = {
 31: 	event: "deviceDidDisconnect",
 32: 	device,
 33: };
 34: export const dialDown: events.DialDown<Settings> = {
 35: 	event: "dialDown",
 36: 	action,
 37: 	context,
 38: 	device,
 39: 	payload: {
 40: 		controller: "Encoder",
 41: 		coordinates: {
 42: 			column: 3,
 43: 			row: 0,
 44: 		},
 45: 		settings: {
 46: 			name: "Elgato",
 47: 		},
 48: 	},
 49: };
 50: export const dialRotate: events.DialRotate<Settings> = {
 51: 	event: "dialRotate",
 52: 	action,
 53: 	context,
 54: 	device,
 55: 	payload: {
 56: 		controller: "Encoder",
 57: 		coordinates: {
 58: 			column: 3,
 59: 			row: 0,
 60: 		},
 61: 		pressed: true,
 62: 		settings: {
 63: 			name: "Elgato",
 64: 		},
 65: 		ticks: -2,
 66: 	},
 67: };
 68: export const dialUp: events.DialUp<Settings> = {
 69: 	...dialDown,
 70: 	event: "dialUp",
 71: };
 72: export const didReceiveGlobalSettings: events.DidReceiveGlobalSettings<Settings> = {
 73: 	event: "didReceiveGlobalSettings",
 74: 	payload: {
 75: 		settings: {
 76: 			name: "Elgato",
 77: 		},
 78: 	},
 79: };
 80: export const didReceiveSettings: events.DidReceiveSettings<Settings> = {
 81: 	action,
 82: 	context,
 83: 	device,
 84: 	event: "didReceiveSettings",
 85: 	payload: {
 86: 		controller: "Encoder",
 87: 		coordinates: {
 88: 			column: 1,
 89: 			row: 0,
 90: 		},
 91: 		isInMultiAction: false,
 92: 		settings: {
 93: 			name: "Elgato",
 94: 		},
 95: 	},
 96: };
 97: export const keyDown: events.KeyDown<Settings> = {
 98: 	action,
 99: 	context,
100: 	device,
101: 	event: "keyDown",
102: 	payload: {
103: 		controller: "Keypad",
104: 		coordinates: {
105: 			column: 2,
106: 			row: 2,
107: 		},
108: 		isInMultiAction: false,
109: 		settings: {
110: 			name: "Elgato",
111: 		},
112: 		state: 1,
113: 	},
114: };
115: export const keyUp: events.KeyUp<Settings> = {
116: 	...keyDown,
117: 	event: "keyUp",
118: };
119: export const propertyInspectorDidAppear: events.PropertyInspectorDidAppear = {
120: 	action,
121: 	context,
122: 	device,
123: 	event: "propertyInspectorDidAppear",
124: };
125: export const propertyInspectorDidDisappear: events.PropertyInspectorDidDisappear = {
126: 	...propertyInspectorDidAppear,
127: 	event: "propertyInspectorDidDisappear",
128: };
129: export const didReceivePropertyInspectorMessage: events.DidReceivePropertyInspectorMessage<Settings> = {
130: 	action,
131: 	context,
132: 	event: "sendToPlugin",
133: 	payload: {
134: 		name: "Elgato",
135: 	},
136: };
137: export const systemDidWakeUp: events.SystemDidWakeUp = {
138: 	event: "systemDidWakeUp",
139: };
140: export const titleParametersDidChange: events.TitleParametersDidChange<Settings> = {
141: 	action,
142: 	context,
143: 	device,
144: 	event: "titleParametersDidChange",
145: 	payload: {
146: 		controller: "Keypad",
147: 		coordinates: {
148: 			column: 3,
149: 			row: 4,
150: 		},
151: 		settings: {
152: 			name: "Elgato",
153: 		},
154: 		title: "Hello world",
155: 		titleParameters: {
156: 			fontFamily: "Arial",
157: 			fontSize: 13,
158: 			fontStyle: "Bold Italic",
159: 			fontUnderline: true,
160: 			showTitle: false,
161: 			titleAlignment: "middle",
162: 			titleColor: "#ffffff",
163: 		},
164: 		state: 1,
165: 	},
166: };
167: export const touchTap: events.TouchTap<Settings> = {
168: 	action,
169: 	context,
170: 	device,
171: 	event: "touchTap",
172: 	payload: {
173: 		controller: "Encoder",
174: 		coordinates: {
175: 			column: 4,
176: 			row: 0,
177: 		},
178: 		hold: true,
179: 		settings: {
180: 			name: "Elgato",
181: 		},
182: 		tapPos: [10, 50],
183: 	},
184: };
185: export const willAppear: events.WillAppear<Settings> = {
186: 	action,
187: 	context,
188: 	device,
189: 	event: "willAppear",
190: 	payload: {
191: 		controller: "Keypad",
192: 		coordinates: {
193: 			column: 8,
194: 			row: 2,
195: 		},
196: 		isInMultiAction: false,
197: 		settings: {
198: 			name: "Elgato",
199: 		},
200: 		state: 1,
201: 	},
202: };
203: export const willDisappear: events.WillDisappear<Settings> = {
204: 	...willAppear,
205: 	event: "willDisappear",
206: };
207: export type Settings = {
208: 	name: string;
209: };
</file>

<file path="src/api/events/__tests__/action.test.ts">
 1: import { Coordinates, type State, WillAppear, WillDisappear } from "..";
 2: import { Expect, TypesAreEqual } from "../../../../tests/utils";
 3: import { Settings } from "../../__mocks__/events";
 4: describe("action event types", () => {
 5: 	it("willAppear", () => {
 6: 		type test = Expect<
 7: 			TypesAreEqual<
 8: 				WillAppear<Settings>,
 9: 				{
10: 					readonly action: string;
11: 					readonly event: "willAppear";
12: 					readonly context: string;
13: 					readonly device: string;
14: 					readonly payload:
15: 						| {
16: 								readonly isInMultiAction: false;
17: 								readonly controller: "Encoder" | "Keypad";
18: 								readonly coordinates: Coordinates;
19: 								settings: Settings;
20: 								readonly state?: State;
21: 						  }
22: 						| {
23: 								readonly isInMultiAction: true;
24: 								readonly controller: "Keypad";
25: 								settings: Settings;
26: 								readonly state?: State;
27: 						  };
28: 				}
29: 			>
30: 		>;
31: 	});
32: 	it("willDisappear", () => {
33: 		type test = Expect<
34: 			TypesAreEqual<
35: 				WillDisappear<Settings>,
36: 				{
37: 					readonly action: string;
38: 					readonly event: "willDisappear";
39: 					readonly context: string;
40: 					readonly device: string;
41: 					readonly payload:
42: 						| {
43: 								readonly isInMultiAction: false;
44: 								readonly controller: "Encoder" | "Keypad";
45: 								readonly coordinates: Coordinates;
46: 								settings: Settings;
47: 								readonly state?: State;
48: 						  }
49: 						| {
50: 								readonly isInMultiAction: true;
51: 								readonly controller: "Keypad";
52: 								settings: Settings;
53: 								readonly state?: State;
54: 						  };
55: 				}
56: 			>
57: 		>;
58: 	});
59: });
</file>

<file path="src/api/events/__tests__/system.test.ts">
 1: import { DidReceiveDeepLink } from "..";
 2: import { Expect, TypesAreEqual } from "../../../../tests/utils";
 3: describe("system event types", () => {
 4: 	it("didReceiveDeepLink", () => {
 5: 		type test = Expect<
 6: 			TypesAreEqual<
 7: 				DidReceiveDeepLink,
 8: 				{
 9: 					readonly event: "didReceiveDeepLink";
10: 					readonly payload: {
11: 						readonly url: string;
12: 					};
13: 				}
14: 			>
15: 		>;
16: 	});
17: });
</file>

<file path="src/api/events/action.ts">
 1: import type { Controller, DeviceType } from "@elgato/schemas/streamdeck/plugins";
 2: import type { JsonObject } from "../../common/json";
 3: import type { DeviceIdentifier } from "./device";
 4: import type { EventIdentifier } from "./index";
 5: export type DidReceiveSettings<TSettings extends JsonObject> = ActionEventMessage<
 6: 	"didReceiveSettings",
 7: 	MultiActionPayload<TSettings> | SingleActionPayload<TSettings>
 8: >;
 9: export type TitleParametersDidChange<TSettings extends JsonObject> = ActionEventMessage<
10: 	"titleParametersDidChange",
11: 	Omit<SingleActionPayload<TSettings>, "isInMultiAction"> & {
12: 		readonly title: string;
13: 		readonly titleParameters: {
14: 			readonly fontFamily: string;
15: 			readonly fontSize: number;
16: 			readonly fontStyle: "" | "Bold Italic" | "Bold" | "Italic" | "Regular";
17: 			readonly fontUnderline: boolean;
18: 			readonly showTitle: boolean;
19: 			readonly titleAlignment: "bottom" | "middle" | "top";
20: 			readonly titleColor: string;
21: 		};
22: 	}
23: >;
24: export type WillAppear<TSettings extends JsonObject> = ActionEventMessage<
25: 	"willAppear",
26: 	MultiActionPayload<TSettings> | SingleActionPayload<TSettings>
27: >;
28: export type WillDisappear<TSettings extends JsonObject> = ActionEventMessage<
29: 	"willDisappear",
30: 	MultiActionPayload<TSettings> | SingleActionPayload<TSettings>
31: >;
32: export type ActionIdentifier = {
33: 	readonly action: string;
34: 	readonly context: string;
35: };
36: export type ActionEventMessage<TEvent extends string, TPayload> = ActionIdentifier &
37: 	DeviceIdentifier &
38: 	EventIdentifier<TEvent> & {
39: 		readonly payload: TPayload;
40: 	};
41: export type ActionEventMessageWithoutPayload<TEvent extends string> = Omit<ActionEventMessage<TEvent, void>, "payload">;
42: export type SingleActionPayload<
43: 	TSettings extends JsonObject,
44: 	TController extends Controller = Controller,
45: > = ActionPayload<TSettings> & {
46: 	readonly coordinates: Coordinates;
47: 	readonly controller: TController;
48: 	readonly isInMultiAction: false;
49: };
50: export type MultiActionPayload<TSettings extends JsonObject> = ActionPayload<TSettings> & {
51: 	readonly controller: "Keypad";
52: 	readonly isInMultiAction: true;
53: };
54: type ActionPayload<TSettings extends JsonObject> = {
55: 	settings: TSettings;
56: 	readonly state?: State;
57: };
58: export type Coordinates = {
59: 	readonly column: number;
60: 	readonly row: number;
61: };
62: export type State = number;
</file>

<file path="src/api/events/device.ts">
 1: import type { DeviceInfo } from "../device";
 2: import type { EventIdentifier } from "./index";
 3: export type DeviceDidConnect = DeviceIdentifier &
 4: 	EventIdentifier<"deviceDidConnect"> & {
 5: 		readonly deviceInfo: DeviceInfo;
 6: 	};
 7: export type DeviceDidDisconnect = DeviceIdentifier & EventIdentifier<"deviceDidDisconnect">;
 8: export type DeviceIdentifier = {
 9: 	readonly device: string;
10: };
</file>

<file path="src/api/events/encoder.ts">
 1: import type { JsonObject } from "../../common/json";
 2: import type { ActionEventMessage, Coordinates, SingleActionPayload } from "./action";
 3: import type { KeyDown, KeyUp } from "./keypad";
 4: export type DialDown<TSettings extends JsonObject> = ActionEventMessage<"dialDown", EncoderPayload<TSettings>>;
 5: export type DialUp<TSettings extends JsonObject> = ActionEventMessage<"dialUp", EncoderPayload<TSettings>>;
 6: export type DialRotate<TSettings extends JsonObject> = ActionEventMessage<
 7: 	"dialRotate",
 8: 	EncoderPayload<TSettings> & {
 9: 		readonly pressed: boolean;
10: 		readonly ticks: number;
11: 	}
12: >;
13: export type TouchTap<TSettings extends JsonObject> = ActionEventMessage<
14: 	"touchTap",
15: 	EncoderPayload<TSettings> & {
16: 		readonly hold: boolean;
17: 		readonly tapPos: [x: number, y: number];
18: 	}
19: >;
20: type EncoderPayload<TSettings extends JsonObject> = Pick<
21: 	SingleActionPayload<TSettings, "Encoder">,
22: 	"controller" | "settings"
23: > & {
24: 	readonly coordinates: Coordinates;
25: };
</file>

<file path="src/api/events/index.ts">
 1: import type { JsonObject, JsonValue } from "../../common/json";
 2: import type { DidReceiveSettings, TitleParametersDidChange, WillAppear, WillDisappear } from "./action";
 3: import type { DeviceDidConnect, DeviceDidDisconnect } from "./device";
 4: import type { DialDown, DialRotate, DialUp, TouchTap } from "./encoder";
 5: import type { KeyDown, KeyUp } from "./keypad";
 6: import type {
 7: 	ApplicationDidLaunch,
 8: 	ApplicationDidTerminate,
 9: 	DidReceiveDeepLink,
10: 	DidReceiveGlobalSettings,
11: 	SystemDidWakeUp,
12: } from "./system";
13: import type {
14: 	DidReceivePluginMessage,
15: 	DidReceivePropertyInspectorMessage,
16: 	PropertyInspectorDidAppear,
17: 	PropertyInspectorDidDisappear,
18: } from "./ui";
19: export { type Controller } from "@elgato/schemas/streamdeck/plugins";
20: export { type ActionIdentifier, type State } from "./action";
21: export { type DeviceIdentifier } from "./device";
22: export {
23: 	type Coordinates,
24: 	type DidReceiveSettings,
25: 	type TitleParametersDidChange,
26: 	type WillAppear,
27: 	type WillDisappear,
28: } from "./action";
29: export { type DeviceDidConnect, type DeviceDidDisconnect } from "./device";
30: export { type DialDown, type DialRotate, type DialUp, type TouchTap } from "./encoder";
31: export { type KeyDown, type KeyUp } from "./keypad";
32: export {
33: 	type ApplicationDidLaunch,
34: 	type ApplicationDidTerminate,
35: 	type DidReceiveDeepLink,
36: 	type DidReceiveGlobalSettings,
37: 	type SystemDidWakeUp,
38: } from "./system";
39: export {
40: 	type DidReceivePluginMessage,
41: 	type DidReceivePropertyInspectorMessage,
42: 	type PropertyInspectorDidAppear,
43: 	type PropertyInspectorDidDisappear,
44: } from "./ui";
45: export type EventIdentifier<TEvent> = {
46: 	readonly event: TEvent;
47: };
48: export type PluginEvent =
49: 	| ApplicationDidLaunch
50: 	| ApplicationDidTerminate
51: 	| DeviceDidConnect
52: 	| DeviceDidDisconnect
53: 	| DialDown<JsonObject>
54: 	| DialRotate<JsonObject>
55: 	| DialUp<JsonObject>
56: 	| DidReceiveDeepLink
57: 	| DidReceiveGlobalSettings<JsonObject>
58: 	| DidReceivePropertyInspectorMessage<JsonValue>
59: 	| DidReceiveSettings<JsonObject>
60: 	| KeyDown<JsonObject>
61: 	| KeyUp<JsonObject>
62: 	| PropertyInspectorDidAppear
63: 	| PropertyInspectorDidDisappear
64: 	| SystemDidWakeUp
65: 	| TitleParametersDidChange<JsonObject>
66: 	| TouchTap<JsonObject>
67: 	| WillAppear<JsonObject>
68: 	| WillDisappear<JsonObject>;
69: export type PluginEventMap = {
70: 	[K in PluginEvent["event"]]: [event: Extract<PluginEvent, EventIdentifier<K>>];
71: };
72: export type UIEvent =
73: 	| DidReceiveGlobalSettings<JsonObject>
74: 	| DidReceivePluginMessage<JsonValue>
75: 	| DidReceiveSettings<JsonObject>;
76: export type UIEventMap = {
77: 	[K in UIEvent["event"]]: [event: Extract<UIEvent, EventIdentifier<K>>];
78: };
</file>

<file path="src/api/events/keypad.ts">
 1: import type { JsonObject } from "../../common/json";
 2: import type { ActionEventMessage, MultiActionPayload, SingleActionPayload, State } from "./action";
 3: import type { DialDown, DialUp } from "./encoder";
 4: export type KeyDown<TSettings extends JsonObject> = ActionEventMessage<
 5: 	"keyDown",
 6: 	MultiActionKeyGesturePayload<TSettings> | SingleActionPayload<TSettings, "Keypad">
 7: >;
 8: export type KeyUp<TSettings extends JsonObject> = ActionEventMessage<
 9: 	"keyUp",
10: 	MultiActionKeyGesturePayload<TSettings> | SingleActionPayload<TSettings, "Keypad">
11: >;
12: type MultiActionKeyGesturePayload<TSettings extends JsonObject> = MultiActionPayload<TSettings> & {
13: 	readonly userDesiredState: State;
14: };
</file>

<file path="src/api/events/system.ts">
 1: import type { Manifest } from "../";
 2: import type { JsonObject } from "../../common/json";
 3: import type { EventIdentifier } from "./index";
 4: export type ApplicationDidLaunch = ApplicationEventIdentifier<"applicationDidLaunch">;
 5: export type ApplicationDidTerminate = ApplicationEventIdentifier<"applicationDidTerminate">;
 6: export type DidReceiveGlobalSettings<TSettings extends JsonObject> = EventIdentifier<"didReceiveGlobalSettings"> & {
 7: 	readonly payload: {
 8: 		settings: TSettings;
 9: 	};
10: };
11: export type DidReceiveDeepLink = EventIdentifier<"didReceiveDeepLink"> & {
12: 	readonly payload: {
13: 		readonly url: string;
14: 	};
15: };
16: export type SystemDidWakeUp = EventIdentifier<"systemDidWakeUp">;
17: type ApplicationEventIdentifier<TEvent> = EventIdentifier<TEvent> & {
18: 	readonly payload: {
19: 		readonly application: string;
20: 	};
21: };
</file>

<file path="src/api/events/ui.ts">
 1: import type { JsonValue } from "../../common/json";
 2: import type { ActionEventMessage, ActionEventMessageWithoutPayload } from "./action";
 3: import type { DeviceIdentifier } from "./device";
 4: export type PropertyInspectorDidAppear = ActionEventMessageWithoutPayload<"propertyInspectorDidAppear">;
 5: export type PropertyInspectorDidDisappear = ActionEventMessageWithoutPayload<"propertyInspectorDidDisappear">;
 6: type PluginMessage<TEvent extends string, TPayload extends JsonValue> = Omit<
 7: 	ActionEventMessage<TEvent, TPayload>,
 8: 	keyof DeviceIdentifier
 9: >;
10: export type DidReceivePropertyInspectorMessage<TPayload extends JsonValue> = PluginMessage<"sendToPlugin", TPayload>;
11: export type DidReceivePluginMessage<TPayload extends JsonValue> = PluginMessage<"sendToPropertyInspector", TPayload>;
</file>

<file path="src/api/registration/__mocks__/index.ts">
 1: import { type ActionInfo, type RegistrationInfo } from "../";
 2: import { DeviceType } from "../../device";
 3: export const actionInfo: ActionInfo = {
 4: 	action: "com.elgato.test.actionOne",
 5: 	context: "abc123",
 6: 	device: "dev123",
 7: 	payload: {
 8: 		controller: "Keypad",
 9: 		isInMultiAction: false,
10: 		coordinates: {
11: 			column: 1,
12: 			row: 2,
13: 		},
14: 		settings: {
15: 			message: "Hello world",
16: 		},
17: 	},
18: };
19: export const registrationInfo: RegistrationInfo = {
20: 	application: {
21: 		font: "Arial",
22: 		language: "en",
23: 		platform: "windows",
24: 		platformVersion: "11",
25: 		version: "99.8.6.54321",
26: 	},
27: 	colors: {
28: 		buttonMouseOverBackgroundColor: "#ffffff",
29: 		buttonPressedBackgroundColor: "#ffffff",
30: 		buttonPressedBorderColor: "#ffffff",
31: 		buttonPressedTextColor: "#ffffff",
32: 		highlightColor: "#ffffff",
33: 	},
34: 	devicePixelRatio: 1,
35: 	devices: [
36: 		{
37: 			id: "DEV1",
38: 			name: "Device One",
39: 			size: {
40: 				columns: 5,
41: 				rows: 3,
42: 			},
43: 			type: DeviceType.StreamDeck,
44: 		},
45: 	],
46: 	plugin: {
47: 		uuid: "com.elgato.test",
48: 		version: "1.0",
49: 	},
50: };
</file>

<file path="src/api/registration/index.ts">
1: export { type RegistrationInfo } from "./info";
2: export { RegistrationParameter } from "./parameters";
3: export { type ActionInfo, type ConnectElgatoStreamDeckSocketFn } from "./ui";
</file>

<file path="src/api/registration/info.ts">
 1: import type { DeviceInfo } from "../device";
 2: import type { Language } from "../i18n";
 3: export type RegistrationInfo = {
 4: 	readonly application: {
 5: 		readonly font: string;
 6: 		readonly language: Language;
 7: 		readonly platform: "mac" | "windows";
 8: 		readonly platformVersion: string;
 9: 		readonly version: string;
10: 	};
11: 	readonly colors: {
12: 		readonly buttonMouseOverBackgroundColor: string;
13: 		readonly buttonPressedBackgroundColor: string;
14: 		readonly buttonPressedBorderColor: string;
15: 		readonly buttonPressedTextColor: string;
16: 		readonly highlightColor: string;
17: 	};
18: 	readonly devicePixelRatio: number;
19: 	readonly devices: (DeviceInfo & {
20: 		readonly id: string;
21: 	})[];
22: 	readonly plugin: {
23: 		readonly uuid: string;
24: 		readonly version: string;
25: 	};
26: };
</file>

<file path="src/api/registration/parameters.ts">
1: export enum RegistrationParameter {
2: 	Port = "-port",
3: 	Info = "-info",
4: 	PluginUUID = "-pluginUUID",
5: 	RegisterEvent = "-registerEvent",
6: }
</file>

<file path="src/api/registration/ui.ts">
 1: import type { JsonObject } from "../../common/json";
 2: import type { ActionIdentifier, DeviceIdentifier } from "../events";
 3: import type { MultiActionPayload, SingleActionPayload } from "../events/action";
 4: export type ConnectElgatoStreamDeckSocketFn = (
 5: 	port: string,
 6: 	uuid: string,
 7: 	event: string,
 8: 	info: string,
 9: 	actionInfo: string,
10: ) => Promise<void> | void;
11: export type ActionInfo<TSettings extends JsonObject = JsonObject> = ActionIdentifier &
12: 	DeviceIdentifier & {
13: 		readonly payload: MultiActionPayload<TSettings> | SingleActionPayload<TSettings>;
14: 	};
</file>

<file path="src/api/command.ts">
  1: import type { JsonObject, JsonValue } from "../plugin";
  2: import type { ActionIdentifier, DidReceiveGlobalSettings, DidReceiveSettings, State } from "./events";
  3: import type { FeedbackPayload } from "./layout";
  4: import type { Target } from "./target";
  5: type CommandBase<TCommand> = {
  6: 	event: TCommand;
  7: };
  8: type CommandBaseWithPayload<TCommand, TPayload> = CommandBase<TCommand> & {
  9: 	payload: TPayload;
 10: };
 11: type ContextualizedCommand<TCommand> = CommandBase<TCommand> & {
 12: 	context: string;
 13: };
 14: type ContextualizedCommandWithPayload<TCommand, TPayload> = ContextualizedCommand<TCommand> & {
 15: 	payload: TPayload;
 16: };
 17: export type SetSettings = ContextualizedCommandWithPayload<"setSettings", JsonObject>;
 18: export type UISetSettings = ActionIdentifier & SetSettings;
 19: export type GetSettings = ContextualizedCommand<"getSettings">;
 20: export type UIGetSettings = ActionIdentifier & GetSettings;
 21: export type SetGlobalSettings = ContextualizedCommandWithPayload<"setGlobalSettings", JsonObject>;
 22: export type GetGlobalSettings = ContextualizedCommand<"getGlobalSettings">;
 23: export type OpenUrl = CommandBaseWithPayload<
 24: 	"openUrl",
 25: 	{
 26: 		url: string;
 27: 	}
 28: >;
 29: export type LogMessage = CommandBaseWithPayload<
 30: 	"logMessage",
 31: 	{
 32: 		message: string;
 33: 	}
 34: >;
 35: export type SetTitle = ContextualizedCommandWithPayload<
 36: 	"setTitle",
 37: 	{
 38: 		state?: State;
 39: 		target?: Target;
 40: 		title?: string;
 41: 	}
 42: >;
 43: export type SetImage = ContextualizedCommandWithPayload<
 44: 	"setImage",
 45: 	{
 46: 		image?: string;
 47: 		state?: State;
 48: 		target?: Target;
 49: 	}
 50: >;
 51: export type SetFeedback = ContextualizedCommandWithPayload<"setFeedback", FeedbackPayload>;
 52: export type SetFeedbackLayout = ContextualizedCommandWithPayload<
 53: 	"setFeedbackLayout",
 54: 	{
 55: 		layout: string;
 56: 	}
 57: >;
 58: export type ShowAlert = ContextualizedCommand<"showAlert">;
 59: export type ShowOk = ContextualizedCommand<"showOk">;
 60: export type SetState = ContextualizedCommandWithPayload<
 61: 	"setState",
 62: 	{
 63: 		state: State;
 64: 	}
 65: >;
 66: export type SetTriggerDescription = ContextualizedCommandWithPayload<
 67: 	"setTriggerDescription",
 68: 	{
 69: 		longTouch?: string;
 70: 		push?: string;
 71: 		rotate?: string;
 72: 		touch?: string;
 73: 	}
 74: >;
 75: export type SwitchToProfile = ContextualizedCommandWithPayload<
 76: 	"switchToProfile",
 77: 	{
 78: 		page?: number;
 79: 		profile?: string;
 80: 	}
 81: > & {
 82: 	device: string;
 83: };
 84: export type SendToPropertyInspector<TPayload extends JsonValue = JsonValue> = ContextualizedCommandWithPayload<
 85: 	"sendToPropertyInspector",
 86: 	TPayload
 87: >;
 88: export type SendToPlugin<TPayload extends JsonValue = JsonValue> = ActionIdentifier &
 89: 	CommandBaseWithPayload<"sendToPlugin", TPayload>;
 90: export type PluginCommand =
 91: 	| GetGlobalSettings
 92: 	| GetSettings
 93: 	| LogMessage
 94: 	| OpenUrl
 95: 	| SendToPropertyInspector
 96: 	| SetFeedback
 97: 	| SetFeedbackLayout
 98: 	| SetGlobalSettings
 99: 	| SetImage
100: 	| SetSettings
101: 	| SetState
102: 	| SetTitle
103: 	| SetTriggerDescription
104: 	| ShowAlert
105: 	| ShowOk
106: 	| SwitchToProfile;
107: export type UICommand = GetGlobalSettings | OpenUrl | SendToPlugin | SetGlobalSettings | UIGetSettings | UISetSettings;
</file>

<file path="src/api/device.ts">
 1: import { DeviceType } from "@elgato/schemas/streamdeck/plugins";
 2: export { DeviceType };
 3: export type DeviceInfo = {
 4: 	readonly name: string;
 5: 	readonly size: Size;
 6: 	readonly type: DeviceType;
 7: };
 8: export type Size = {
 9: 	readonly columns: number;
10: 	readonly rows: number;
11: };
</file>

<file path="src/api/i18n.ts">
1: export const supportedLanguages = ["de", "en", "es", "fr", "ja", "ko", "zh_CN", "zh_TW"] as const;
2: export type Language = (typeof supportedLanguages)[number];
</file>

<file path="src/api/index.ts">
1: export * from "./command";
2: export * from "./device";
3: export * from "./events";
4: export * from "./i18n";
5: export * from "./layout";
6: export * from "./registration";
7: export * from "./target";
8: export { type Manifest } from "@elgato/schemas/streamdeck/plugins";
</file>

<file path="src/api/layout.ts">
 1: import * as schemas from "@elgato/schemas/streamdeck/plugins";
 2: export { BarSubType } from "@elgato/schemas/streamdeck/plugins";
 3: export type Bar = FeedbackPayloadItem<schemas.Bar>;
 4: export type GBar = FeedbackPayloadItem<schemas.GBar>;
 5: export type Pixmap = FeedbackPayloadItem<schemas.Pixmap>;
 6: export type Text = FeedbackPayloadItem<schemas.Text>;
 7: export type FeedbackPayload = Record<string, Bar | GBar | Pixmap | Text | number | string>;
 8: type FeedbackPayloadItem<T extends schemas.Bar | schemas.GBar | schemas.Pixmap | schemas.Text> = Partial<
 9: 	Omit<T, "key" | "rect" | "type">
10: >;
</file>

<file path="src/api/target.ts">
1: export enum Target {
2: 	HardwareAndSoftware = 0,
3: 	Hardware = 1,
4: 	Software = 2,
5: }
</file>

<file path="src/common/__tests__/disposable.test.ts">
 1: import { deferredDisposable, type IDisposable } from "../disposable";
 2: describe("deferredDisposable", () => {
 3: 	describe("dispose", () => {
 4: 		it("invokes delegate", () => {
 5: 			const listener = jest.fn();
 6: 			const disposable = deferredDisposable(listener);
 7: 			disposable.dispose();
 8: 			expect(listener).toHaveBeenCalledTimes(1);
 9: 		});
10: 		it("invokes delegate once only", () => {
11: 			const listener = jest.fn();
12: 			const disposable = deferredDisposable(listener);
13: 			disposable.dispose();
14: 			disposable.dispose();
15: 			disposable.dispose();
16: 			expect(listener).toHaveBeenCalledTimes(1);
17: 		});
18: 	});
19: 	describe("[Symbol.dispose]", () => {
20: 		it("invokes delegate", () => {
21: 			const listener = jest.fn();
22: 			{
23: 				using disposable = deferredDisposable(listener);
24: 			}
25: 			expect(listener).toHaveBeenCalledTimes(1);
26: 		});
27: 		it("invokes delegate once only", () => {
28: 			const listener = jest.fn();
29: 			{
30: 				using disposable = deferredDisposable(listener);
31: 				disposable[Symbol.dispose]();
32: 				disposable[Symbol.dispose]();
33: 			}
34: 			expect(listener).toHaveBeenCalledTimes(1);
35: 		});
36: 	});
37: 	describe("dispose and [Symbol.dispose]", () => {
38: 		it("invokes delegate once only", () => {
39: 			const listener = jest.fn();
40: 			{
41: 				using disposable = deferredDisposable(listener);
42: 				disposable.dispose();
43: 				disposable[Symbol.dispose]();
44: 			}
45: 			expect(listener).toHaveBeenCalledTimes(1);
46: 		});
47: 	});
48: });
</file>

<file path="src/common/__tests__/enumerable.test.ts">
  1: import { Enumerable } from "../enumerable";
  2: describe("Enumerable", () => {
  3: 	const source = [
  4: 		{ name: "Facecam" },
  5: 		{ name: "Stream Deck" },
  6: 		{ name: "Wave DX" },
  7: 	];
  8: 	const enumerable = new Enumerable(source);
  9: 	describe("constructor", () => {
 10: 		describe("Enumerable<T>", () => {
 11: 			it("iterates enumerable", () => {
 12: 				const fn = jest.fn();
 13: 				const arr = [1, 2];
 14: 				const source = new Enumerable(arr);
 15: 				const enumerable = new Enumerable(source);
 16: 				arr.push(3, 4);
 17: 				enumerable.forEach(fn);
 18: 				expect(enumerable.length).toBe(4);
 19: 				expect(fn).toHaveBeenCalledTimes(4);
 20: 				expect(fn).toHaveBeenNthCalledWith(1, 1);
 21: 				expect(fn).toHaveBeenNthCalledWith(2, 2);
 22: 				expect(fn).toHaveBeenNthCalledWith(3, 3);
 23: 				expect(fn).toHaveBeenNthCalledWith(4, 4);
 24: 			});
 25: 			it("reads length", () => {
 26: 				const arr = [1];
 27: 				const source = new Enumerable(arr);
 28: 				const enumerable = new Enumerable(source);
 29: 				expect(enumerable.length).toBe(1);
 30: 				arr.push(2);
 31: 				expect(enumerable.length).toBe(2);
 32: 			});
 33: 		});
 34: 		describe("T[]", () => {
 35: 			it("iterates mutated array", () => {
 36: 				const fn = jest.fn();
 37: 				const arr = [1, 2];
 38: 				const enumerable = new Enumerable(arr);
 39: 				arr.push(3, 4);
 40: 				enumerable.forEach(fn);
 41: 				expect(enumerable.length).toBe(4);
 42: 				expect(fn).toHaveBeenCalledTimes(4);
 43: 				expect(fn).toHaveBeenNthCalledWith(1, 1);
 44: 				expect(fn).toHaveBeenNthCalledWith(2, 2);
 45: 				expect(fn).toHaveBeenNthCalledWith(3, 3);
 46: 				expect(fn).toHaveBeenNthCalledWith(4, 4);
 47: 			});
 48: 			it("reads length", () => {
 49: 				const arr = [1];
 50: 				const enumerable = new Enumerable(arr);
 51: 				expect(enumerable.length).toBe(1);
 52: 				arr.push(2);
 53: 				expect(enumerable.length).toBe(2);
 54: 			});
 55: 		});
 56: 		describe("Map<K, T>", () => {
 57: 			it("iterates mutated map", () => {
 58: 				const fnBefore = jest.fn();
 59: 				const map = new Map([
 60: 					[1, "One"],
 61: 					[2, "Two"],
 62: 				]);
 63: 				const enumerable = new Enumerable(map);
 64: 				enumerable.forEach(fnBefore);
 65: 				expect(enumerable.length).toBe(2);
 66: 				expect(fnBefore).toHaveBeenCalledTimes(2);
 67: 				expect(fnBefore).toHaveBeenNthCalledWith(1, "One");
 68: 				expect(fnBefore).toHaveBeenNthCalledWith(2, "Two");
 69: 				const fnAfter = jest.fn();
 70: 				map.set(1, "A");
 71: 				map.set(3, "Three");
 72: 				enumerable.forEach(fnAfter);
 73: 				expect(enumerable.length).toBe(3);
 74: 				expect(fnAfter).toHaveBeenCalledTimes(3);
 75: 				expect(fnAfter).toHaveBeenNthCalledWith(1, "A");
 76: 				expect(fnAfter).toHaveBeenNthCalledWith(2, "Two");
 77: 				expect(fnAfter).toHaveBeenNthCalledWith(3, "Three");
 78: 			});
 79: 			it("reads length", () => {
 80: 				const map = new Map([
 81: 					[1, "One"],
 82: 					[2, "Two"],
 83: 				]);
 84: 				const enumerable = new Enumerable(map);
 85: 				expect(enumerable.length).toBe(2);
 86: 				map.delete(1);
 87: 				map.set(3, "Three");
 88: 				map.set(4, "Four");
 89: 				expect(enumerable.length).toBe(3);
 90: 			});
 91: 		});
 92: 		describe("Set<T>", () => {
 93: 			it("iterates mutated map", () => {
 94: 				const fnBefore = jest.fn();
 95: 				const set = new Set(["One", "Two"]);
 96: 				const enumerable = new Enumerable(set);
 97: 				enumerable.forEach(fnBefore);
 98: 				expect(enumerable.length).toBe(2);
 99: 				expect(fnBefore).toHaveBeenCalledTimes(2);
100: 				expect(fnBefore).toHaveBeenNthCalledWith(1, "One");
101: 				expect(fnBefore).toHaveBeenNthCalledWith(2, "Two");
102: 				const fnAfter = jest.fn();
103: 				set.delete("One");
104: 				set.add("Three");
105: 				enumerable.forEach(fnAfter);
106: 				expect(enumerable.length).toBe(2);
107: 				expect(fnAfter).toHaveBeenCalledTimes(2);
108: 				expect(fnAfter).toHaveBeenNthCalledWith(1, "Two");
109: 				expect(fnAfter).toHaveBeenNthCalledWith(2, "Three");
110: 			});
111: 			it("reads length", () => {
112: 				const set = new Set(["One", "Two"]);
113: 				const enumerable = new Enumerable(set);
114: 				expect(enumerable.length).toBe(2);
115: 				set.delete("One");
116: 				set.add("Three");
117: 				set.add("Four");
118: 				expect(enumerable.length).toBe(3);
119: 			});
120: 		});
121: 		describe("IterableIterator", () => {
122: 			it("iterates mutated map", () => {
123: 				const fn = jest.fn();
124: 				const itr = function* () {
125: 					yield "One";
126: 					yield "Two";
127: 				};
128: 				const enumerable = new Enumerable(itr);
129: 				enumerable.forEach(fn);
130: 				expect(enumerable.length).toBe(2);
131: 				expect(fn).toHaveBeenCalledTimes(2);
132: 				expect(fn).toHaveBeenNthCalledWith(1, "One");
133: 				expect(fn).toHaveBeenNthCalledWith(2, "Two");
134: 			});
135: 			it("reads length", () => {
136: 				const itr = function* () {
137: 					yield "One";
138: 					yield "Two";
139: 				};
140: 				const enumerable = new Enumerable(itr);
141: 				expect(enumerable.length).toBe(2);
142: 			});
143: 		});
144: 	});
145: 	describe("IterableIterator implementation", () => {
146: 		describe("next", () => {
147: 			it("iterates all items", () => {
148: 				const enumerable = new Enumerable(["One", "Two", "Three"]);
149: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "One" });
150: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "Two" });
151: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "Three" });
152: 				expect(enumerable.next()).toStrictEqual({ done: true, value: undefined });
153: 			});
154: 			it("re-captures on return", () => {
155: 				const enumerable = new Enumerable(["One", "Two", "Three"]);
156: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "One" });
157: 				expect(enumerable.return?.("Stop")).toStrictEqual({ done: true, value: "Stop" });
158: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "One" });
159: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "Two" });
160: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "Three" });
161: 				expect(enumerable.next()).toStrictEqual({ done: true, value: undefined });
162: 			});
163: 			it("does not re-capture on throw", () => {
164: 				const enumerable = new Enumerable(["One", "Two", "Three"]);
165: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "One" });
166: 				expect(() => enumerable.throw?.("Staged error")).toThrow("Staged error");
167: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "Two" });
168: 				expect(enumerable.next()).toStrictEqual({ done: false, value: "Three" });
169: 				expect(enumerable.next()).toStrictEqual({ done: true, value: undefined });
170: 			});
171: 		});
172: 		test("return", () => {
173: 			const enumerable = new Enumerable([1, 2, 3]);
174: 			const res = enumerable.return?.("Hello world");
175: 			expect(res?.done).toBe(true);
176: 			expect(res?.value).toBe("Hello world");
177: 		});
178: 		test("throw", () => {
179: 			const enumerable = new Enumerable([1, 2, 3]);
180: 			expect(() => enumerable.throw?.("Hello world")).toThrow("Hello world");
181: 		});
182: 	});
183: 	describe("iterator helpers", () => {
184: 		it("chains iterators", () => {
185: 			const fn = jest.fn();
186: 			const source = ["One", "Two", "Three"];
187: 			const enumerable = new Enumerable(source);
188: 			enumerable
189: 				.asIndexedPairs()
190: 				.drop(1)
191: 				.flatMap(([i, value]) => [i, value].values())
192: 				.filter((x) => typeof x === "number")
193: 				.map((x) => {
194: 					return { value: x };
195: 				})
196: 				.take(1)
197: 				.forEach(fn);
198: 			expect(fn).toHaveBeenCalledTimes(1);
199: 			expect(fn).toHaveBeenNthCalledWith(1, { value: 1 });
200: 		});
201: 		it("should not iterate unless necessary", () => {
202: 			const fn = jest.fn();
203: 			const enumerable = new Enumerable(fn);
204: 			enumerable
205: 				.asIndexedPairs()
206: 				.drop(1)
207: 				.flatMap(([i, value]) => [i, value].values())
208: 				.filter((x) => typeof x === "number")
209: 				.map((x) => {
210: 					return { value: x };
211: 				})
212: 				.take(1);
213: 			expect(fn).toHaveBeenCalledTimes(0);
214: 		});
215: 	});
216: 	describe("iterator", () => {
217: 		const source = ["a", "b", "c"];
218: 		const enumerable = new Enumerable(source);
219: 		let i = 0;
220: 		for (const item of enumerable) {
221: 			expect(item).toBe(source[i++]);
222: 		}
223: 		expect(i).toBe(3);
224: 	});
225: 	test("asIndexedPairs", () => {
226: 		const fn = jest.fn();
227: 		const res = enumerable.asIndexedPairs();
228: 		res.forEach(fn);
229: 		expect(fn).toHaveBeenCalledTimes(3);
230: 		expect(fn).toHaveBeenNthCalledWith(1, [0, { name: "Facecam" }]);
231: 		expect(fn).toHaveBeenNthCalledWith(2, [1, { name: "Stream Deck" }]);
232: 		expect(fn).toHaveBeenNthCalledWith(3, [2, { name: "Wave DX" }]);
233: 	});
234: 	describe("drop", () => {
235: 		it("accepts limit 0", () => {
236: 			expect(enumerable.drop(0).length).toBe(source.length);
237: 		});
238: 		it("accepts limit 1", () => {
239: 			const fn = jest.fn();
240: 			const res = enumerable.drop(1);
241: 			res.forEach(fn);
242: 			expect(fn).toHaveBeenCalledTimes(2);
243: 			expect(fn).toHaveBeenNthCalledWith(1, { name: "Stream Deck" });
244: 			expect(fn).toHaveBeenNthCalledWith(2, { name: "Wave DX" });
245: 		});
246: 		it("accepts limit less than length", () => {
247: 			const fn = jest.fn();
248: 			const res = enumerable.drop(2);
249: 			res.forEach(fn);
250: 			expect(fn).toHaveBeenCalledTimes(1);
251: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
252: 		});
253: 		it("accepts limit exceeding length", () => {
254: 			const fn = jest.fn();
255: 			const res = enumerable.drop(4);
256: 			res.forEach(fn);
257: 			expect(fn).toHaveBeenCalledTimes(0);
258: 		});
259: 		it("throw for negative", () => {
260: 			expect(() => enumerable.drop(-1)).toThrow(RangeError);
261: 		});
262: 		it("throw for NaN", () => {
263: 			expect(() => enumerable.drop("false")).toThrow(RangeError);
264: 		});
265: 	});
266: 	describe("every", () => {
267: 		it("evaluates all when needed", () => {
268: 			expect(enumerable.every((x) => typeof x.name === "string")).toBeTruthy();
269: 		});
270: 		it("evaluates lazily", () => {
271: 			const fn = jest.fn().mockReturnValue(false);
272: 			const every = enumerable.every(fn);
273: 			expect(every).toBeFalsy();
274: 			expect(fn).toHaveBeenCalledTimes(1);
275: 			expect(fn).toHaveBeenCalledWith({
276: 				name: "Facecam",
277: 			});
278: 		});
279: 	});
280: 	describe("filter", () => {
281: 		it("filters items", () => {
282: 			const fn = jest.fn().mockImplementation((x) => x.name !== "Stream Deck");
283: 			const filtered = Array.from(enumerable.filter(fn));
284: 			expect(fn).toHaveBeenCalledTimes(3);
285: 			expect(fn).toHaveBeenNthCalledWith(1, { name: "Facecam" });
286: 			expect(fn).toHaveBeenNthCalledWith(2, { name: "Stream Deck" });
287: 			expect(fn).toHaveBeenNthCalledWith(3, { name: "Wave DX" });
288: 			expect(filtered).toHaveLength(2);
289: 			expect(filtered.at(0)).toEqual({ name: "Facecam" });
290: 			expect(filtered.at(1)).toEqual({ name: "Wave DX" });
291: 		});
292: 		it("can return no items", () => {
293: 			const filtered = Array.from(enumerable.filter((x) => x.name === "Test"));
294: 			expect(filtered).toHaveLength(0);
295: 		});
296: 		it("dot not evaluate unless iterated", () => {
297: 			const fn = jest.fn();
298: 			enumerable.filter(fn);
299: 			expect(fn).toHaveBeenCalledTimes(0);
300: 		});
301: 	});
302: 	describe("find", () => {
303: 		it("finds the first", () => {
304: 			const fn = jest.fn().mockImplementation((x) => x.name === "Facecam");
305: 			const item = enumerable.find(fn);
306: 			expect(item).toEqual({ name: "Facecam" });
307: 			expect(fn).toHaveBeenCalledTimes(1);
308: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
309: 		});
310: 		it("finds the last", () => {
311: 			const fn = jest.fn().mockImplementation((x) => x.name === "Wave DX");
312: 			const item = enumerable.find(fn);
313: 			expect(item).toEqual({ name: "Wave DX" });
314: 			expect(fn).toHaveBeenCalledTimes(3);
315: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
316: 			expect(fn).toHaveBeenCalledWith({ name: "Stream Deck" });
317: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
318: 		});
319: 		it("can find nothing", () => {
320: 			const fn = jest.fn().mockImplementation((x) => x.name === "Top secret product");
321: 			const item = enumerable.find(fn);
322: 			expect(item).toBeUndefined();
323: 			expect(fn).toHaveBeenCalledTimes(3);
324: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
325: 			expect(fn).toHaveBeenCalledWith({ name: "Stream Deck" });
326: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
327: 		});
328: 	});
329: 	describe("findLast", () => {
330: 		it("finds the first", () => {
331: 			const fn = jest.fn().mockImplementation((x) => !x.name.match(/\s+/));
332: 			const item = enumerable.findLast(fn);
333: 			expect(item).toEqual({ name: "Facecam" });
334: 			expect(fn).toHaveBeenCalledTimes(3);
335: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
336: 			expect(fn).toHaveBeenCalledWith({ name: "Stream Deck" });
337: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
338: 		});
339: 		it("finds the last", () => {
340: 			const fn = jest.fn().mockImplementation((x) => x.name.match(/\s+/));
341: 			const item = enumerable.findLast(fn);
342: 			expect(item).toEqual({ name: "Wave DX" });
343: 			expect(fn).toHaveBeenCalledTimes(3);
344: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
345: 			expect(fn).toHaveBeenCalledWith({ name: "Stream Deck" });
346: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
347: 		});
348: 		it("can find nothing", () => {
349: 			const fn = jest.fn().mockImplementation((x) => x.name === "Top secret product");
350: 			const item = enumerable.findLast(fn);
351: 			expect(item).toBeUndefined();
352: 			expect(fn).toHaveBeenCalledTimes(3);
353: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
354: 			expect(fn).toHaveBeenCalledWith({ name: "Stream Deck" });
355: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
356: 		});
357: 	});
358: 	test("flatMap", () => {
359: 		const fn = jest.fn();
360: 		const res = enumerable.flatMap((x) => x.name.split(" ").values());
361: 		res.forEach(fn);
362: 		expect(fn).toHaveBeenCalledTimes(5);
363: 		expect(fn).toHaveBeenNthCalledWith(1, "Facecam");
364: 		expect(fn).toHaveBeenNthCalledWith(2, "Stream");
365: 		expect(fn).toHaveBeenNthCalledWith(3, "Deck");
366: 		expect(fn).toHaveBeenNthCalledWith(4, "Wave");
367: 		expect(fn).toHaveBeenNthCalledWith(5, "DX");
368: 	});
369: 	describe("forEach", () => {
370: 		it("iterates over items", () => {
371: 			const fn = jest.fn();
372: 			enumerable.forEach(fn);
373: 			expect(fn).toHaveBeenCalledTimes(3);
374: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
375: 			expect(fn).toHaveBeenCalledWith({ name: "Stream Deck" });
376: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
377: 		});
378: 	});
379: 	describe("includes", () => {
380: 		it("matches reference", () => {
381: 			expect(enumerable.includes(source[1])).toBeTruthy();
382: 			expect(enumerable.includes({ name: "Stream Deck" })).toBeFalsy();
383: 			expect(enumerable.includes(undefined!)).toBeFalsy();
384: 		});
385: 	});
386: 	describe("map", () => {
387: 		it("maps each item", () => {
388: 			const res = Array.from(enumerable.map(({ name }) => name));
389: 			expect(res).toHaveLength(3);
390: 			expect(res.at(0)).toBe("Facecam");
391: 			expect(res.at(1)).toBe("Stream Deck");
392: 			expect(res.at(2)).toBe("Wave DX");
393: 		});
394: 		it("returns an empty array", () => {
395: 			const empty = new Enumerable<number>([]);
396: 			const res = Array.from(empty.map((x) => x.toString()));
397: 			expect(res).toHaveLength(0);
398: 		});
399: 		it("dot not evaluate unless iterated", () => {
400: 			const fn = jest.fn();
401: 			enumerable.map(fn);
402: 			expect(fn).toHaveBeenCalledTimes(0);
403: 		});
404: 	});
405: 	describe("reduce", () => {
406: 		describe("without initial value", () => {
407: 			it("reduces all", () => {
408: 				const res = enumerable.reduce((prev, curr) => ({ name: `${prev.name}, ${curr.name}` }));
409: 				expect(res).toEqual({ name: "Facecam, Stream Deck, Wave DX" });
410: 			});
411: 			it("throws when empty", () => {
412: 				const empty = new Enumerable([]);
413: 				expect(() => empty.reduce((prev, curr) => curr)).toThrowError(
414: 					new TypeError("Reduce of empty enumerable with no initial value."),
415: 				);
416: 			});
417: 		});
418: 		describe("with initial value", () => {
419: 			it("reduces all", () => {
420: 				const res = enumerable.reduce((prev, curr) => `${prev}, ${curr.name}`, "Initial");
421: 				expect(res).toEqual("Initial, Facecam, Stream Deck, Wave DX");
422: 			});
423: 			it("reduces empty", () => {
424: 				const empty = new Enumerable([]);
425: 				expect(empty.reduce((prev, curr) => `${prev}, ${curr}`, "Initial")).toBe("Initial");
426: 			});
427: 		});
428: 	});
429: 	describe("some", () => {
430: 		it("evaluates lazily", () => {
431: 			const fn = jest.fn().mockReturnValue(true);
432: 			const some = enumerable.some(fn);
433: 			expect(some).toBeTruthy();
434: 			expect(fn).toHaveBeenCalledTimes(1);
435: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
436: 		});
437: 		it("evaluates all when needed", () => {
438: 			const fn = jest.fn().mockReturnValue(false);
439: 			const some = enumerable.some(fn);
440: 			expect(some).toBeFalsy();
441: 			expect(fn).toHaveBeenCalledTimes(3);
442: 			expect(fn).toHaveBeenCalledWith({ name: "Facecam" });
443: 			expect(fn).toHaveBeenCalledWith({ name: "Stream Deck" });
444: 			expect(fn).toHaveBeenCalledWith({ name: "Wave DX" });
445: 		});
446: 	});
447: 	describe("take", () => {
448: 		it("accepts limit 0", () => {
449: 			expect(enumerable.take(0).length).toBe(0);
450: 		});
451: 		it("accepts limit 1", () => {
452: 			const fn = jest.fn();
453: 			const res = enumerable.take(1);
454: 			res.forEach(fn);
455: 			expect(fn).toHaveBeenCalledTimes(1);
456: 			expect(fn).toHaveBeenNthCalledWith(1, { name: "Facecam" });
457: 		});
458: 		it("accepts limit less than length", () => {
459: 			const fn = jest.fn();
460: 			const res = enumerable.take(2);
461: 			res.forEach(fn);
462: 			expect(fn).toHaveBeenCalledTimes(2);
463: 			expect(fn).toHaveBeenNthCalledWith(1, { name: "Facecam" });
464: 			expect(fn).toHaveBeenNthCalledWith(2, { name: "Stream Deck" });
465: 		});
466: 		it("accepts limit exceeding length", () => {
467: 			const fn = jest.fn();
468: 			const res = enumerable.take(99);
469: 			res.forEach(fn);
470: 			expect(fn).toHaveBeenCalledTimes(3);
471: 			expect(fn).toHaveBeenNthCalledWith(1, { name: "Facecam" });
472: 			expect(fn).toHaveBeenNthCalledWith(2, { name: "Stream Deck" });
473: 			expect(fn).toHaveBeenNthCalledWith(3, { name: "Wave DX" });
474: 		});
475: 		it("throw for negative", () => {
476: 			expect(() => enumerable.take(-1)).toThrow(RangeError);
477: 		});
478: 		it("throw for NaN", () => {
479: 			expect(() => enumerable.take("false")).toThrow(RangeError);
480: 		});
481: 	});
482: 	describe("toArray", () => {
483: 		it("returns a new array of items", () => {
484: 			const arr = ["One", "Two"];
485: 			const enumerable = new Enumerable(arr);
486: 			const res = enumerable.toArray();
487: 			expect(arr).toEqual(res);
488: 			expect(arr).not.toBe(res);
489: 		});
490: 		it("can return an empty array", () => {
491: 			const enumerable = new Enumerable(function* () {});
492: 			const res = enumerable.toArray();
493: 			expect(res).toHaveLength(0);
494: 		});
495: 	});
496: 	test("toJSON", () => {
497: 		const arr = ["One", "Two"];
498: 		const enumerable = new Enumerable(arr);
499: 		expect(JSON.stringify(arr)).toEqual(JSON.stringify(enumerable));
500: 	});
501: 	test("toString", () => {
502: 		const arr = ["One", "Two"];
503: 		const enumerable = new Enumerable(arr);
504: 		expect(arr.toString()).toEqual(enumerable.toString());
505: 	});
506: });
</file>

<file path="src/common/__tests__/event-emitter.test.ts">
  1: import type { Expect, TypesAreEqual } from "../../../tests/utils";
  2: import { type EventArgs, EventEmitter, type EventsOf } from "../event-emitter";
  3: describe("EventEmitter", () => {
  4: 	describe("adding listeners", () => {
  5: 		test("addListener", () => {
  6: 			const emitter = new EventEmitter<EventMap>();
  7: 			const listener = jest.fn();
  8: 			emitter.addListener("message", listener);
  9: 			emitter.emit("message", "First");
 10: 			emitter.emit("message", "Second");
 11: 			expect(listener).toHaveBeenCalledTimes(2);
 12: 			expect(listener).toHaveBeenNthCalledWith(1, "First");
 13: 			expect(listener).toHaveBeenNthCalledWith(2, "Second");
 14: 		});
 15: 		test("on", () => {
 16: 			const emitter = new EventEmitter<EventMap>();
 17: 			const listener = jest.fn();
 18: 			emitter.on("message", listener);
 19: 			emitter.emit("message", "First");
 20: 			emitter.emit("message", "Second");
 21: 			expect(listener).toHaveBeenCalledTimes(2);
 22: 			expect(listener).toHaveBeenNthCalledWith(1, "First");
 23: 			expect(listener).toHaveBeenNthCalledWith(2, "Second");
 24: 		});
 25: 		test("once", () => {
 26: 			const emitter = new EventEmitter<EventMap>();
 27: 			const listener = jest.fn();
 28: 			emitter.once("message", listener);
 29: 			emitter.emit("message", "First");
 30: 			emitter.emit("message", "Second");
 31: 			expect(listener).toHaveBeenCalledTimes(1);
 32: 			expect(listener).toHaveBeenCalledWith("First");
 33: 		});
 34: 	});
 35: 	describe("disposable listeners", () => {
 36: 		it("adds the listener", async () => {
 37: 			const emitter = new EventEmitter<EventMap>();
 38: 			const listener = jest.fn();
 39: 			emitter.disposableOn("message", listener);
 40: 			emitter.emit("message", "Hello world");
 41: 			expect(listener).toHaveBeenCalledTimes(1);
 42: 			expect(listener).toHaveBeenCalledWith("Hello world");
 43: 		});
 44: 		it("can remove after emitting", async () => {
 45: 			const emitter = new EventEmitter<EventMap>();
 46: 			const listener = jest.fn();
 47: 			{
 48: 				using handler = emitter.disposableOn("message", listener);
 49: 				emitter.emit("message", "One");
 50: 			}
 51: 			emitter.emit("message", "Two");
 52: 			expect(listener).toHaveBeenCalledTimes(1);
 53: 			expect(listener).toHaveBeenNthCalledWith(1, "One");
 54: 		});
 55: 		it("dispose", async () => {
 56: 			const emitter = new EventEmitter<EventMap>();
 57: 			const listener = jest.fn();
 58: 			const handler = emitter.disposableOn("message", listener);
 59: 			handler.dispose();
 60: 			emitter.emit("message", "Hello world");
 61: 			expect(listener).not.toHaveBeenCalled();
 62: 		});
 63: 		it("[Symbol.dispose]", async () => {
 64: 			const emitter = new EventEmitter<EventMap>();
 65: 			const listener = jest.fn();
 66: 			{
 67: 				using handler = emitter.disposableOn("message", listener);
 68: 			}
 69: 			emitter.emit("message", "Hello world");
 70: 			expect(listener).not.toHaveBeenCalled();
 71: 		});
 72: 	});
 73: 	it("emits to all listeners", () => {
 74: 		const emitter = new EventEmitter<EventMap>();
 75: 		const [listener, other] = [jest.fn(), jest.fn(), jest.fn(), jest.fn()];
 76: 		emitter.addListener("message", listener);
 77: 		emitter.addListener("message", listener);
 78: 		emitter.addListener("message", listener);
 79: 		emitter.addListener("other", other);
 80: 		emitter.emit("message", "Hello world");
 81: 		expect(listener).toHaveBeenCalledTimes(3);
 82: 		expect(listener).toHaveBeenCalledWith("Hello world");
 83: 		expect(other).toBeCalledTimes(0);
 84: 	});
 85: 	test("eventNames", () => {
 86: 		const emitter = new EventEmitter<EventMap>();
 87: 		const listener = jest.fn();
 88: 		expect(emitter.eventNames()).toStrictEqual([]);
 89: 		emitter.addListener("message", listener);
 90: 		expect(emitter.eventNames()).toStrictEqual(["message"]);
 91: 		emitter.addListener("other", listener);
 92: 		expect(emitter.eventNames()).toStrictEqual(["message", "other"]);
 93: 	});
 94: 	describe("listenerCount", () => {
 95: 		it("with listener", () => {
 96: 			const emitter = new EventEmitter<EventMap>();
 97: 			const listener = jest.fn();
 98: 			emitter.addListener("message", listener);
 99: 			emitter.addListener("message", listener);
100: 			emitter.addListener("message", jest.fn());
101: 			emitter.addListener("other", jest.fn());
102: 			expect(emitter.listenerCount("message", listener)).toBe(2);
103: 			expect(emitter.listenerCount("message", listener)).toBe(2);
104: 		});
105: 		it("without listener", () => {
106: 			const emitter = new EventEmitter<EventMap>();
107: 			emitter.addListener("message", jest.fn());
108: 			emitter.addListener("message", jest.fn());
109: 			emitter.addListener("message", jest.fn());
110: 			emitter.addListener("other", jest.fn());
111: 			expect(emitter.listenerCount("message")).toBe(3);
112: 			expect(emitter.listenerCount("other")).toBe(1);
113: 			expect(emitter.listenerCount("another")).toBe(0);
114: 		});
115: 	});
116: 	test("listeners", () => {
117: 		const emitter = new EventEmitter<EventMap>();
118: 		const [one, two] = [jest.fn(), jest.fn()];
119: 		emitter.addListener("message", one);
120: 		emitter.addListener("message", two);
121: 		emitter.addListener("message", two);
122: 		expect(emitter.listeners("message")).toStrictEqual([one, two, two]);
123: 		expect(emitter.listeners("other")).toStrictEqual([]);
124: 	});
125: 	describe("prepending listeners", () => {
126: 		test("prependListener", () => {
127: 			const emitter = new EventEmitter<EventMap>();
128: 			const [on, prepend] = [jest.fn(), jest.fn()];
129: 			const order: unknown[] = [];
130: 			on.mockImplementation(() => order.push(on));
131: 			prepend.mockImplementation(() => order.push(prepend));
132: 			emitter.on("message", on);
133: 			emitter.prependListener("message", prepend);
134: 			emitter.emit("message", "Hello world");
135: 			expect(on).toHaveBeenCalledTimes(1);
136: 			expect(on).toBeCalledWith("Hello world");
137: 			expect(prepend).toHaveBeenCalledTimes(1);
138: 			expect(prepend).toBeCalledWith("Hello world");
139: 			expect(order).toStrictEqual([prepend, on]);
140: 		});
141: 		test("prependOnceListener", () => {
142: 			const emitter = new EventEmitter<EventMap>();
143: 			const [on, prepend] = [jest.fn(), jest.fn()];
144: 			const order: unknown[] = [];
145: 			on.mockImplementation(() => {
146: 				order.push(on);
147: 			});
148: 			prepend.mockImplementation(() => order.push(prepend));
149: 			emitter.on("message", on);
150: 			emitter.prependOnceListener("message", prepend);
151: 			emitter.emit("message", "Hello world");
152: 			emitter.emit("message", "Hello world");
153: 			expect(on).toHaveBeenCalledTimes(2);
154: 			expect(on).toBeCalledWith("Hello world");
155: 			expect(prepend).toHaveBeenCalledTimes(1);
156: 			expect(prepend).toBeCalledWith("Hello world");
157: 			expect(order).toStrictEqual([prepend, on, on]);
158: 		});
159: 	});
160: 	describe("removing listeners", () => {
161: 		test("off", () => {
162: 			const emitter = new EventEmitter<EventMap>();
163: 			const [one, two] = [jest.fn(), jest.fn()];
164: 			emitter.off("message", one);
165: 			emitter.on("message", one);
166: 			emitter.on("message", two);
167: 			emitter.on("other", one);
168: 			emitter.on("other", two);
169: 			emitter.off("message", one);
170: 			emitter.emit("message", "Hello world");
171: 			expect(one).not.toHaveBeenCalled();
172: 			expect(two).toHaveBeenCalledTimes(1);
173: 			expect(two).toHaveBeenCalledWith("Hello world");
174: 		});
175: 		test("removeAllListeners", () => {
176: 			const emitter = new EventEmitter<EventMap>();
177: 			const [one, two] = [jest.fn(), jest.fn()];
178: 			emitter.on("message", one);
179: 			emitter.on("message", two);
180: 			emitter.on("other", one);
181: 			emitter.on("other", two);
182: 			emitter.removeAllListeners("message");
183: 			emitter.emit("message", "Hello world");
184: 			expect(one).not.toHaveBeenCalled();
185: 			expect(two).not.toHaveBeenCalled();
186: 		});
187: 		test("removeListener", () => {
188: 			const emitter = new EventEmitter<EventMap>();
189: 			const [one, two] = [jest.fn(), jest.fn()];
190: 			emitter.on("message", one);
191: 			emitter.on("message", two);
192: 			emitter.on("other", one);
193: 			emitter.on("other", two);
194: 			emitter.removeListener("message", one);
195: 			emitter.emit("message", "Hello world");
196: 			expect(one).not.toHaveBeenCalled();
197: 			expect(two).toHaveBeenCalledTimes(1);
198: 			expect(two).toHaveBeenCalledWith("Hello world");
199: 		});
200: 	});
201: 	describe("types", () => {
202: 		test("event map", () => {
203: 			const invalidArgs = new EventEmitter<{
204: 				invalid: string;
205: 				valid: [name: string];
206: 			}>();
207: 			const invalidEventName = new EventEmitter<{
208: 				[1]: [name: string];
209: 				valid: [name: string];
210: 			}>();
211: 		});
212: 		test("event name", () => {
213: 			type eventName = Expect<
214: 				TypesAreEqual<EventsOf<EventMap>, "another" | "array" | "empty" | "message" | "other" | (string & {})>
215: 			>;
216: 			type invalid = EventsOf<{
217: 				invalid: string;
218: 				valid: [name: string];
219: 			}>;
220: 		});
221: 		it("events args", () => {
222: 			type t = EventArgs<EventMap, "array">;
223: 			type empty = Expect<TypesAreEqual<EventArgs<EventMap, "empty">, []>>;
224: 			type single = Expect<TypesAreEqual<EventArgs<EventMap, "message">, [message: string]>>;
225: 			type multiple = Expect<TypesAreEqual<EventArgs<EventMap, "array">, [id: number, name: string]>>;
226: 			type invalid = EventArgs<
227: 				{ invalid: string },
228: 				"invalid"
229: 			>;
230: 		});
231: 	});
232: });
233: type EventMap = {
234: 	message: [message: string];
235: 	other: [id: number];
236: 	another: [id: number];
237: 	empty: [];
238: 	array: [id: number, name: string];
239: };
</file>

<file path="src/common/__tests__/i18n.test.ts">
 1: import type { Language } from "../../api";
 2: import { I18nProvider } from "../i18n";
 3: jest.mock("../logging");
 4: describe("I18nProvider", () => {
 5: 	it("lazily evaluates locales", () => {
 6: 		const localeProvider = jest.fn();
 7: 		new I18nProvider("en", localeProvider);
 8: 		expect(localeProvider).toHaveBeenCalledTimes(0);
 9: 	});
10: 	it("loads locales once", () => {
11: 		const localeProvider = jest.fn().mockReturnValue(null);
12: 		const i18n = new I18nProvider("en", localeProvider);
13: 		i18n.translate("Hello", "en");
14: 		i18n.translate("Hello", "en");
15: 		i18n.translate("Hello", "de");
16: 		expect(localeProvider).toHaveBeenCalledTimes(2);
17: 		expect(localeProvider).toHaveBeenNthCalledWith(1, "en");
18: 		expect(localeProvider).toHaveBeenNthCalledWith(2, "de");
19: 	});
20: 	it("does not load unsupported locales", () => {
21: 		const localeProvider = jest.fn().mockReturnValue(null);
22: 		const i18n = new I18nProvider("en", localeProvider);
23: 		i18n.translate("Hello", "__");
24: 		expect(localeProvider).toHaveBeenCalledTimes(1);
25: 		expect(localeProvider).toHaveBeenCalledWith("en");
26: 	});
27: 	it("t is alias of translate", () => {
28: 		const i18n = new I18nProvider("en", jest.fn());
29: 		const spyOnTranslate = jest.spyOn(i18n, "translate");
30: 		i18n.t("test");
31: 		i18n.t("test", "de");
32: 		expect(spyOnTranslate).toHaveBeenCalledTimes(2);
33: 		expect(spyOnTranslate).toHaveBeenNthCalledWith(1, "test", "en");
34: 		expect(spyOnTranslate).toHaveBeenNthCalledWith(2, "test", "de");
35: 	});
36: 	describe("translating", () => {
37: 		const localeProvider = jest.fn().mockImplementation((language: Language) => {
38: 			switch (language) {
39: 				case "de":
40: 					return { Hello: "Hello welt" };
41: 				case "en":
42: 					return { Hello: "Hello world", Company: { Name: "Elgato" } };
43: 				default:
44: 					return null;
45: 			}
46: 		});
47: 		it("find resources from the requested language", () => {
48: 			const i18n = new I18nProvider("en", localeProvider);
49: 			expect(i18n.translate("Hello", "de")).toBe("Hello welt");
50: 		});
51: 		it("finds resources from the default language", () => {
52: 			const i18n = new I18nProvider("en", localeProvider);
53: 			expect(i18n.translate("Hello", "es")).toBe("Hello world");
54: 		});
55: 		it("returns the key for unknown resources", () => {
56: 			const i18n = new I18nProvider("en", localeProvider);
57: 			expect(i18n.translate("Goodbye")).toBe("Goodbye");
58: 		});
59: 		it("translates nested properties", () => {
60: 			const i18n = new I18nProvider("en", localeProvider);
61: 			expect(i18n.translate("Company.Name")).toBe("Elgato");
62: 		});
63: 		it("can translate with t alias", () => {
64: 			const i18n = new I18nProvider("en", localeProvider);
65: 			expect(i18n.t("Company.Name")).toBe("Elgato");
66: 		});
67: 	});
68: });
</file>

<file path="src/common/__tests__/promises.test.ts">
 1: import { PromiseCompletionSource } from "../promises";
 2: describe("PromiseCompletionSource<T>", () => {
 3: 	it("Defaults to pending", () => {
 4: 		const pcs = new PromiseCompletionSource<string>();
 5: 		expect(getPromiseState(pcs.promise)).resolves.toBe("pending");
 6: 	});
 7: 	it("Resolves after setResult", () => {
 8: 		const pcs = new PromiseCompletionSource<string>();
 9: 		pcs.setResult("foo");
10: 		expect(getPromiseState(pcs.promise)).resolves.toBe("complete");
11: 	});
12: 	it("Resolves with result", async () => {
13: 		const pcs = new PromiseCompletionSource<string>();
14: 		pcs.setResult("foo");
15: 		expect(await pcs.promise).toBe("foo");
16: 	});
17: 	it("Reject after setException", () => {
18: 		const pcs = new PromiseCompletionSource<string>();
19: 		pcs.setException();
20: 		expect(getPromiseState(pcs.promise)).resolves.toBe("error");
21: 	});
22: 	it("Rejects with exception", () => {
23: 		const pcs = new PromiseCompletionSource<string>();
24: 		pcs.setException("Mock error");
25: 		expect(async () => await pcs.promise).rejects.toMatch("Mock error");
26: 	});
27: });
28: async function getPromiseState<T>(promise: Promise<T>): Promise<"complete" | "error" | "pending"> {
29: 	const other = {};
30: 	try {
31: 		const winner = await Promise.race([promise, other]);
32: 		return winner == other ? "pending" : "complete";
33: 	} catch {
34: 		return "error";
35: 	}
36: }
</file>

<file path="src/common/__tests__/utils.test.ts">
 1: import { freeze, get } from "../utils";
 2: describe("freeze", () => {
 3: 	it("top-level properties", () => {
 4: 		const obj = {
 5: 			name: "Elgato",
 6: 		};
 7: 		freeze(obj);
 8: 		expect(() => (obj.name = "Other")).toThrowError();
 9: 		expect(obj.name).toEqual("Elgato");
10: 	});
11: 	it("nested properties", () => {
12: 		const obj = {
13: 			company: {
14: 				name: "Elgato",
15: 			},
16: 		};
17: 		freeze(obj);
18: 		expect(() => (obj.company.name = "Other")).toThrowError();
19: 		expect(obj.company.name).toEqual("Elgato");
20: 	});
21: 	it("handles undefined", () => {
22: 		const value = undefined;
23: 		freeze(value);
24: 		expect(value).toBeUndefined();
25: 	});
26: 	it("handles null", () => {
27: 		const value = null;
28: 		freeze(value);
29: 		expect(value).toBeNull();
30: 	});
31: });
32: describe("get", () => {
33: 	it("gets the value for a top-level path", () => {
34: 		const obj = { foo: "bar" };
35: 		expect(get("foo", obj)).toBe("bar");
36: 	});
37: 	it("gets the value for a nested path", () => {
38: 		const obj = { nested: { number: 13 } };
39: 		expect(get("nested.number", obj)).toBe(13);
40: 	});
41: 	it("handles falsy values", () => {
42: 		const obj = { falsy: false };
43: 		expect(get("falsy", obj)).toBe(false);
44: 	});
45: 	it("defaults to undefined", () => {
46: 		const obj = {};
47: 		expect(get("__unknown.__prop", obj)).toBe(undefined);
48: 	});
49: });
</file>

<file path="src/common/events/action-event.ts">
 1: import type { ActionIdentifier, DeviceIdentifier, PluginEvent } from "../../api";
 2: import { Event } from "./event";
 3: export class ActionWithoutPayloadEvent<
 4: 	TSource extends Extract<PluginEvent, ActionIdentifier & DeviceIdentifier>,
 5: 	TAction,
 6: > extends Event<TSource> {
 7: 	constructor(
 8: 		public readonly action: TAction,
 9: 		source: TSource,
10: 	) {
11: 		super(source);
12: 	}
13: }
14: export class ActionEvent<
15: 	TSource extends Extract<PluginEvent, ActionIdentifier & DeviceIdentifier> & PayloadEvent<TSource>,
16: 	TAction,
17: > extends ActionWithoutPayloadEvent<TSource, TAction> {
18: 	public readonly payload: ExtractPayload<TSource>;
19: 	constructor(action: TAction, source: TSource) {
20: 		super(action, source);
21: 		this.payload = source.payload;
22: 	}
23: }
24: type ExtractPayload<T> = T extends {
25: 	payload: infer TPayload;
26: }
27: 	? TPayload extends object
28: 		? TPayload
29: 		: never
30: 	: never;
31: type PayloadEvent<T> = {
32: 	payload: ExtractPayload<T>;
33: };
</file>

<file path="src/common/events/event.ts">
1: import type { PluginEvent, UIEvent } from "../../api";
2: export class Event<T extends PluginEvent | UIEvent> {
3: 	public readonly type: T["event"];
4: 	constructor(source: T) {
5: 		this.type = source.event;
6: 	}
7: }
</file>

<file path="src/common/events/index.ts">
1: export { ActionEvent, ActionWithoutPayloadEvent } from "./action-event";
2: export { Event } from "./event";
3: export { DidReceiveGlobalSettingsEvent } from "./settings-event";
</file>

<file path="src/common/events/settings-event.ts">
 1: import type { DidReceiveGlobalSettings } from "../../api";
 2: import type { JsonObject } from "../json";
 3: import { Event } from "./event";
 4: export class DidReceiveGlobalSettingsEvent<T extends JsonObject> extends Event<DidReceiveGlobalSettings<T>> {
 5: 	public readonly settings: T;
 6: 	constructor(source: DidReceiveGlobalSettings<T>) {
 7: 		super(source);
 8: 		this.settings = source.payload.settings;
 9: 	}
10: }
</file>

<file path="src/common/logging/__tests__/console-target.test.ts">
 1: import { ConsoleTarget } from "../console-target";
 2: import { LogLevel } from "../level";
 3: describe("ConsoleTarget", () => {
 4: 	it("Error writes to error", () => {
 5: 		const target = new ConsoleTarget();
 6: 		const spyOnConsoleError = jest.spyOn(console, "error").mockImplementationOnce(() => jest.fn());
 7: 		target.write({
 8: 			data: ["Hello world"],
 9: 			level: LogLevel.ERROR,
10: 			scope: "Test",
11: 		});
12: 		expect(spyOnConsoleError).toHaveBeenCalledTimes(1);
13: 		expect(spyOnConsoleError).toHaveBeenCalledWith("Hello world");
14: 	});
15: 	it("Warn writes to warn", () => {
16: 		const target = new ConsoleTarget();
17: 		const spyOnConsoleWarn = jest.spyOn(console, "warn").mockImplementationOnce(() => jest.fn());
18: 		target.write({
19: 			data: ["Hello world"],
20: 			level: LogLevel.WARN,
21: 			scope: "Test",
22: 		});
23: 		expect(spyOnConsoleWarn).toHaveBeenCalledTimes(1);
24: 		expect(spyOnConsoleWarn).toHaveBeenCalledWith("Hello world");
25: 	});
26: 	it.each([
27: 		{ name: "Info", level: LogLevel.INFO },
28: 		{ name: "Debug", level: LogLevel.DEBUG },
29: 		{ name: "Trace", level: LogLevel.TRACE },
30: 	])("$name writes to log", ({ level }) => {
31: 		const target = new ConsoleTarget();
32: 		const spyOnConsoleLog = jest.spyOn(console, "log").mockImplementationOnce(() => jest.fn());
33: 		target.write({
34: 			data: ["Hello world"],
35: 			level,
36: 			scope: "Test",
37: 		});
38: 		expect(spyOnConsoleLog).toHaveBeenCalledTimes(1);
39: 		expect(spyOnConsoleLog).toHaveBeenCalledWith("Hello world");
40: 	});
41: });
</file>

<file path="src/common/logging/__tests__/format.test.ts">
  1: import { LogLevel } from "../../../common/logging";
  2: import { stringFormatter } from "../format";
  3: describe("stringFormatter", () => {
  4: 	describe("data only", () => {
  5: 		test("without error", () => {
  6: 			const format = stringFormatter({ dataOnly: true });
  7: 			const actual = format({
  8: 				data: ["Hello", "World", { foo: "bar" }, true],
  9: 				level: LogLevel.INFO,
 10: 				scope: "Test",
 11: 			});
 12: 			expect(actual).toEqual(`Hello World {"foo":"bar"} true`);
 13: 		});
 14: 		test("with error", () => {
 15: 			const err = new Error("I am the error");
 16: 			const format = stringFormatter({ dataOnly: true });
 17: 			const actual = format({
 18: 				data: ["Encountered an error", err, true],
 19: 				level: LogLevel.INFO,
 20: 				scope: "",
 21: 			});
 22: 			expect(actual).toEqual(`Encountered an error \n${err.stack}\ntrue`);
 23: 		});
 24: 	});
 25: 	describe("full", () => {
 26: 		const mockedDate = new Date(2000, 11, 25, 10, 30, 0, 123);
 27: 		const mockedDateString = "2000-12-25T10:30:00.123Z";
 28: 		beforeEach(() => jest.useFakeTimers().setSystemTime(mockedDate));
 29: 		describe("aggregating data", () => {
 30: 			it("without error", () => {
 31: 				const format = stringFormatter();
 32: 				const actual = format({
 33: 					data: ["Hello", "World", { foo: "bar" }, true],
 34: 					level: LogLevel.INFO,
 35: 					scope: "Test",
 36: 				});
 37: 				expect(actual).toEqual(`${mockedDateString} INFO  Test: Hello World {"foo":"bar"} true`);
 38: 			});
 39: 			it("with error", () => {
 40: 				const err = new Error("I am the error");
 41: 				const format = stringFormatter();
 42: 				const actual = format({
 43: 					data: ["Encountered an error", err, true],
 44: 					level: LogLevel.INFO,
 45: 					scope: "",
 46: 				});
 47: 				expect(actual).toEqual(`${mockedDateString} INFO  Encountered an error \n${err.stack}\ntrue`);
 48: 			});
 49: 		});
 50: 		describe("log each level", () => {
 51: 			describe("without scope", () => {
 52: 				const testCases = [
 53: 					{
 54: 						name: "ERROR",
 55: 						level: LogLevel.ERROR,
 56: 						expected: `${mockedDateString} ERROR Hello world`,
 57: 					},
 58: 					{
 59: 						name: "WARN",
 60: 						level: LogLevel.WARN,
 61: 						expected: `${mockedDateString} WARN  Hello world`,
 62: 					},
 63: 					{
 64: 						name: "INFO",
 65: 						level: LogLevel.INFO,
 66: 						expected: `${mockedDateString} INFO  Hello world`,
 67: 					},
 68: 					{
 69: 						name: "DEBUG",
 70: 						level: LogLevel.DEBUG,
 71: 						expected: `${mockedDateString} DEBUG Hello world`,
 72: 					},
 73: 					{
 74: 						name: "TRACE",
 75: 						level: LogLevel.TRACE,
 76: 						expected: `${mockedDateString} TRACE Hello world`,
 77: 					},
 78: 				];
 79: 				it.each(testCases)("$name message", ({ level, expected }) => {
 80: 					const format = stringFormatter();
 81: 					const actual = format({
 82: 						data: ["Hello world"],
 83: 						level,
 84: 						scope: "",
 85: 					});
 86: 					// Assert.
 87: 					expect(actual).toEqual(expected);
 88: 				});
 89: 			});
 90: 			/**
 91: 			 * Asserts {@link stringFormatter} for each log-level, with a scope.
 92: 			 */
 93: 			describe("with scope", () => {
 94: 				const scope = "Test->Logger";
 95: 				const testCases = [
 96: 					{
 97: 						name: "ERROR",
 98: 						level: LogLevel.ERROR,
 99: 						expected: `${mockedDateString} ERROR ${scope}: Hello world`,
100: 					},
101: 					{
102: 						name: "WARN",
103: 						level: LogLevel.WARN,
104: 						expected: `${mockedDateString} WARN  ${scope}: Hello world`,
105: 					},
106: 					{
107: 						name: "INFO",
108: 						level: LogLevel.INFO,
109: 						expected: `${mockedDateString} INFO  ${scope}: Hello world`,
110: 					},
111: 					{
112: 						name: "DEBUG",
113: 						level: LogLevel.DEBUG,
114: 						expected: `${mockedDateString} DEBUG ${scope}: Hello world`,
115: 					},
116: 					{
117: 						name: "TRACE",
118: 						level: LogLevel.TRACE,
119: 						expected: `${mockedDateString} TRACE ${scope}: Hello world`,
120: 					},
121: 				];
122: 				it.each(testCases)("$name message", ({ level, expected }) => {
123: 					const format = stringFormatter();
124: 					const actual = format({
125: 						data: ["Hello world"],
126: 						level,
127: 						scope,
128: 					});
129: 					expect(actual).toEqual(expected);
130: 				});
131: 			});
132: 		});
133: 	});
134: });
</file>

<file path="src/common/logging/__tests__/logger.test.ts">
  1: import { LogLevel } from "../level";
  2: import { Logger, LoggerOptions } from "../logger";
  3: import { LogEntry, LogTarget } from "../target";
  4: describe("Logger", () => {
  5: 	it("clones options on construction", () => {
  6: 		const options: LoggerOptions = {
  7: 			level: LogLevel.ERROR,
  8: 			targets: [{ write: jest.fn() }],
  9: 		};
 10: 		const logger = new Logger(options);
 11: 		logger.setLevel(LogLevel.INFO);
 12: 		logger.info("Hello world");
 13: 		expect(logger.level).toBe(LogLevel.INFO);
 14: 		expect(options.level).toBe(LogLevel.ERROR);
 15: 		expect(options.targets[0].write).toHaveBeenCalledTimes(1);
 16: 		expect(options.targets[0].write).toHaveBeenCalledWith<[LogEntry]>({
 17: 			data: ["Hello world"],
 18: 			level: LogLevel.INFO,
 19: 			scope: "",
 20: 		});
 21: 	});
 22: 	/**
 23: 	 * Asserts {@link Logger.write} logs to all targets
 24: 	 */
 25: 	it("writes to all targets", () => {
 26: 		const options: LoggerOptions = {
 27: 			level: LogLevel.INFO,
 28: 			targets: [{ write: jest.fn() }, { write: jest.fn() }, { write: jest.fn() }],
 29: 		};
 30: 		const logger = new Logger(options);
 31: 		logger.info("Hello world");
 32: 		const entry: LogEntry = {
 33: 			data: ["Hello world"],
 34: 			level: LogLevel.INFO,
 35: 			scope: "",
 36: 		};
 37: 		expect(options.targets[0].write).toBeCalledTimes(1);
 38: 		expect(options.targets[0].write).toHaveBeenCalledWith(entry);
 39: 		expect(options.targets[1].write).toBeCalledTimes(1);
 40: 		expect(options.targets[1].write).toHaveBeenCalledWith(entry);
 41: 		expect(options.targets[2].write).toBeCalledTimes(1);
 42: 		expect(options.targets[2].write).toHaveBeenCalledWith(entry);
 43: 	});
 44: 	/**
 45: 	 * Asserts {@link Logger} correctly supplies all log entry data.
 46: 	 */
 47: 	describe("supplies all log entry data", () => {
 48: 		it.each([
 49: 			{
 50: 				scopes: [],
 51: 				scope: "",
 52: 			},
 53: 			{
 54: 				scopes: ["Foo "],
 55: 				scope: "Foo",
 56: 			},
 57: 			{
 58: 				scopes: ["Foo", "  "],
 59: 				scope: "Foo",
 60: 			},
 61: 			{
 62: 				scopes: [" Hello", "World"],
 63: 				scope: "Hello->World",
 64: 			},
 65: 			{
 66: 				scopes: ["One", " Two ", "Three"],
 67: 				scope: "One->Two->Three",
 68: 			},
 69: 		])("When scopes are $scopes", ({ scopes, scope }) => {
 70: 			const target = { write: jest.fn() };
 71: 			const parent = new Logger({
 72: 				level: LogLevel.TRACE,
 73: 				minimumLevel: LogLevel.TRACE,
 74: 				targets: [target],
 75: 			});
 76: 			const logger = scopes.reduce((prev, current) => prev.createScope(current), parent);
 77: 			logger.error("Log error", new Error("error"));
 78: 			logger.warn("Log warn", new Error("warn"));
 79: 			logger.info("Log info", new Error("info"));
 80: 			logger.debug("Log debug", new Error("debug"));
 81: 			logger.trace("Log trace", new Error("trace"));
 82: 			expect(target.write).toHaveBeenCalledTimes(5);
 83: 			expect(target.write).toHaveBeenNthCalledWith<[LogEntry]>(1, {
 84: 				level: LogLevel.ERROR,
 85: 				data: [
 86: 					"Log error",
 87: 					expect.objectContaining({
 88: 						message: "error",
 89: 					}),
 90: 				],
 91: 				scope,
 92: 			});
 93: 			expect(target.write).toHaveBeenNthCalledWith<[LogEntry]>(2, {
 94: 				level: LogLevel.WARN,
 95: 				data: [
 96: 					"Log warn",
 97: 					expect.objectContaining({
 98: 						message: "warn",
 99: 					}),
100: 				],
101: 				scope,
102: 			});
103: 			expect(target.write).toHaveBeenNthCalledWith<[LogEntry]>(3, {
104: 				level: LogLevel.INFO,
105: 				data: [
106: 					"Log info",
107: 					expect.objectContaining({
108: 						message: "info",
109: 					}),
110: 				],
111: 				scope,
112: 			});
113: 			expect(target.write).toHaveBeenNthCalledWith<[LogEntry]>(4, {
114: 				level: LogLevel.DEBUG,
115: 				data: [
116: 					"Log debug",
117: 					expect.objectContaining({
118: 						message: "debug",
119: 					}),
120: 				],
121: 				scope,
122: 			});
123: 			expect(target.write).toHaveBeenNthCalledWith<[LogEntry]>(5, {
124: 				level: LogLevel.TRACE,
125: 				data: [
126: 					"Log trace",
127: 					expect.objectContaining({
128: 						message: "trace",
129: 					}),
130: 				],
131: 				scope,
132: 			});
133: 		});
134: 	});
135: 	describe("checks the log level before forwarding to target", () => {
136: 		let level: LogLevel;
137: 		describe("ERROR", () => {
138: 			beforeAll(() => (level = LogLevel.ERROR));
139: 			it("does log ERROR", () => verify((logger) => logger.error("error"), true));
140: 			it("does not log WARN", () => verify((logger) => logger.warn("warn"), false));
141: 			it("does not log INFO", () => verify((logger) => logger.info("info"), false));
142: 			it("does not log DEBUG", () => verify((logger) => logger.debug("debug"), false));
143: 			it("does not log TRACE", () => verify((logger) => logger.trace("trace"), false));
144: 		});
145: 		describe("WARN", () => {
146: 			beforeAll(() => (level = LogLevel.WARN));
147: 			it("does log ERROR", () => verify((logger) => logger.error("error"), true));
148: 			it("does log WARN", () => verify((logger) => logger.warn("warn"), true));
149: 			it("does not log INFO", () => verify((logger) => logger.info("info"), false));
150: 			it("does not log DEBUG", () => verify((logger) => logger.debug("debug"), false));
151: 			it("does not log TRACE", () => verify((logger) => logger.trace("trace"), false));
152: 		});
153: 		describe("INFO", () => {
154: 			beforeAll(() => (level = LogLevel.INFO));
155: 			it("does log ERROR", () => verify((logger) => logger.error("error"), true));
156: 			it("does log WARN", () => verify((logger) => logger.warn("warn"), true));
157: 			it("does log INFO", () => verify((logger) => logger.info("info"), true));
158: 			it("does not log DEBUG", () => verify((logger) => logger.debug("debug"), false));
159: 			it("does not log TRACE", () => verify((logger) => logger.trace("trace"), false));
160: 		});
161: 		describe("DEBUG", () => {
162: 			beforeAll(() => (level = LogLevel.DEBUG));
163: 			it("does log ERROR", () => verify((logger) => logger.error("error"), true));
164: 			it("does log WARN", () => verify((logger) => logger.warn("warn"), true));
165: 			it("does log INFO", () => verify((logger) => logger.info("info"), true));
166: 			it("does log DEBUG", () => verify((logger) => logger.debug("debug"), true));
167: 			it("does not log TRACE", () => verify((logger) => logger.trace("trace"), false));
168: 		});
169: 		describe("TRACE", () => {
170: 			beforeAll(() => (level = LogLevel.TRACE));
171: 			it("does log ERROR", () => verify((logger) => logger.error("error"), true));
172: 			it("does log WARN", () => verify((logger) => logger.warn("warn"), true));
173: 			it("does log INFO", () => verify((logger) => logger.info("info"), true));
174: 			it("does log DEBUG", () => verify((logger) => logger.debug("debug"), true));
175: 			it("does log TRACE", () => verify((logger) => logger.trace("trace"), true));
176: 		});
177: 		function verify(act: (logger: Logger) => void, expectLog: boolean) {
178: 			const target = { write: jest.fn() };
179: 			const logger = new Logger({
180: 				level,
181: 				minimumLevel: LogLevel.TRACE,
182: 				targets: [target],
183: 			});
184: 			act(logger);
185: 			expect(target.write).toHaveBeenCalledTimes(expectLog ? 1 : 0);
186: 		}
187: 	});
188: 	describe("setLogLevel", () => {
189: 		it("inherited by scoped loggers", () => {
190: 			const parent = new Logger({
191: 				level: LogLevel.ERROR,
192: 				targets: [{ write: jest.fn() }],
193: 			});
194: 			const childBefore = parent.createScope("Child (Before)");
195: 			const grandchildBefore = childBefore.createScope("Grandchild (Before)");
196: 			parent.setLevel(LogLevel.INFO);
197: 			const childAfter = parent.createScope("Child (After)");
198: 			expect(parent.level).toBe(LogLevel.INFO);
199: 			expect(childBefore.level).toBe(LogLevel.INFO);
200: 			expect(grandchildBefore.level).toBe(LogLevel.INFO);
201: 			expect(childAfter.level).toBe(LogLevel.INFO);
202: 		});
203: 		it("inherited from parents with defined log-level", () => {
204: 			const parent = new Logger({
205: 				level: LogLevel.ERROR,
206: 				targets: [{ write: jest.fn() }],
207: 			});
208: 			const child = parent.createScope("Child");
209: 			const grandchild = child.createScope("Grandchild");
210: 			child.setLevel(LogLevel.WARN);
211: 			parent.setLevel(LogLevel.INFO);
212: 			expect(parent.level).toBe(LogLevel.INFO);
213: 			expect(child.level).toBe(LogLevel.WARN);
214: 			expect(grandchild.level).toBe(LogLevel.WARN);
215: 		});
216: 		it("defaults when set to undefined", () => {
217: 			const parent = new Logger({
218: 				level: LogLevel.ERROR,
219: 				targets: [{ write: jest.fn() }],
220: 			});
221: 			const child = parent.createScope("Child");
222: 			const grandchild = child.createScope("Grandchild");
223: 			child.setLevel(LogLevel.WARN);
224: 			parent.setLevel(LogLevel.INFO);
225: 			child.setLevel();
226: 			expect(parent.level).toBe(LogLevel.INFO);
227: 			expect(child.level).toBe(LogLevel.INFO);
228: 			expect(grandchild.level).toBe(LogLevel.INFO);
229: 		});
230: 	});
231: 	describe("log-level validation", () => {
232: 		const testCases = [
233: 			{
234: 				minimumLevel: LogLevel.INFO,
235: 				name: "Can be ERROR",
236: 				level: LogLevel.ERROR,
237: 				expected: LogLevel.ERROR,
238: 			},
239: 			{
240: 				minimumLevel: LogLevel.TRACE,
241: 				name: "Can be ERROR",
242: 				level: LogLevel.ERROR,
243: 				expected: LogLevel.ERROR,
244: 			},
245: 			{
246: 				minimumLevel: LogLevel.INFO,
247: 				name: "Can be WARN",
248: 				level: LogLevel.WARN,
249: 				expected: LogLevel.WARN,
250: 			},
251: 			{
252: 				minimumLevel: LogLevel.TRACE,
253: 				name: "Can be WARN",
254: 				level: LogLevel.WARN,
255: 				expected: LogLevel.WARN,
256: 			},
257: 			{
258: 				minimumLevel: LogLevel.INFO,
259: 				name: "Can be INFO",
260: 				level: LogLevel.INFO,
261: 				expected: LogLevel.INFO,
262: 			},
263: 			{
264: 				minimumLevel: LogLevel.TRACE,
265: 				name: "Can be INFO",
266: 				level: LogLevel.INFO,
267: 				expected: LogLevel.INFO,
268: 			},
269: 			{
270: 				minimumLevel: LogLevel.INFO,
271: 				name: "Cannot be DEBUG",
272: 				level: LogLevel.DEBUG,
273: 				expected: LogLevel.INFO,
274: 			},
275: 			{
276: 				minimumLevel: LogLevel.TRACE,
277: 				name: "Can be DEBUG",
278: 				level: LogLevel.DEBUG,
279: 				expected: LogLevel.DEBUG,
280: 			},
281: 			{
282: 				minimumLevel: LogLevel.INFO,
283: 				name: "Cannot be TRACE",
284: 				level: LogLevel.TRACE,
285: 				expected: LogLevel.INFO,
286: 			},
287: 			{
288: 				minimumLevel: LogLevel.TRACE,
289: 				name: "Can be TRACE",
290: 				level: LogLevel.TRACE,
291: 				expected: LogLevel.TRACE,
292: 			},
293: 		];
294: 		describe("construction", () => {
295: 			it.each(testCases)("$name when minimumLevel is $minimumLevel", ({ level, expected, minimumLevel }) => {
296: 				const options: LoggerOptions = {
297: 					level,
298: 					minimumLevel: minimumLevel as LogLevel.INFO | LogLevel.TRACE,
299: 					targets: [{ write: jest.fn() }],
300: 				};
301: 				const logger = new Logger(options);
302: 				expect(logger.level).toBe(expected);
303: 				if (level === expected) {
304: 					expect(options.targets[0].write).toHaveBeenCalledTimes(0);
305: 				} else {
306: 					expect(options.targets[0].write).toHaveBeenCalledTimes(1);
307: 					expect(options.targets[0].write).toHaveBeenCalledWith<[LogEntry]>({
308: 						level: LogLevel.WARN,
309: 						data: [`Log level cannot be set to ${LogLevel[level]} whilst not in debug mode.`],
310: 						scope: "",
311: 					});
312: 				}
313: 			});
314: 		});
315: 		/**
316: 		 * Asserts {@link Logger.setLogLevel} validates teh {@link LogLevel}.
317: 		 */
318: 		describe("setLevel", () => {
319: 			it.each(testCases)("$name when minimumLevel is $minimumLevel", ({ level, expected, minimumLevel }) => {
320: 				const options: LoggerOptions = {
321: 					level: LogLevel.ERROR,
322: 					minimumLevel: minimumLevel as LogLevel.INFO | LogLevel.TRACE,
323: 					targets: [{ write: jest.fn() }],
324: 				};
325: 				const logger = new Logger(options);
326: 				logger.setLevel(level);
327: 				expect(logger.level).toBe(expected);
328: 				if (level === expected) {
329: 					expect(options.targets[0].write).toHaveBeenCalledTimes(0);
330: 				} else {
331: 					expect(options.targets[0].write).toHaveBeenCalledTimes(1);
332: 					expect(options.targets[0].write).toHaveBeenCalledWith<[LogEntry]>({
333: 						level: LogLevel.WARN,
334: 						data: [`Log level cannot be set to ${LogLevel[level]} whilst not in debug mode.`],
335: 						scope: "",
336: 					});
337: 				}
338: 			});
339: 		});
340: 	});
341: });
</file>

<file path="src/common/logging/__tests__/routing.test.ts">
  1: import type { LogEntry } from "..";
  2: import { MessageGateway, type MessageRequestOptions, MessageResponder } from "../../messaging";
  3: import { LogLevel } from "../level";
  4: import { Logger } from "../logger";
  5: import { createRoutedLogTarget, type JsonSafeLogEntry, registerCreateLogEntryRoute } from "../routing";
  6: jest.mock("../../messaging");
  7: const expectedLoggerWritePath = "internal:logger.write";
  8: describe("createRoutedLogTarget", () => {
  9: 	it("sends log entry to router", () => {
 10: 		const router = new MessageGateway<unknown>(jest.fn(), jest.fn());
 11: 		const target = createRoutedLogTarget(router);
 12: 		target.write({
 13: 			data: ["Hello", "world"],
 14: 			level: LogLevel.INFO,
 15: 			scope: "Test",
 16: 		});
 17: 		expect(router.fetch).toHaveBeenCalledTimes(1);
 18: 		expect(router.fetch).toHaveBeenCalledWith<[MessageRequestOptions]>({
 19: 			body: {
 20: 				level: LogLevel.INFO,
 21: 				message: "Hello world",
 22: 				scope: "Test",
 23: 			} satisfies JsonSafeLogEntry,
 24: 			path: expectedLoggerWritePath,
 25: 			unidirectional: true,
 26: 		});
 27: 	});
 28: });
 29: describe("registerCreateLogEntryRoute", () => {
 30: 	describe("incomplete request", () => {
 31: 		test("body is undefined", () => {
 32: 			const router = new MessageGateway<unknown>(jest.fn(), jest.fn());
 33: 			const spyOnRoute = jest.spyOn(router, "route");
 34: 			const responder = new MessageResponder(null!, jest.fn());
 35: 			registerCreateLogEntryRoute(router, null!);
 36: 			spyOnRoute.mock.calls[0][1](
 37: 				{
 38: 					action: jest.fn(),
 39: 					path: expectedLoggerWritePath,
 40: 					unidirectional: true,
 41: 					body: undefined,
 42: 				},
 43: 				responder,
 44: 			);
 45: 			expect(spyOnRoute).toHaveBeenCalledTimes(1);
 46: 			expect(spyOnRoute).toHaveBeenCalledWith(expectedLoggerWritePath, expect.any(Function));
 47: 			expect(responder.fail).toHaveBeenCalledTimes(1);
 48: 		});
 49: 		test("level is undefined", () => {
 50: 			const router = new MessageGateway<unknown>(jest.fn(), jest.fn());
 51: 			const spyOnRoute = jest.spyOn(router, "route");
 52: 			const responder = new MessageResponder(null!, jest.fn());
 53: 			registerCreateLogEntryRoute(router, null!);
 54: 			spyOnRoute.mock.calls[0][1](
 55: 				{
 56: 					action: jest.fn(),
 57: 					path: expectedLoggerWritePath,
 58: 					unidirectional: true,
 59: 					body: {
 60: 						level: undefined,
 61: 					},
 62: 				},
 63: 				responder,
 64: 			);
 65: 			expect(spyOnRoute).toHaveBeenCalledTimes(1);
 66: 			expect(spyOnRoute).toHaveBeenCalledWith(expectedLoggerWritePath, expect.any(Function));
 67: 			expect(responder.fail).toHaveBeenCalledTimes(1);
 68: 		});
 69: 	});
 70: 	it("should write to logger", () => {
 71: 		const router = new MessageGateway<unknown>(jest.fn(), jest.fn());
 72: 		const spyOnRoute = jest.spyOn(router, "route");
 73: 		const responder = new MessageResponder(null!, jest.fn());
 74: 		const logger = new Logger({
 75: 			level: LogLevel.INFO,
 76: 			targets: [{ write: jest.fn() }],
 77: 		});
 78: 		const spyOnWrite = jest.spyOn(logger, "write");
 79: 		registerCreateLogEntryRoute(router, logger);
 80: 		spyOnRoute.mock.calls[0][1](
 81: 			{
 82: 				action: jest.fn(),
 83: 				path: expectedLoggerWritePath,
 84: 				unidirectional: true,
 85: 				body: {
 86: 					level: LogLevel.WARN,
 87: 					message: "Hello world",
 88: 					scope: "Test",
 89: 				} satisfies JsonSafeLogEntry,
 90: 			},
 91: 			responder,
 92: 		);
 93: 		expect(spyOnRoute).toHaveBeenCalledTimes(1);
 94: 		expect(spyOnRoute).toHaveBeenCalledWith(expectedLoggerWritePath, expect.any(Function));
 95: 		expect(spyOnWrite).toHaveBeenCalledTimes(1);
 96: 		expect(spyOnWrite).toHaveBeenCalledWith<[LogEntry]>({
 97: 			data: ["Hello world"],
 98: 			level: LogLevel.WARN,
 99: 			scope: "Test",
100: 		});
101: 		expect(responder.success).toHaveBeenCalledTimes(1);
102: 	});
103: });
</file>

<file path="src/common/logging/console-target.ts">
 1: import { LogLevel } from "./level";
 2: import type { LogEntry, LogTarget } from "./target";
 3: export class ConsoleTarget implements LogTarget {
 4: 	public write(entry: LogEntry): void {
 5: 		switch (entry.level) {
 6: 			case LogLevel.ERROR:
 7: 				console.error(...entry.data);
 8: 				break;
 9: 			case LogLevel.WARN:
10: 				console.warn(...entry.data);
11: 				break;
12: 			default:
13: 				console.log(...entry.data);
14: 		}
15: 	}
16: }
</file>

<file path="src/common/logging/format.ts">
 1: import { LogLevel } from "./level";
 2: import { type LogEntry } from "./target";
 3: const EOL = "\n";
 4: export type LogEntryFormatter = (entry: LogEntry) => string;
 5: export function stringFormatter(opts?: StringFormatOptions): LogEntryFormatter {
 6: 	if (opts?.dataOnly) {
 7: 		return ({ data }) => `${reduce(data)}`;
 8: 	} else {
 9: 		return (entry: LogEntry) => {
10: 			const { data, level, scope } = entry;
11: 			let prefix = `${new Date().toISOString()} ${LogLevel[level].padEnd(5)} `;
12: 			if (scope) {
13: 				prefix += `${scope}: `;
14: 			}
15: 			return `${prefix}${reduce(data)}`;
16: 		};
17: 	}
18: }
19: type StringFormatOptions = {
20: 	dataOnly?: boolean;
21: };
22: function reduce(data: unknown[]): string {
23: 	let result = "";
24: 	let previousWasError = false;
25: 	for (const value of data) {
26: 		// When the value is an error, write the stack.
27: 		if (typeof value === "object" && value instanceof Error) {
28: 			result += `${EOL}${value.stack}`;
29: 			previousWasError = true;
30: 			continue;
31: 		}
32: 		if (previousWasError) {
33: 			result += EOL;
34: 			previousWasError = false;
35: 		}
36: 		result += typeof value === "object" ? JSON.stringify(value) : value;
37: 		result += " ";
38: 	}
39: 	return result.trimEnd();
40: }
</file>

<file path="src/common/logging/index.ts">
1: export * from "./console-target";
2: export * from "./format";
3: export * from "./level";
4: export * from "./logger";
5: export * from "./routing";
6: export * from "./target";
</file>

<file path="src/common/logging/level.ts">
1: export enum LogLevel {
2: 	ERROR = 0,
3: 	WARN = 1,
4: 	INFO = 2,
5: 	DEBUG = 3,
6: 	TRACE = 4,
7: }
</file>

<file path="src/common/logging/logger.ts">
 1: import { LogLevel } from "./level";
 2: import type { LogEntry, LogEntryData, LogTarget } from "./target";
 3: export class Logger {
 4: 	private _level?: LogLevel;
 5: 	private readonly options: LoggerOptions & Required<Pick<LoggerOptions, "minimumLevel">>;
 6: 	private readonly scope: string;
 7: 	constructor(opts: LoggerOptions) {
 8: 		this.options = { minimumLevel: LogLevel.TRACE, ...opts };
 9: 		this.scope = this.options.scope === undefined || this.options.scope.trim() === "" ? "" : this.options.scope;
10: 		if (typeof this.options.level !== "function") {
11: 			this.setLevel(this.options.level);
12: 		}
13: 	}
14: 	public get level(): LogLevel {
15: 		if (this._level !== undefined) {
16: 			return this._level;
17: 		}
18: 		return typeof this.options.level === "function" ? this.options.level() : this.options.level;
19: 	}
20: 	public createScope(scope: string): Logger | this {
21: 		scope = scope.trim();
22: 		if (scope === "") {
23: 			return this;
24: 		}
25: 		return new Logger({
26: 			...this.options,
27: 			level: () => this.level,
28: 			scope: this.options.scope ? `${this.options.scope}->${scope}` : scope,
29: 		});
30: 	}
31: 	public debug(...data: LogEntryData): this {
32: 		return this.write({ level: LogLevel.DEBUG, data, scope: this.scope });
33: 	}
34: 	public error(...data: LogEntryData): this {
35: 		return this.write({ level: LogLevel.ERROR, data, scope: this.scope });
36: 	}
37: 	public info(...data: LogEntryData): this {
38: 		return this.write({ level: LogLevel.INFO, data, scope: this.scope });
39: 	}
40: 	public setLevel(level?: LogLevel): this {
41: 		if (level !== undefined && level > this.options.minimumLevel) {
42: 			this._level = LogLevel.INFO;
43: 			this.warn(`Log level cannot be set to ${LogLevel[level]} whilst not in debug mode.`);
44: 		} else {
45: 			this._level = level;
46: 		}
47: 		return this;
48: 	}
49: 	public trace(...data: LogEntryData): this {
50: 		return this.write({ level: LogLevel.TRACE, data, scope: this.scope });
51: 	}
52: 	public warn(...data: LogEntryData): this {
53: 		return this.write({ level: LogLevel.WARN, data, scope: this.scope });
54: 	}
55: 	public write(entry: LogEntry): this {
56: 		if (entry.level <= this.level) {
57: 			this.options.targets.forEach((t) => t.write(entry));
58: 		}
59: 		return this;
60: 	}
61: }
62: export type LoggerOptions = {
63: 	level: LogLevel | (() => LogLevel);
64: 	minimumLevel?: LogLevel;
65: 	scope?: string;
66: 	targets: LogTarget[];
67: };
</file>

<file path="src/common/logging/routing.ts">
 1: import { INTERNAL_PATH_PREFIX, type MessageGateway } from "../messaging";
 2: import { stringFormatter } from "./format";
 3: import type { Logger } from "./logger";
 4: import type { LogEntry, LogTarget } from "./target";
 5: const LOGGER_WRITE_PATH = `${INTERNAL_PATH_PREFIX}logger.write`;
 6: export function createRoutedLogTarget(router: MessageGateway<unknown>): LogTarget {
 7: 	const format = stringFormatter({ dataOnly: true });
 8: 	return {
 9: 		write: (entry: LogEntry): void => {
10: 			router.fetch({
11: 				body: {
12: 					level: entry.level,
13: 					message: format(entry),
14: 					scope: entry.scope,
15: 				} satisfies JsonSafeLogEntry,
16: 				path: LOGGER_WRITE_PATH,
17: 				unidirectional: true,
18: 			});
19: 		},
20: 	};
21: }
22: export function registerCreateLogEntryRoute(router: MessageGateway<unknown>, logger: Logger): void {
23: 	router.route<JsonSafeLogEntry>(LOGGER_WRITE_PATH, (req, res) => {
24: 		if (req.body === undefined) {
25: 			return res.fail();
26: 		}
27: 		const { level, message, scope } = req.body;
28: 		if (level === undefined) {
29: 			return res.fail();
30: 		}
31: 		logger.write({ level, data: [message], scope });
32: 		return res.success();
33: 	});
34: }
35: export type JsonSafeLogEntry = Omit<LogEntry, "data"> & {
36: 	message: string;
37: };
</file>

<file path="src/common/logging/target.ts">
 1: import { LogLevel } from "./level";
 2: export type LogTarget = {
 3: 	write(entry: LogEntry): void;
 4: };
 5: export type LogEntry = {
 6: 	data: unknown[] | [string, ...unknown[]];
 7: 	level: LogLevel;
 8: 	scope: string;
 9: };
10: export type LogEntryData = unknown[] | [string, ...unknown[]];
</file>

<file path="src/common/messaging/__tests__/gateway.test.ts">
  1: import type { DidReceivePropertyInspectorMessage } from "../../../api";
  2: import { type Action } from "../../../plugin/actions/action";
  3: import type { JsonValue } from "../../json";
  4: import { MessageGateway, type UnscopedMessageRequest } from "../gateway";
  5: import type { RawMessageRequest } from "../message";
  6: import { MessageResponder } from "../responder";
  7: describe("MessageGateway", () => {
  8: 	it("must provide sender action", async () => {
  9: 		type MockAction = Pick<Action, "id" | "manifestId">;
 10: 		const proxy = jest.fn();
 11: 		const provider = jest.fn().mockReturnValue({
 12: 			id: "abc123",
 13: 			manifestId: "com.elgato.test.one",
 14: 		});
 15: 		const handler = jest.fn();
 16: 		const gateway = new MessageGateway<MockAction>(proxy, provider);
 17: 		gateway.route("/test", handler);
 18: 		await gateway.process({
 19: 			action: "com.elgato.test.one",
 20: 			context: "abc123",
 21: 			event: "sendToPlugin",
 22: 			payload: {
 23: 				__type: "request",
 24: 				id: "req1",
 25: 				path: "/test",
 26: 				unidirectional: false,
 27: 				body: {
 28: 					name: "Elgato",
 29: 				},
 30: 			},
 31: 		} satisfies DidReceivePropertyInspectorMessage<RawMessageRequest>);
 32: 		expect(handler).toHaveBeenCalledTimes(1);
 33: 		expect(handler).toHaveBeenCalledWith<[UnscopedMessageRequest<MockAction>, MessageResponder]>(
 34: 			{
 35: 				action: {
 36: 					id: "abc123",
 37: 					manifestId: "com.elgato.test.one",
 38: 				},
 39: 				path: "/test",
 40: 				unidirectional: false,
 41: 				body: {
 42: 					name: "Elgato",
 43: 				},
 44: 			},
 45: 			expect.any(MessageResponder),
 46: 		);
 47: 	});
 48: 	it("must not process unknown payloads", async () => {
 49: 		const proxy = jest.fn();
 50: 		const provider = jest.fn();
 51: 		const gateway = new MessageGateway<object>(proxy, provider);
 52: 		await gateway.process(true);
 53: 		expect(proxy).toHaveBeenCalledTimes(0);
 54: 		expect(provider).toHaveBeenCalledTimes(0);
 55: 	});
 56: 	it("emits unknownRequest and unknownRequest for unknown routes", async () => {
 57: 		const unknownMessageFn = jest.fn();
 58: 		const unknownRequestFn = jest.fn();
 59: 		const gateway = new MessageGateway<object>(jest.fn(), jest.fn());
 60: 		gateway.on("unhandledMessage", unknownMessageFn);
 61: 		gateway.on("unhandledRequest", unknownRequestFn);
 62: 		await gateway.process({
 63: 			action: "com.elgato.test.one",
 64: 			context: "abc123",
 65: 			event: "sendToPlugin",
 66: 			payload: {
 67: 				__type: "request",
 68: 				id: "abc123",
 69: 				path: "/",
 70: 				unidirectional: false,
 71: 			},
 72: 		} satisfies DidReceivePropertyInspectorMessage<RawMessageRequest>);
 73: 		expect(unknownRequestFn).toHaveBeenCalledTimes(1);
 74: 		expect(unknownRequestFn).toHaveBeenLastCalledWith({
 75: 			action: "com.elgato.test.one",
 76: 			context: "abc123",
 77: 			event: "sendToPlugin",
 78: 			payload: {
 79: 				__type: "request",
 80: 				id: "abc123",
 81: 				path: "/",
 82: 				unidirectional: false,
 83: 			},
 84: 		});
 85: 		expect(unknownMessageFn).toHaveBeenCalledTimes(1);
 86: 		expect(unknownMessageFn).toHaveBeenLastCalledWith({
 87: 			action: "com.elgato.test.one",
 88: 			context: "abc123",
 89: 			event: "sendToPlugin",
 90: 			payload: {
 91: 				__type: "request",
 92: 				id: "abc123",
 93: 				path: "/",
 94: 				unidirectional: false,
 95: 			},
 96: 		});
 97: 	});
 98: 	it("emits unknownMessage for payloads that aren't requests", async () => {
 99: 		const listener = jest.fn();
100: 		const gateway = new MessageGateway<object>(jest.fn(), jest.fn());
101: 		gateway.on("unhandledMessage", listener);
102: 		await gateway.process({
103: 			action: "com.elgato.test.one",
104: 			context: "abc123",
105: 			event: "sendToPlugin",
106: 			payload: true,
107: 		});
108: 		expect(listener).toHaveBeenCalledTimes(1);
109: 		expect(listener).toHaveBeenLastCalledWith({
110: 			action: "com.elgato.test.one",
111: 			context: "abc123",
112: 			event: "sendToPlugin",
113: 			payload: true,
114: 		});
115: 	});
116: 	it("must execute handlers in order", async () => {
117: 		const proxy = jest.fn();
118: 		const gateway = new MessageGateway<object>(proxy, jest.fn());
119: 		const order: string[] = [];
120: 		const handlers = [
121: 			() => {
122: 				order.push("First");
123: 			},
124: 			() => {
125: 				order.push("Second");
126: 			},
127: 		];
128: 		gateway.route("/test", handlers[0]);
129: 		gateway.route("/test", handlers[1]);
130: 		await gateway.process({
131: 			action: "com.elgato.test.one",
132: 			context: "abc123",
133: 			event: "sendToPlugin",
134: 			payload: {
135: 				__type: "request",
136: 				id: "12345",
137: 				path: "/test",
138: 				unidirectional: false,
139: 				body: {
140: 					name: "Elgato",
141: 				},
142: 			} satisfies RawMessageRequest,
143: 		});
144: 		expect(order).toEqual(["First", "Second"]);
145: 	});
146: 	it("must return 406 when the payload could not be sent to the server", async () => {
147: 		const proxy = jest.fn().mockReturnValue(false);
148: 		const gateway = new MessageGateway<object>(proxy, jest.fn());
149: 		const res = await gateway.fetch("/");
150: 		expect(res.status).toBe(406);
151: 		expect(res.ok).toBe(false);
152: 		expect(res.body).toBeUndefined();
153: 	});
154: 	it("can remove routes", async () => {
155: 		const proxy = jest.fn();
156: 		const listener = jest.fn();
157: 		const gateway = new MessageGateway<object>(proxy, jest.fn());
158: 		const ev = {
159: 			action: "com.elgato.test.one",
160: 			context: "abc123",
161: 			event: "sendToPlugin",
162: 			payload: {
163: 				__type: "request",
164: 				id: "12345",
165: 				path: "/test",
166: 				unidirectional: false,
167: 			},
168: 		} satisfies DidReceivePropertyInspectorMessage<RawMessageRequest>;
169: 		const disposable = gateway.route("/test", listener);
170: 		await gateway.process(ev);
171: 		expect(listener).toHaveBeenCalledTimes(1);
172: 		disposable.dispose();
173: 		await gateway.process(ev);
174: 		expect(listener).toHaveBeenCalledTimes(1);
175: 	});
176: 	describe("fetch e2e", () => {
177: 		let client!: MessageGateway<object>;
178: 		let server!: MessageGateway<object>;
179: 		let cascade!: (message: string) => void;
180: 		beforeEach(() => {
181: 			cascade = jest.fn();
182: 			client = new MessageGateway(async (value) => {
183: 				try {
184: 					await server.process({
185: 						action: "com.elgato.test.one",
186: 						context: "abc123",
187: 						event: "sendToPlugin",
188: 						payload: value as JsonValue,
189: 					});
190: 				} catch (err) {
191: 					if (!(err instanceof SafeError)) {
192: 						throw err;
193: 					}
194: 				}
195: 				return true;
196: 			}, jest.fn());
197: 			server = new MessageGateway<object>(async (value) => {
198: 				await client.process({
199: 					action: "com.elgato.test.one",
200: 					context: "abc123",
201: 					event: "sendToPropertyInspector",
202: 					payload: value as JsonValue,
203: 				});
204: 				return true;
205: 			}, jest.fn());
206: 			server.route("/async", () => {
207: 				return Promise.resolve(["Mario", "Luigi", "Peach"]);
208: 			});
209: 			server.route("/test", (req, res) => {
210: 				res.success({
211: 					name: "Elgato",
212: 				});
213: 			});
214: 			server.route("/error", () => {
215: 				throw new SafeError();
216: 			});
217: 			server.route("/cascade", () => {
218: 				cascade("First");
219: 				return true;
220: 			});
221: 			server.route("/cascade", () => {
222: 				cascade("Second");
223: 				return false;
224: 			});
225: 		});
226: 		afterEach(() => jest.resetAllMocks());
227: 		describe("known routes", () => {
228: 			it("200 on success", async () => {
229: 				const { body, ok, status } = await client.fetch<MockData>("/test");
230: 				expect(status).toBe(200);
231: 				expect(ok).toBeTruthy();
232: 				expect(body).toEqual({ name: "Elgato" });
233: 			});
234: 			it("202 on unidirectional request", async () => {
235: 				const { body, ok, status } = await client.fetch({
236: 					path: "/test",
237: 					unidirectional: true,
238: 				});
239: 				expect(status).toBe(202);
240: 				expect(ok).toBeTruthy();
241: 				expect(body).toBeUndefined();
242: 			});
243: 			it("data with promise result", async () => {
244: 				const { body, ok, status } = await client.fetch<MockData>("/async");
245: 				expect(status).toBe(200);
246: 				expect(ok).toBeTruthy();
247: 				expect(body).toEqual(["Mario", "Luigi", "Peach"]);
248: 			});
249: 			it("500 on error", async () => {
250: 				const { body, ok, status } = await client.fetch("/error");
251: 				expect(status).toBe(500);
252: 				expect(ok).toBeFalsy();
253: 				expect(body).toBeUndefined();
254: 			});
255: 			it("202 on error (unidirectional request)", async () => {
256: 				const { body, ok, status } = await client.fetch({
257: 					path: "/error",
258: 					unidirectional: true,
259: 				});
260: 				expect(status).toBe(202);
261: 				expect(ok).toBeTruthy();
262: 				expect(body).toBeUndefined();
263: 			});
264: 			it("408 on timeout", async () => {
265: 				const spyOnSetTimeout = jest.spyOn(global, "setTimeout").mockImplementation((fn) => fn());
266: 				const spyOnClearTimeout = jest.spyOn(global, "clearTimeout");
267: 				const res = client.fetch({
268: 					path: "/test",
269: 					timeout: 1,
270: 				});
271: 				const { body, ok, status } = await res;
272: 				expect(status).toBe(408);
273: 				expect(ok).toBeFalsy();
274: 				expect(body).toBeUndefined();
275: 				expect(spyOnSetTimeout).toHaveBeenCalledWith(expect.any(Function), 1);
276: 				expect(spyOnClearTimeout).toHaveBeenCalledTimes(0);
277: 			});
278: 		});
279: 		describe("unknown routes", () => {
280: 			it("501 on unknown routes", async () => {
281: 				const { body, ok, status } = await client.fetch("/unknown");
282: 				expect(status).toBe(501);
283: 				expect(ok).toBeFalsy();
284: 				expect(body).toBeUndefined();
285: 			});
286: 			it("501 on unknown routes (unidirectional request)", async () => {
287: 				const { body, ok, status } = await client.fetch({
288: 					path: "/unknown",
289: 					unidirectional: true,
290: 				});
291: 				expect(status).toBe(501);
292: 				expect(ok).toBeFalsy();
293: 				expect(body).toBeUndefined();
294: 			});
295: 		});
296: 		it("should execute all, but return after the first", async () => {
297: 			const { body, ok, status } = await client.fetch("/cascade");
298: 			expect(status).toBe(200);
299: 			expect(ok).toBe(true);
300: 			expect(body).toBe(true);
301: 			expect(cascade).toHaveBeenCalledTimes(2);
302: 			expect(cascade).toHaveBeenNthCalledWith(1, "First");
303: 			expect(cascade).toHaveBeenNthCalledWith(2, "Second");
304: 		});
305: 	});
306: });
307: type MockData = {
308: 	name: string;
309: };
310: class SafeError extends Error {}
</file>

<file path="src/common/messaging/__tests__/message.test.ts">
  1: import { isRequest, isResponse, type RawMessageRequest, type RawMessageResponse } from "../message";
  2: describe("isRequest", () => {
  3: 	const request = {
  4: 		__type: "request",
  5: 		id: "abc123",
  6: 		path: "/test",
  7: 		unidirectional: false,
  8: 	} satisfies RawMessageRequest;
  9: 	test("valid", () => {
 10: 		const actual = isRequest(request);
 11: 		expect(actual).toBe(true);
 12: 	});
 13: 	test.each([
 14: 		{
 15: 			name: "value must not be undefined",
 16: 			request: undefined,
 17: 		},
 18: 		{
 19: 			name: "value must not be null",
 20: 			request: null,
 21: 		},
 22: 		{
 23: 			name: "value must be an object",
 24: 			request: true,
 25: 		},
 26: 		{
 27: 			name: "__type must exist",
 28: 			request: {
 29: 				id: "abc123",
 30: 				path: "/test",
 31: 				unidirectional: true,
 32: 			},
 33: 		},
 34: 		{
 35: 			name: "id must exist",
 36: 			request: {
 37: 				__type: "request",
 38: 				path: "/test",
 39: 				unidirectional: true,
 40: 			},
 41: 		},
 42: 		{
 43: 			name: "path must exist",
 44: 			request: {
 45: 				__type: "request",
 46: 				id: "abc123",
 47: 				unidirectional: true,
 48: 			},
 49: 		},
 50: 		{
 51: 			name: "unidirectional must exist",
 52: 			request: {
 53: 				__type: "request",
 54: 				id: "abc123",
 55: 				path: "/test",
 56: 			},
 57: 		},
 58: 		{
 59: 			name: "__type must be 'request'",
 60: 			request: {
 61: 				...request,
 62: 				__type: "other",
 63: 			},
 64: 		},
 65: 		{
 66: 			name: "id must be string",
 67: 			request: {
 68: 				...request,
 69: 				id: 1,
 70: 			},
 71: 		},
 72: 		{
 73: 			name: "path must be string",
 74: 			request: {
 75: 				...request,
 76: 				path: false,
 77: 			},
 78: 		},
 79: 		{
 80: 			name: "unidirectional must be boolean",
 81: 			request: {
 82: 				...request,
 83: 				unidirectional: 13,
 84: 			},
 85: 		},
 86: 	])("$name", ({ request }) => {
 87: 		const actual = isRequest(request);
 88: 		expect(actual).toBe(false);
 89: 	});
 90: });
 91: describe("isResponse", () => {
 92: 	const response = {
 93: 		__type: "response",
 94: 		id: "abc123",
 95: 		path: "/test",
 96: 		status: 200,
 97: 	} satisfies RawMessageResponse;
 98: 	test("valid", () => {
 99: 		const actual = isResponse(response);
100: 		expect(actual).toBe(true);
101: 	});
102: 	test.each([
103: 		{
104: 			name: "value must not be undefined",
105: 			response: undefined,
106: 		},
107: 		{
108: 			name: "value must not be null",
109: 			response: null,
110: 		},
111: 		{
112: 			name: "value must be an object",
113: 			response: true,
114: 		},
115: 		{
116: 			name: "__type must exist",
117: 			response: {
118: 				id: "abc123",
119: 				path: "/test",
120: 				status: 200,
121: 			},
122: 		},
123: 		{
124: 			name: "id must exist",
125: 			response: {
126: 				__type: "response",
127: 				path: "/test",
128: 				status: 200,
129: 			},
130: 		},
131: 		{
132: 			name: "path must exist",
133: 			response: {
134: 				__type: "response",
135: 				id: "abc123",
136: 				status: 200,
137: 			},
138: 		},
139: 		{
140: 			name: "status must exist",
141: 			response: {
142: 				__type: "response",
143: 				id: "abc123",
144: 				path: "/test",
145: 			},
146: 		},
147: 		{
148: 			name: "__type must be 'response'",
149: 			response: {
150: 				...response,
151: 				__type: "other",
152: 			},
153: 		},
154: 		{
155: 			name: "id must be string",
156: 			response: {
157: 				...response,
158: 				id: 1,
159: 			},
160: 		},
161: 		{
162: 			name: "path must be string",
163: 			response: {
164: 				...response,
165: 				path: false,
166: 			},
167: 		},
168: 		{
169: 			name: "status must be number",
170: 			response: {
171: 				...response,
172: 				status: false,
173: 			},
174: 		},
175: 	])("$name", ({ response }) => {
176: 		const actual = isResponse(response);
177: 		expect(actual).toBe(false);
178: 	});
179: });
</file>

<file path="src/common/messaging/__tests__/responder.test.ts">
  1: import type { RawMessageResponse } from "../message";
  2: import { MessageResponder } from "../responder";
  3: describe("MessageResponder", () => {
  4: 	it("should send 200 with success", async () => {
  5: 		const proxy = jest.fn();
  6: 		const res = new MessageResponder(
  7: 			{
  8: 				__type: "request",
  9: 				id: "abc123",
 10: 				path: "/pets",
 11: 				unidirectional: false,
 12: 			},
 13: 			proxy,
 14: 		);
 15: 		await res.success(["Arthur", "Izzie", "Murphy"]);
 16: 		expect(proxy).toHaveBeenCalledTimes(1);
 17: 		expect(proxy).toHaveBeenLastCalledWith<[RawMessageResponse]>({
 18: 			__type: "response",
 19: 			id: "abc123",
 20: 			path: "/pets",
 21: 			status: 200,
 22: 			body: ["Arthur", "Izzie", "Murphy"],
 23: 		});
 24: 	});
 25: 	it("should send 500 with fail", async () => {
 26: 		const proxy = jest.fn();
 27: 		const res = new MessageResponder(
 28: 			{
 29: 				__type: "request",
 30: 				id: "abc123",
 31: 				path: "/toggle-light",
 32: 				unidirectional: false,
 33: 				body: {
 34: 					id: 123,
 35: 				},
 36: 			},
 37: 			proxy,
 38: 		);
 39: 		await res.fail([]);
 40: 		expect(proxy).toHaveBeenCalledTimes(1);
 41: 		expect(proxy).toHaveBeenLastCalledWith<[RawMessageResponse]>({
 42: 			__type: "response",
 43: 			id: "abc123",
 44: 			path: "/toggle-light",
 45: 			status: 500,
 46: 			body: [],
 47: 		});
 48: 	});
 49: 	it("send status", async () => {
 50: 		const proxy = jest.fn();
 51: 		const res = new MessageResponder(
 52: 			{
 53: 				__type: "request",
 54: 				id: "abc123",
 55: 				path: "/mute-mic",
 56: 				unidirectional: false,
 57: 			},
 58: 			proxy,
 59: 		);
 60: 		await res.send(501);
 61: 		expect(proxy).toHaveBeenCalledTimes(1);
 62: 		expect(proxy).toHaveBeenLastCalledWith<[RawMessageResponse]>({
 63: 			__type: "response",
 64: 			id: "abc123",
 65: 			path: "/mute-mic",
 66: 			status: 501,
 67: 		});
 68: 	});
 69: 	it("can respond when unidirectional", async () => {
 70: 		const proxy = jest.fn();
 71: 		const res = new MessageResponder(
 72: 			{
 73: 				__type: "request",
 74: 				id: "abc123",
 75: 				path: "/test",
 76: 				unidirectional: true,
 77: 			},
 78: 			proxy,
 79: 		);
 80: 		await res.success();
 81: 		expect(proxy).toHaveBeenCalledTimes(1);
 82: 		expect(proxy).toHaveBeenLastCalledWith<[RawMessageResponse]>({
 83: 			__type: "response",
 84: 			id: "abc123",
 85: 			path: "/test",
 86: 			status: 200,
 87: 		});
 88: 	});
 89: 	it("down not respond more than once", async () => {
 90: 		const proxy = jest.fn();
 91: 		const res = new MessageResponder(
 92: 			{
 93: 				__type: "request",
 94: 				id: "abc123",
 95: 				path: "/test",
 96: 				unidirectional: false,
 97: 				body: {
 98: 					id: 123,
 99: 				},
100: 			},
101: 			proxy,
102: 		);
103: 		await res.success();
104: 		await res.success({ test: "other" });
105: 		expect(proxy).toHaveBeenCalledTimes(1);
106: 		expect(proxy).toHaveBeenLastCalledWith<[RawMessageResponse]>({
107: 			__type: "response",
108: 			id: "abc123",
109: 			path: "/test",
110: 			status: 200,
111: 		});
112: 	});
113: });
</file>

<file path="src/common/messaging/gateway.ts">
  1: import type { DidReceivePluginMessage, DidReceivePropertyInspectorMessage } from "../../api";
  2: import { IDisposable } from "../disposable";
  3: import { EventEmitter } from "../event-emitter";
  4: import type { JsonValue } from "../json";
  5: import { isRequest, isResponse, type RawMessageRequest, type RawMessageResponse, type StatusCode } from "./message";
  6: import { MessageResponder } from "./responder";
  7: const DEFAULT_TIMEOUT = 5000;
  8: export const PUBLIC_PATH_PREFIX = "public:";
  9: export const INTERNAL_PATH_PREFIX = "internal:";
 10: export class MessageGateway<TAction> extends EventEmitter<MessageGatewayEventMap> {
 11: 	private readonly requests = new Map<string, (res: MessageResponse) => void>();
 12: 	private readonly routes = new EventEmitter();
 13: 	constructor(
 14: 		private readonly proxy: OutboundMessageProxy,
 15: 		private readonly actionProvider: ActionProvider<TAction>,
 16: 	) {
 17: 		super();
 18: 	}
 19: 	public async fetch<T extends JsonValue = JsonValue>(request: MessageRequestOptions): Promise<MessageResponse<T>>;
 20: 	public async fetch<T extends JsonValue = JsonValue>(path: string, body?: JsonValue): Promise<MessageResponse<T>>;
 21: 	public async fetch<T extends JsonValue = JsonValue>(
 22: 		requestOrPath: MessageRequestOptions | string,
 23: 		bodyOrUndefined?: JsonValue,
 24: 	): Promise<MessageResponse<T>> {
 25: 		const id = crypto.randomUUID();
 26: 		const {
 27: 			body,
 28: 			path,
 29: 			timeout = DEFAULT_TIMEOUT,
 30: 			unidirectional = false,
 31: 		} = typeof requestOrPath === "string" ? { body: bodyOrUndefined, path: requestOrPath } : requestOrPath;
 32: 		const response = new Promise<MessageResponse<T>>((resolve) => {
 33: 			this.requests.set(id, (res: MessageResponse) => {
 34: 				if (res.status !== 408) {
 35: 					clearTimeout(timeoutMonitor);
 36: 				}
 37: 				resolve(res as MessageResponse<T>);
 38: 			});
 39: 		});
 40: 		const timeoutMonitor = setTimeout(
 41: 			() => this.handleResponse({ __type: "response", id, path, status: 408 }),
 42: 			timeout,
 43: 		);
 44: 		const accepted = await this.proxy({
 45: 			__type: "request",
 46: 			body,
 47: 			id,
 48: 			path,
 49: 			unidirectional,
 50: 		} satisfies RawMessageRequest);
 51: 		if (!accepted) {
 52: 			this.handleResponse({ __type: "response", id, path, status: 406 });
 53: 		}
 54: 		return response;
 55: 	}
 56: 	public async process(
 57: 		message: DidReceivePluginMessage<JsonValue> | DidReceivePropertyInspectorMessage<JsonValue>,
 58: 	): Promise<void> {
 59: 		if (isRequest(message.payload)) {
 60: 			const action = this.actionProvider(message);
 61: 			if (await this.handleRequest(action, message.payload)) {
 62: 				return;
 63: 			}
 64: 			this.emit(
 65: 				"unhandledRequest",
 66: 				message as DidReceivePluginMessage<RawMessageRequest> | DidReceivePropertyInspectorMessage<RawMessageRequest>,
 67: 			);
 68: 		} else if (isResponse(message.payload) && this.handleResponse(message.payload)) {
 69: 			return;
 70: 		}
 71: 		this.emit("unhandledMessage", message);
 72: 	}
 73: 	public route<TBody extends JsonValue = JsonValue>(
 74: 		path: string,
 75: 		handler: UnscopedMessageHandler<TAction, TBody>,
 76: 		options?: RouteConfiguration<TAction>,
 77: 	): IDisposable {
 78: 		options = { filter: (): boolean => true, ...options };
 79: 		return this.routes.disposableOn(path, async (ev: InternalRouteHandlerEventArgs<TAction, TBody>) => {
 80: 			if (options?.filter && options.filter(ev.request.action)) {
 81: 				await ev.routed();
 82: 				try {
 83: 					const result = await handler(ev.request, ev.responder);
 84: 					if (result !== undefined) {
 85: 						await ev.responder.send(200, result);
 86: 					}
 87: 				} catch (err) {
 88: 					await ev.responder.send(500);
 89: 					throw err;
 90: 				}
 91: 			}
 92: 		});
 93: 	}
 94: 	private async handleRequest(action: TAction, source: RawMessageRequest): Promise<boolean> {
 95: 		const responder = new MessageResponder(source, this.proxy);
 96: 		const request: UnscopedMessageRequest<TAction, JsonValue> = {
 97: 			action,
 98: 			path: source.path,
 99: 			unidirectional: source.unidirectional,
100: 			body: source.body,
101: 		};
102: 		let routed = false;
103: 		const routes = this.routes.listeners(source.path) as ((
104: 			ev: InternalRouteHandlerEventArgs<TAction>,
105: 		) => Promise<void>)[];
106: 		for (const route of routes) {
107: 			await route({
108: 				request,
109: 				responder,
110: 				routed: async (): Promise<void> => {
111: 					if (request.unidirectional) {
112: 						await responder.send(202);
113: 					}
114: 					routed = true;
115: 				},
116: 			});
117: 		}
118: 		if (routed) {
119: 			await responder.send(200);
120: 			return true;
121: 		}
122: 		await responder.send(501);
123: 		return false;
124: 	}
125: 	private handleResponse(res: RawMessageResponse): boolean {
126: 		const handler = this.requests.get(res.id);
127: 		this.requests.delete(res.id);
128: 		if (handler) {
129: 			handler(new MessageResponse(res));
130: 			return true;
131: 		}
132: 		return false;
133: 	}
134: }
135: type PluginOrPropertyInspectorMessage<T extends JsonValue> =
136: 	| DidReceivePluginMessage<T>
137: 	| DidReceivePropertyInspectorMessage<T>;
138: type MessageGatewayEventMap = {
139: 	unhandledMessage: [message: PluginOrPropertyInspectorMessage<JsonValue>];
140: 	unhandledRequest: [message: PluginOrPropertyInspectorMessage<RawMessageRequest>];
141: };
142: export type MessageRequestOptions = {
143: 	body?: JsonValue;
144: 	path: string;
145: 	timeout?: number;
146: 	unidirectional?: boolean;
147: };
148: class MessageResponse<TBody extends JsonValue = JsonValue> {
149: 	public readonly body?: TBody;
150: 	public readonly status: StatusCode;
151: 	constructor(res: RawMessageResponse) {
152: 		this.body = res.body as TBody;
153: 		this.status = res.status;
154: 	}
155: 	public get ok(): boolean {
156: 		return this.status >= 200 && this.status < 300;
157: 	}
158: }
159: export { type MessageResponse };
160: export type OutboundMessageProxy = (payload: JsonValue) => Promise<boolean> | boolean;
161: export type ActionProvider<T> = (
162: 	source: DidReceivePluginMessage<JsonValue> | DidReceivePropertyInspectorMessage<JsonValue>,
163: ) => T;
164: export type UnscopedMessageRequest<TAction, TBody extends JsonValue = JsonValue> = Omit<
165: 	RawMessageRequest,
166: 	"__type" | "body" | "id"
167: > & {
168: 	readonly action: TAction;
169: 	readonly body?: TBody;
170: };
171: export type UnscopedMessageHandler<TAction, TBody extends JsonValue = JsonValue> = (
172: 	request: UnscopedMessageRequest<TAction, TBody>,
173: 	response: MessageResponder,
174: ) => JsonValue | Promise<JsonValue | void> | void;
175: export type RouteConfiguration<TAction> = {
176: 	filter?: (source: TAction) => boolean;
177: };
178: type InternalRouteHandlerEventArgs<TAction, TBody extends JsonValue = JsonValue> = {
179: 	request: UnscopedMessageRequest<TAction, TBody>;
180: 	responder: MessageResponder;
181: 	routed(): Promise<void>;
182: };
</file>

<file path="src/common/messaging/index.ts">
1: export * from "./gateway";
2: export { type StatusCode } from "./message";
3: export { MessageResponder } from "./responder";
</file>

<file path="src/common/messaging/message.ts">
 1: import type { JsonValue } from "../json";
 2: export function isRequest(value: unknown): value is RawMessageRequest {
 3: 	return isMessage(value, "request") && has(value, "unidirectional", "boolean");
 4: }
 5: export function isResponse(value: unknown): value is RawMessageResponse {
 6: 	return isMessage(value, "response") && has(value, "status", "number");
 7: }
 8: function isMessage<T extends MessageType>(value: unknown, type: T): value is Message<T> {
 9: 	if (value === undefined || value === null || typeof value !== "object") {
10: 		return false;
11: 	}
12: 	if (!("__type" in value) || value.__type !== type) {
13: 		return false;
14: 	}
15: 	return has(value, "id", "string") && has(value, "path", "string");
16: }
17: function has(obj: object, key: string, type: "boolean" | "number" | "string"): boolean {
18: 	return key in obj && typeof obj[key as keyof typeof obj] === type;
19: }
20: type Message<T extends MessageType> = {
21: 	readonly __type: T;
22: 	readonly body?: JsonValue;
23: 	readonly id: string;
24: 	readonly path: string;
25: };
26: type MessageType = "request" | "response";
27: export type RawMessageRequest = Message<"request"> & {
28: 	readonly unidirectional: boolean;
29: };
30: export type RawMessageResponse = Message<"response"> & {
31: 	readonly status: StatusCode;
32: };
33: export type StatusCode =
34: 	| 200
35: 	| 202
36: 	| 406
37: 	| 408
38: 	| 500
39: 	| 501;
</file>

<file path="src/common/messaging/responder.ts">
 1: import type { JsonValue } from "../json";
 2: import type { OutboundMessageProxy } from "./gateway";
 3: import type { RawMessageRequest, RawMessageResponse, StatusCode } from "./message";
 4: export class MessageResponder {
 5: 	private _responded = false;
 6: 	constructor(
 7: 		private readonly request: RawMessageRequest,
 8: 		private readonly proxy: OutboundMessageProxy,
 9: 	) {}
10: 	public get canRespond(): boolean {
11: 		return !this._responded;
12: 	}
13: 	public fail(body?: JsonValue): Promise<void> {
14: 		return this.send(500, body);
15: 	}
16: 	public async send(status: StatusCode, body?: JsonValue): Promise<void> {
17: 		if (this.canRespond) {
18: 			await this.proxy({
19: 				__type: "response",
20: 				id: this.request.id,
21: 				path: this.request.path,
22: 				body,
23: 				status,
24: 			} satisfies RawMessageResponse);
25: 			this._responded = true;
26: 		}
27: 	}
28: 	public success(body?: JsonValue): Promise<void> {
29: 		return this.send(200, body);
30: 	}
31: }
</file>

<file path="src/common/disposable.ts">
 1: (Symbol as any).dispose ??= Symbol("Symbol.dispose");
 2: export function deferredDisposable(dispose: (...args: unknown[]) => void): IDisposable {
 3: 	let isDisposed = false;
 4: 	const guardedDispose = (): void => {
 5: 		if (!isDisposed) {
 6: 			dispose();
 7: 			isDisposed = true;
 8: 		}
 9: 	};
10: 	return {
11: 		[Symbol.dispose]: guardedDispose,
12: 		dispose: guardedDispose,
13: 	};
14: }
15: export interface IDisposable {
16: 	[Symbol.dispose](): void;
17: 	dispose(): void;
18: }
</file>

<file path="src/common/enumerable.ts">
  1: export class Enumerable<T> implements IterableIterator<T> {
  2: 	readonly #items: () => IterableIterator<T>;
  3: 	readonly #length: () => number;
  4: 	#iterator: Iterator<T> | undefined;
  5: 	constructor(source: Enumerable<T> | Map<unknown, T> | Set<T> | T[] | (() => IterableIterator<T>)) {
  6: 		if (source instanceof Enumerable) {
  7: 			this.#items = source.#items;
  8: 			this.#length = source.#length;
  9: 		} else if (Array.isArray(source)) {
 10: 			this.#items = (): IterableIterator<T> => source.values();
 11: 			this.#length = (): number => source.length;
 12: 		} else if (source instanceof Map || source instanceof Set) {
 13: 			this.#items = (): IterableIterator<T> => source.values();
 14: 			this.#length = (): number => source.size;
 15: 		} else {
 16: 			this.#items = source;
 17: 			this.#length = (): number => {
 18: 				let i = 0;
 19: 				for (const _ of this) {
 20: 					i++;
 21: 				}
 22: 				return i;
 23: 			};
 24: 		}
 25: 	}
 26: 	public get length(): number {
 27: 		return this.#length();
 28: 	}
 29: 	public *[Symbol.iterator](): IterableIterator<T> {
 30: 		for (const item of this.#items()) {
 31: 			yield item;
 32: 		}
 33: 	}
 34: 	public asIndexedPairs(): Enumerable<[number, T]> {
 35: 		return new Enumerable(
 36: 			function* (this: Enumerable<T>): IterableIterator<[number, T]> {
 37: 				let i = 0;
 38: 				for (const item of this) {
 39: 					yield [i++, item] as [number, T];
 40: 				}
 41: 			}.bind(this),
 42: 		);
 43: 	}
 44: 	public drop(limit: number): Enumerable<T> {
 45: 		if (isNaN(limit) || limit < 0) {
 46: 			throw new RangeError("limit must be 0, or a positive number");
 47: 		}
 48: 		return new Enumerable(
 49: 			function* (this: Enumerable<T>): IterableIterator<T> {
 50: 				let i = 0;
 51: 				for (const item of this) {
 52: 					if (i++ >= limit) {
 53: 						yield item;
 54: 					}
 55: 				}
 56: 			}.bind(this),
 57: 		);
 58: 	}
 59: 	public every(predicate: (value: T) => boolean): boolean {
 60: 		for (const item of this) {
 61: 			if (!predicate(item)) {
 62: 				return false;
 63: 			}
 64: 		}
 65: 		return true;
 66: 	}
 67: 	public filter(predicate: (value: T) => boolean): Enumerable<T> {
 68: 		return new Enumerable(
 69: 			function* (this: Enumerable<T>): IterableIterator<T> {
 70: 				for (const item of this) {
 71: 					if (predicate(item)) {
 72: 						yield item;
 73: 					}
 74: 				}
 75: 			}.bind(this),
 76: 		);
 77: 	}
 78: 	public find(predicate: (value: T) => boolean): T | undefined {
 79: 		for (const item of this) {
 80: 			if (predicate(item)) {
 81: 				return item;
 82: 			}
 83: 		}
 84: 	}
 85: 	public findLast(predicate: (value: T) => boolean): T | undefined {
 86: 		let result = undefined;
 87: 		for (const item of this) {
 88: 			if (predicate(item)) {
 89: 				result = item;
 90: 			}
 91: 		}
 92: 		return result;
 93: 	}
 94: 	public flatMap<U>(mapper: (item: T) => IterableIterator<U>): Enumerable<U> {
 95: 		return new Enumerable(
 96: 			function* (this: Enumerable<T>): IterableIterator<U> {
 97: 				for (const item of this) {
 98: 					for (const mapped of mapper(item)) {
 99: 						yield mapped;
100: 					}
101: 				}
102: 			}.bind(this),
103: 		);
104: 	}
105: 	public forEach(fn: (item: T) => void): void {
106: 		for (const item of this) {
107: 			fn(item);
108: 		}
109: 	}
110: 	public includes(search: T): boolean {
111: 		return this.some((item) => item === search);
112: 	}
113: 	public map<U>(mapper: (value: T) => U): Enumerable<U> {
114: 		return new Enumerable<U>(
115: 			function* (this: Enumerable<T>): IterableIterator<U> {
116: 				for (const item of this) {
117: 					yield mapper(item);
118: 				}
119: 			}.bind(this),
120: 		);
121: 	}
122: 	public next(...args: [] | [undefined]): IteratorResult<T, T> {
123: 		this.#iterator ??= this.#items();
124: 		const result = this.#iterator.next(...args);
125: 		if (result.done) {
126: 			this.#iterator = undefined;
127: 		}
128: 		return result;
129: 	}
130: 	public reduce(accumulator: (previous: T, current: T) => T): T;
131: 	public reduce<R>(accumulator: (previous: R, current: T) => R, initial: R): R;
132: 	public reduce<R>(accumulator: (previous: R | T, current: T) => R | T, initial?: R | T): R | T {
133: 		if (this.length === 0) {
134: 			if (initial === undefined) {
135: 				throw new TypeError("Reduce of empty enumerable with no initial value.");
136: 			}
137: 			return initial;
138: 		}
139: 		let result = initial;
140: 		for (const item of this) {
141: 			if (result === undefined) {
142: 				result = item;
143: 			} else {
144: 				result = accumulator(result, item);
145: 			}
146: 		}
147: 		return result!;
148: 	}
149: 	public return?<TReturn>(value?: TReturn): IteratorResult<T, TReturn | undefined> {
150: 		this.#iterator = undefined;
151: 		return { done: true, value };
152: 	}
153: 	public some(predicate: (value: T) => boolean): boolean {
154: 		for (const item of this) {
155: 			if (predicate(item)) {
156: 				return true;
157: 			}
158: 		}
159: 		return false;
160: 	}
161: 	public take(limit: number): Enumerable<T> {
162: 		if (isNaN(limit) || limit < 0) {
163: 			throw new RangeError("limit must be 0, or a positive number");
164: 		}
165: 		return new Enumerable(
166: 			function* (this: Enumerable<T>): IterableIterator<T> {
167: 				let i = 0;
168: 				for (const item of this) {
169: 					if (i++ < limit) {
170: 						yield item;
171: 					}
172: 				}
173: 			}.bind(this),
174: 		);
175: 	}
176: 	public throw?<TReturn>(e?: TReturn): IteratorResult<T, TReturn | undefined> {
177: 		throw e;
178: 	}
179: 	public toArray(): T[] {
180: 		return Array.from(this);
181: 	}
182: 	public toJSON(): T[] {
183: 		return this.toArray();
184: 	}
185: 	public toString(): string {
186: 		return `${this.toArray()}`;
187: 	}
188: }
</file>

<file path="src/common/event-emitter.ts">
  1: import { deferredDisposable, type IDisposable } from "./disposable";
  2: export class EventEmitter<TMap extends EventMap<TMap>> {
  3: 	private readonly events = new Map<EventsOf<TMap>, EventListener[]>();
  4: 	public addListener<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
  5: 		eventName: TEventName,
  6: 		listener: (...args: TArgs) => void,
  7: 	): this {
  8: 		return this.on(eventName, listener);
  9: 	}
 10: 	public disposableOn<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 11: 		eventName: TEventName,
 12: 		listener: (...args: TArgs) => void,
 13: 	): IDisposable {
 14: 		this.addListener(eventName, listener);
 15: 		return deferredDisposable(() => this.removeListener(eventName, listener));
 16: 	}
 17: 	public emit<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 18: 		eventName: TEventName,
 19: 		...args: TArgs
 20: 	): boolean {
 21: 		const listeners = this.events.get(eventName);
 22: 		if (listeners === undefined) {
 23: 			return false;
 24: 		}
 25: 		for (let i = 0; i < listeners.length; ) {
 26: 			const { listener, once } = listeners[i];
 27: 			if (once) {
 28: 				listeners.splice(i, 1);
 29: 			} else {
 30: 				i++;
 31: 			}
 32: 			listener(...args);
 33: 		}
 34: 		return true;
 35: 	}
 36: 	public eventNames(): EventsOf<TMap>[] {
 37: 		return Array.from(this.events.keys());
 38: 	}
 39: 	public listenerCount<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 40: 		eventName: TEventName,
 41: 		listener?: (...args: TArgs) => void,
 42: 	): number {
 43: 		const listeners = this.events.get(eventName);
 44: 		if (listeners === undefined || listener == undefined) {
 45: 			return listeners?.length || 0;
 46: 		}
 47: 		let count = 0;
 48: 		listeners.forEach((ev) => {
 49: 			if (ev.listener === listener) {
 50: 				count++;
 51: 			}
 52: 		});
 53: 		return count;
 54: 	}
 55: 	public listeners<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 56: 		eventName: TEventName,
 57: 	): ((...args: TArgs) => void)[] {
 58: 		return Array.from(this.events.get(eventName) || []).map(({ listener }) => listener);
 59: 	}
 60: 	public off<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 61: 		eventName: TEventName,
 62: 		listener: (...args: TArgs) => void,
 63: 	): this {
 64: 		const listeners = this.events.get(eventName) || [];
 65: 		for (let i = listeners.length - 1; i >= 0; i--) {
 66: 			if (listeners[i].listener === listener) {
 67: 				listeners.splice(i, 1);
 68: 			}
 69: 		}
 70: 		return this;
 71: 	}
 72: 	public on<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 73: 		eventName: TEventName,
 74: 		listener: (...args: TArgs) => void,
 75: 	): this {
 76: 		return this.add(eventName, (listeners) => listeners.push({ listener }));
 77: 	}
 78: 	public once<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 79: 		eventName: TEventName,
 80: 		listener: (...args: TArgs) => void,
 81: 	): this {
 82: 		return this.add(eventName, (listeners) => listeners.push({ listener, once: true }));
 83: 	}
 84: 	public prependListener<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 85: 		eventName: TEventName,
 86: 		listener: (...args: TArgs) => void,
 87: 	): this {
 88: 		return this.add(eventName, (listeners) => listeners.splice(0, 0, { listener }));
 89: 	}
 90: 	public prependOnceListener<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
 91: 		eventName: TEventName,
 92: 		listener: (...args: TArgs) => void,
 93: 	): this {
 94: 		return this.add(eventName, (listeners) => listeners.splice(0, 0, { listener, once: true }));
 95: 	}
 96: 	public removeAllListeners<TEventName extends EventsOf<TMap>>(eventName: TEventName): this {
 97: 		this.events.delete(eventName);
 98: 		return this;
 99: 	}
100: 	public removeListener<TEventName extends EventsOf<TMap>, TArgs extends EventArgs<TMap, TEventName>>(
101: 		eventName: TEventName,
102: 		listener: (...args: TArgs) => void,
103: 	): this {
104: 		return this.off(eventName, listener);
105: 	}
106: 	private add<TEventName extends EventsOf<TMap>>(
107: 		eventName: TEventName,
108: 		fn: (listeners: EventListener[]) => void,
109: 	): this {
110: 		let listeners = this.events.get(eventName);
111: 		if (listeners === undefined) {
112: 			listeners = [];
113: 			this.events.set(eventName, listeners);
114: 		}
115: 		fn(listeners);
116: 		return this;
117: 	}
118: }
119: type EventMap<T> = {
120: 	[K in keyof T]: K extends string ? (T[K] extends unknown[] ? T[K] : never) : never;
121: };
122: export type EventsOf<TMap extends EventMap<TMap>> = keyof TMap | (string & {});
123: export type EventArgs<TMap extends EventMap<TMap>, TEvent extends EventsOf<TMap>> = TEvent extends keyof TMap
124: 	? TMap[TEvent] extends unknown[]
125: 		? TMap[TEvent]
126: 		: never
127: 	: unknown[];
128: type EventListener = {
129: 	listener: (...args: any) => void;
130: 	once?: true;
131: };
</file>

<file path="src/common/i18n.ts">
 1: import { type Language, supportedLanguages } from "../api";
 2: import { JsonObject } from "../common/json";
 3: import { freeze, get } from "./utils";
 4: export class I18nProvider {
 5: 	private static readonly DEFAULT_LANGUAGE: Language = "en";
 6: 	private readonly _translations: Map<Language, JsonObject | null> = new Map();
 7: 	constructor(
 8: 		private readonly language: Language,
 9: 		private readonly readTranslations: TranslationsReader,
10: 	) {}
11: 	public t(key: string, language: Language = this.language): string {
12: 		return this.translate(key, language);
13: 	}
14: 	public translate(key: string, language: Language = this.language): string {
15: 		if (language === I18nProvider.DEFAULT_LANGUAGE) {
16: 			return get(key, this.getTranslations(language))?.toString() || key;
17: 		}
18: 		return (
19: 			get(key, this.getTranslations(language))?.toString() ||
20: 			get(key, this.getTranslations(I18nProvider.DEFAULT_LANGUAGE))?.toString() ||
21: 			key
22: 		);
23: 	}
24: 	private getTranslations(language: Language): JsonObject | null {
25: 		let translations = this._translations.get(language);
26: 		if (translations === undefined) {
27: 			translations = supportedLanguages.includes(language) ? this.readTranslations(language) : null;
28: 			freeze(translations);
29: 			this._translations.set(language, translations);
30: 		}
31: 		return translations;
32: 	}
33: }
34: export type TranslationsReader = (language: Language) => JsonObject | null;
35: export function parseLocalizations(contents: string): JsonObject {
36: 	const json = JSON.parse(contents);
37: 	if (json !== undefined && json !== null && typeof json === "object" && "Localization" in json) {
38: 		return json["Localization"] as JsonObject;
39: 	}
40: 	throw new TypeError(`Translations must be a JSON object nested under a property named "Localization"`);
41: }
</file>

<file path="src/common/json.ts">
1: export type JsonObject = {
2: 	[key: string]: JsonValue;
3: };
4: export type JsonPrimitive = boolean | number | string | null | undefined;
5: export type JsonValue = JsonObject | JsonPrimitive | JsonValue[];
</file>

<file path="src/common/promises.ts">
 1: export class PromiseCompletionSource<T> {
 2: 	private readonly _promise: Promise<T>;
 3: 	private _reject?: (reason?: unknown) => void;
 4: 	private _resolve?: (value: PromiseLike<T> | T) => void;
 5: 	constructor() {
 6: 		this._promise = new Promise<T>((resolve, reject) => {
 7: 			this._resolve = resolve;
 8: 			this._reject = reject;
 9: 		});
10: 	}
11: 	public get promise(): Promise<T> {
12: 		return this._promise;
13: 	}
14: 	public setException(reason?: unknown): void {
15: 		if (this._reject) {
16: 			this._reject(reason);
17: 		}
18: 	}
19: 	public setResult(value: PromiseLike<T> | T): void {
20: 		if (this._resolve) {
21: 			this._resolve(value);
22: 		}
23: 	}
24: }
</file>

<file path="src/common/utils.ts">
 1: export function freeze<T>(value: T): void {
 2: 	if (value !== undefined && value !== null && typeof value === "object" && !Object.isFrozen(value)) {
 3: 		Object.freeze(value);
 4: 		Object.values(value).forEach(freeze);
 5: 	}
 6: }
 7: export function get(path: string, source: unknown): unknown {
 8: 	const props: string[] = path.split(".");
 9: 	return props.reduce((obj, prop) => obj && obj[prop as keyof object], source);
10: }
11: export type KeyOf<T, K extends keyof T> = Omit<T[K], "">;
</file>

<file path="src/plugin/__mocks__/connection.ts">
 1: import { registrationInfo } from "../../api/registration/__mocks__";
 2: const { connection } = jest.requireActual<typeof import("../connection")>("../connection");
 3: jest.spyOn(connection, "connect").mockReturnValue(Promise.resolve());
 4: jest.spyOn(connection, "registrationParameters", "get").mockReturnValue({
 5: 	info: registrationInfo,
 6: 	pluginUUID: "abc123",
 7: 	port: "12345",
 8: 	registerEvent: "register",
 9: });
10: jest.spyOn(connection, "send").mockReturnValue(Promise.resolve());
11: export { connection };
</file>

<file path="src/plugin/__mocks__/manifest.ts">
 1: import type { Manifest } from "../../api";
 2: import { Version } from "../common/version";
 3: import type {
 4: 	getManifest as __getManifest,
 5: 	getSoftwareMinimumVersion as __getSoftwareMinimumVersion,
 6: } from "../manifest";
 7: export const manifest: Manifest = {
 8: 	Actions: [
 9: 		{
10: 			Name: "Action One",
11: 			UUID: "com.elgato.test.key",
12: 			Icon: "imgs/actions/one",
13: 			States: [
14: 				{
15: 					Image: "imgs/actions/state",
16: 				},
17: 			],
18: 		},
19: 		{
20: 			Name: "Action Two",
21: 			UUID: "com.elgato.test.dial",
22: 			Icon: "imgs/actions/one",
23: 			States: [
24: 				{
25: 					Image: "imgs/actions/state",
26: 				},
27: 			],
28: 		},
29: 	],
30: 	Author: "Elgato",
31: 	CodePath: "index.js",
32: 	Description: "Example manifest",
33: 	Icon: "imgs/plugin",
34: 	Name: "Test Plugin",
35: 	OS: [
36: 		{
37: 			MinimumVersion: "11",
38: 			Platform: "windows",
39: 		},
40: 	],
41: 	SDKVersion: 2,
42: 	Software: {
43: 		MinimumVersion: "6.5",
44: 	},
45: 	UUID: "com.elgato.test",
46: 	Version: "1.0.0",
47: };
48: export const getSoftwareMinimumVersion = jest.fn().mockReturnValue(new Version("6.5"));
49: export const getManifest = jest.fn().mockReturnValue(manifest);
</file>

<file path="src/plugin/__tests__/connection.test.ts">
  1: import { type WS as WebSocketServer } from "jest-websocket-mock";
  2: import type { RegistrationInfo } from "..";
  3: import type { ApplicationDidLaunch, DidReceiveGlobalSettings, OpenUrl } from "../../api";
  4: import type { Settings } from "../../api/__mocks__/events";
  5: import { registrationInfo } from "../../api/registration/__mocks__";
  6: import { Logger, LogLevel } from "../../common/logging";
  7: import { type connection as Connection } from "../connection";
  8: jest.mock("ws");
  9: jest.mock("../logging");
 10: const port = ["-port", "12345"];
 11: const pluginUUID = ["-pluginUUID", "abc123"];
 12: const registerEvent = ["-registerEvent", "test_event"];
 13: const info = ["-info", `{"plugin":{"uuid":"com.elgato.test","version":"0.1.0"}}`];
 14: const originalArgv = process.argv;
 15: describe("connection", () => {
 16: 	let logger!: Logger;
 17: 	let connection!: typeof Connection;
 18: 	let connectionLogger: Logger;
 19: 	beforeEach(async () => {
 20: 		connectionLogger = new Logger({
 21: 			level: LogLevel.TRACE,
 22: 			targets: [{ write: jest.fn() }],
 23: 		});
 24: 		({ logger } = await require("../logging"));
 25: 		jest.spyOn(logger, "createScope").mockReturnValueOnce(connectionLogger);
 26: 		({ connection } = await require("../connection"));
 27: 		process.argv = [...port, ...pluginUUID, ...registerEvent, ...info];
 28: 	});
 29: 	afterEach(() => {
 30: 		process.argv = originalArgv;
 31: 		jest.resetModules();
 32: 	});
 33: 	describe("WebSocket", () => {
 34: 		let server: WebSocketServer;
 35: 		beforeEach(async () => {
 36: 			const { WS } = await require("jest-websocket-mock");
 37: 			server = new WS(`ws://127.0.0.1:${port[1]}`, { jsonProtocol: true });
 38: 		});
 39: 		afterEach(() => server.close());
 40: 		it("connect", async () => {
 41: 			await connection.connect();
 42: 			await expect(server).toReceiveMessage({
 43: 				event: registerEvent[1],
 44: 				uuid: pluginUUID[1],
 45: 			});
 46: 		});
 47: 		it("emits connected", async () => {
 48: 			const listener = jest.fn();
 49: 			connection.on("connected", listener);
 50: 			await connection.connect();
 51: 			expect(listener).toHaveBeenCalledTimes(1);
 52: 			expect(listener).toBeCalledWith<[RegistrationInfo]>(JSON.parse(info[1]));
 53: 		});
 54: 		it("sends", async () => {
 55: 			await connection.connect();
 56: 			await connection.send({
 57: 				event: "setSettings",
 58: 				context: "abc123",
 59: 				payload: {
 60: 					message: "Hello world",
 61: 				},
 62: 			});
 63: 			await expect(server).toReceiveMessage({
 64: 				event: registerEvent[1],
 65: 				uuid: pluginUUID[1],
 66: 			});
 67: 			await expect(server).toReceiveMessage({
 68: 				event: "setSettings",
 69: 				context: "abc123",
 70: 				payload: {
 71: 					message: "Hello world",
 72: 				},
 73: 			});
 74: 		});
 75: 		it("propagates messages", async () => {
 76: 			const listener = jest.fn();
 77: 			connection.on("didReceiveGlobalSettings", listener);
 78: 			await connection.connect();
 79: 			server.send({
 80: 				event: "didReceiveGlobalSettings",
 81: 				payload: {
 82: 					settings: {
 83: 						name: "Elgato",
 84: 					},
 85: 				},
 86: 			} satisfies DidReceiveGlobalSettings<Settings>);
 87: 			expect(listener).toHaveBeenCalledTimes(1);
 88: 			expect(listener).toHaveBeenCalledWith<[DidReceiveGlobalSettings<Settings>]>({
 89: 				event: "didReceiveGlobalSettings",
 90: 				payload: {
 91: 					settings: {
 92: 						name: "Elgato",
 93: 					},
 94: 				},
 95: 			});
 96: 		});
 97: 		describe("logging", () => {
 98: 			it("traces send", async () => {
 99: 				const spyOnTrace = jest.spyOn(connectionLogger, "trace");
100: 				await connection.connect();
101: 				await connection.send({
102: 					event: "openUrl",
103: 					payload: {
104: 						url: "https://www.elgato.com",
105: 					},
106: 				});
107: 				expect(spyOnTrace).toHaveBeenCalledTimes(1);
108: 				expect(spyOnTrace).toHaveBeenCalledWith(
109: 					JSON.stringify({
110: 						event: "openUrl",
111: 						payload: {
112: 							url: "https://www.elgato.com",
113: 						},
114: 					} satisfies OpenUrl),
115: 				);
116: 			});
117: 			it("traces emit", async () => {
118: 				const spyOnTrace = jest.spyOn(connectionLogger, "trace");
119: 				await connection.connect();
120: 				server.send({
121: 					event: "applicationDidLaunch",
122: 					payload: {
123: 						application: "elgato",
124: 					},
125: 				} satisfies ApplicationDidLaunch);
126: 				expect(spyOnTrace).toHaveBeenCalledTimes(1);
127: 				expect(spyOnTrace).toHaveBeenCalledWith(
128: 					JSON.stringify({
129: 						event: "applicationDidLaunch",
130: 						payload: {
131: 							application: "elgato",
132: 						},
133: 					} satisfies ApplicationDidLaunch),
134: 				);
135: 			});
136: 			it("warns for unknown message", async () => {
137: 				const spyOnWarn = jest.spyOn(connectionLogger, "warn");
138: 				await connection.connect();
139: 				server.send({ foo: "bar" });
140: 				expect(spyOnWarn).toHaveBeenCalledTimes(1);
141: 				expect(spyOnWarn).toHaveBeenCalledWith(`Received unknown message: ${JSON.stringify({ foo: "bar" })}`);
142: 			});
143: 			it("errors invalid JSON", async () => {
144: 				const origSerializer = server.serializer;
145: 				server.serializer = () => "{ invalid }";
146: 				const spyOnError = jest.spyOn(connectionLogger, "error");
147: 				await connection.connect();
148: 				server.send("{ invalid }");
149: 				expect(spyOnError).toHaveBeenCalledTimes(1);
150: 				expect(spyOnError).toHaveBeenCalledWith(`Failed to parse message: { invalid }`, expect.any(Error));
151: 				server.serializer = origSerializer;
152: 			});
153: 		});
154: 	});
155: 	describe("registration parameters", () => {
156: 		it("parses valid arguments", () => {
157: 			process.argv = [...port, ...pluginUUID, ...registerEvent, ...info];
158: 			const parameters = connection.registrationParameters;
159: 			expect(parameters.port).toBe("12345");
160: 			expect(parameters.pluginUUID).toBe("abc123");
161: 			expect(parameters.registerEvent).toBe("test_event");
162: 			expect(parameters.info).not.toBeUndefined();
163: 			expect(parameters.info.plugin.uuid).toBe("com.elgato.test");
164: 			expect(parameters.info.plugin.version).toBe("0.1.0");
165: 		});
166: 		it("ignores unknown arguments", () => {
167: 			process.argv = [...port, "-other", "Hello world", ...pluginUUID, ...registerEvent, ...info];
168: 			const parameters = connection.registrationParameters;
169: 			expect(parameters.port).toBe("12345");
170: 			expect(parameters.pluginUUID).toBe("abc123");
171: 			expect(parameters.registerEvent).toBe("test_event");
172: 			expect(parameters.info).not.toBeUndefined();
173: 			expect(parameters.info.plugin.uuid).toBe("com.elgato.test");
174: 			expect(parameters.info.plugin.version).toBe("0.1.0");
175: 		});
176: 		it("handles uneven arguments", () => {
177: 			process.argv = [...port, ...pluginUUID, "-bool", ...registerEvent, ...info];
178: 			const parameters = connection.registrationParameters;
179: 			expect(parameters.port).toBe("12345");
180: 			expect(parameters.pluginUUID).toBe("abc123");
181: 			expect(parameters.registerEvent).toBe("test_event");
182: 			expect(parameters.info).not.toBeUndefined();
183: 			expect(parameters.info.plugin.uuid).toBe("com.elgato.test");
184: 			expect(parameters.info.plugin.version).toBe("0.1.0");
185: 		});
186: 		it("logs arguments", () => {
187: 			const scopedLogger = new Logger({
188: 				level: LogLevel.TRACE,
189: 				targets: [{ write: jest.fn() }],
190: 			});
191: 			jest.spyOn(logger, "createScope").mockReturnValueOnce(scopedLogger);
192: 			const spyOnLoggerDebug = jest.spyOn(scopedLogger, "debug");
193: 			connection.registrationParameters;
194: 			expect(spyOnLoggerDebug).toHaveBeenCalledTimes(4);
195: 			expect(spyOnLoggerDebug).toBeCalledWith(`port=${[port[1]]}`);
196: 			expect(spyOnLoggerDebug).toBeCalledWith(`pluginUUID=${[pluginUUID[1]]}`);
197: 			expect(spyOnLoggerDebug).toBeCalledWith(`registerEvent=${[registerEvent[1]]}`);
198: 			expect(spyOnLoggerDebug).toBeCalledWith(`info=${info[1]}`);
199: 		});
200: 		it("creates a scoped logger", () => {
201: 			const spyOnCreateScope = jest.spyOn(logger, "createScope");
202: 			connection.registrationParameters;
203: 			expect(spyOnCreateScope).toBeCalledWith("RegistrationParameters");
204: 		});
205: 		it("includes all missing arguments", () => {
206: 			process.argv = [];
207: 			expect(() => connection.registrationParameters).toThrow(
208: 				"Unable to establish a connection with Stream Deck, missing command line arguments: -port, -pluginUUID, -registerEvent, -info",
209: 			);
210: 		});
211: 		it("requires port", () => {
212: 			process.argv = [...pluginUUID, ...registerEvent, ...info];
213: 			expect(() => connection.registrationParameters).toThrow(
214: 				"Unable to establish a connection with Stream Deck, missing command line arguments: -port",
215: 			);
216: 		});
217: 		it("requires pluginUUID", () => {
218: 			process.argv = [...port, ...registerEvent, ...info];
219: 			expect(() => connection.registrationParameters).toThrow(
220: 				"Unable to establish a connection with Stream Deck, missing command line arguments: -pluginUUID",
221: 			);
222: 		});
223: 		it("requires registerEvent", () => {
224: 			process.argv = [...port, ...pluginUUID, ...info];
225: 			expect(() => connection.registrationParameters).toThrow(
226: 				"Unable to establish a connection with Stream Deck, missing command line arguments: -registerEvent",
227: 			);
228: 		});
229: 		it("requires info", () => {
230: 			process.argv = [...port, ...pluginUUID, ...registerEvent];
231: 			expect(() => connection.registrationParameters).toThrow(
232: 				"Unable to establish a connection with Stream Deck, missing command line arguments: -info",
233: 			);
234: 		});
235: 	});
236: 	it("parses version from registration info", () => {
237: 		process.argv = [...port, ...pluginUUID, ...registerEvent, "-info", JSON.stringify(registrationInfo)];
238: 		expect(connection.version).not.toBeUndefined();
239: 		expect(connection.version.major).toBe(99);
240: 		expect(connection.version.minor).toBe(8);
241: 		expect(connection.version.patch).toBe(6);
242: 		expect(connection.version.build).toBe(54321);
243: 	});
244: });
</file>

<file path="src/plugin/__tests__/i18n.test.ts">
 1: import fs from "node:fs";
 2: import path from "node:path";
 3: import { fileSystemLocaleProvider } from "../i18n";
 4: import { logger } from "../logging";
 5: jest.mock("../logging");
 6: describe("fileSystemLocaleProvider", () => {
 7: 	const mockedCwd = "c:\\temp";
 8: 	beforeEach(() => jest.spyOn(process, "cwd").mockReturnValue(mockedCwd));
 9: 	afterEach(() => jest.resetAllMocks());
10: 	it("reads from the language JSON file", () => {
11: 		jest.spyOn(fs, "existsSync").mockReturnValue(true);
12: 		const spyOnReadFileSync = jest.spyOn(fs, "readFileSync").mockReturnValue(
13: 			JSON.stringify({
14: 				Localization: {
15: 					Hello: "Hallo Welt",
16: 				},
17: 			}),
18: 		);
19: 		const translations = fileSystemLocaleProvider("de");
20: 		expect(translations).toEqual({ Hello: "Hallo Welt" });
21: 		expect(spyOnReadFileSync).toHaveBeenCalledTimes(1);
22: 		expect(spyOnReadFileSync).toHaveBeenCalledWith(path.join(mockedCwd, "de.json"), { flag: "r" });
23: 	});
24: 	it("returns null when the file is not found", () => {
25: 		jest.spyOn(fs, "existsSync").mockReturnValue(false);
26: 		const spyOnReadFileSync = jest.spyOn(fs, "readFileSync");
27: 		const translations = fileSystemLocaleProvider("en");
28: 		expect(translations).toBeNull();
29: 		expect(spyOnReadFileSync).toHaveBeenCalledTimes(0);
30: 	});
31: 	it("logs an error when the contents are not JSON", () => {
32: 		jest.spyOn(fs, "existsSync").mockReturnValue(true);
33: 		const spyOnReadFileSync = jest.spyOn(fs, "readFileSync").mockReturnValue(`{"value":invalid}`);
34: 		const spyOnLogError = jest.spyOn(logger, "error");
35: 		const translations = fileSystemLocaleProvider("es");
36: 		expect(translations).toBeNull();
37: 		expect(spyOnReadFileSync).toHaveBeenCalledTimes(1);
38: 		expect(spyOnLogError).toHaveBeenCalledTimes(1);
39: 		expect(spyOnLogError).toHaveBeenCalledWith(
40: 			`Failed to load translations from ${path.join(mockedCwd, "es.json")}`,
41: 			expect.any(SyntaxError),
42: 		);
43: 	});
44: 	it("logs an error when the structure is incorrect", () => {
45: 		jest.spyOn(fs, "existsSync").mockReturnValue(true);
46: 		const spyOnReadFileSync = jest.spyOn(fs, "readFileSync").mockReturnValue(`{"NotLocalization":"Incorrect format"}`);
47: 		const spyOnLogError = jest.spyOn(logger, "error");
48: 		const translations = fileSystemLocaleProvider("ja");
49: 		expect(translations).toBeNull();
50: 		expect(spyOnReadFileSync).toHaveBeenCalledTimes(1);
51: 		expect(spyOnLogError).toHaveBeenCalledTimes(1);
52: 		expect(spyOnLogError).toHaveBeenCalledWith(
53: 			`Failed to load translations from ${path.join(mockedCwd, "ja.json")}`,
54: 			expect.any(TypeError),
55: 		);
56: 	});
57: });
</file>

<file path="src/plugin/__tests__/index.test.ts">
 1: import { BarSubType, DeviceType, Target } from "../../api";
 2: import { EventEmitter } from "../../common/event-emitter";
 3: import { I18nProvider } from "../../common/i18n";
 4: import { LogLevel } from "../../common/logging";
 5: import { SingletonAction } from "../actions/singleton-action";
 6: import { connection } from "../connection";
 7: import streamDeckAsDefaultExport, { streamDeck } from "../index";
 8: import { logger } from "../logging";
 9: import { route } from "../ui/route";
10: jest.mock("../../common/i18n");
11: jest.mock("../logging");
12: jest.mock("../manifest");
13: jest.mock("../connection");
14: describe("index", () => {
15: 	it("default is streamDeck const", async () => {
16: 		expect(streamDeck).toBe(streamDeckAsDefaultExport);
17: 	});
18: 	it("exports namespaces", async () => {
19: 		const { actionService } = await require("../actions/service");
20: 		const { deviceService } = await require("../devices/service");
21: 		const { getManifest } = await require("../manifest");
22: 		const profiles = await require("../profiles");
23: 		const settings = await require("../settings");
24: 		const system = await require("../system");
25: 		const { ui } = await require("../ui");
26: 		expect(streamDeck.actions).toBe(actionService);
27: 		expect(streamDeck.devices).toBe(deviceService);
28: 		expect(streamDeck.manifest).toBe(getManifest());
29: 		expect(streamDeck.profiles).toBe(profiles);
30: 		expect(streamDeck.settings).toBe(settings);
31: 		expect(streamDeck.system).toBe(system);
32: 		expect(streamDeck.ui).toBe(ui);
33: 	});
34: 	it("connects", async () => {
35: 		const spyOnConnect = jest.spyOn(connection, "connect");
36: 		await streamDeck.connect();
37: 		expect(spyOnConnect).toHaveBeenCalledTimes(1);
38: 	});
39: 	it("has logger", () => {
40: 		expect(streamDeck.logger).toEqual(logger);
41: 	});
42: 	it("exports enums, classes, and functions", async () => {
43: 		const index = (await require("../index")) as typeof import("../index");
44: 		expect(index.BarSubType).toBe(BarSubType);
45: 		expect(index.DeviceType).toBe(DeviceType);
46: 		expect(index.EventEmitter).toBe(EventEmitter);
47: 		expect(index.LogLevel).toBe(LogLevel);
48: 		expect(index.SingletonAction).toBe(SingletonAction);
49: 		expect(index.Target).toBe(Target);
50: 		expect(index.route).toBe(route);
51: 	});
52: 	it("lazily loads i18n provider", async () => {
53: 		expect(I18nProvider).toBeCalledTimes(0);
54: 		streamDeck.i18n;
55: 		expect(I18nProvider).toHaveBeenCalledTimes(1);
56: 	});
57: });
</file>

<file path="src/plugin/__tests__/manifest.test.ts">
 1: import fs from "node:fs";
 2: import path from "node:path";
 3: import type { Manifest } from "../../api";
 4: import { manifest as mockManifest } from "../__mocks__/manifest";
 5: describe("manifest", () => {
 6: 	let getManifest: typeof import("../manifest").getManifest;
 7: 	let getSoftwareMinimumVersion: typeof import("../manifest").getSoftwareMinimumVersion;
 8: 	beforeEach(async () => ({ getManifest, getSoftwareMinimumVersion } = await require("../manifest")));
 9: 	afterEach(() => jest.resetModules());
10: 	describe("getManifest", () => {
11: 		it("Errors when file does not exist", () => {
12: 			const existsSync = jest.spyOn(fs, "existsSync").mockReturnValueOnce(false);
13: 			jest.spyOn(process, "cwd").mockReturnValueOnce("test");
14: 			expect(getManifest).toThrowError("Failed to read manifest.json as the file does not exist.");
15: 			expect(existsSync).toHaveBeenCalled();
16: 			expect(existsSync).toHaveBeenCalledWith(path.join("test", "manifest.json"));
17: 		});
18: 		it("Parses the manifest file", () => {
19: 			jest.spyOn(fs, "existsSync").mockReturnValue(true);
20: 			jest.spyOn(fs, "readFileSync").mockReturnValueOnce(JSON.stringify(mockManifest));
21: 			const manifest = getManifest();
22: 			expect(manifest).toEqual(mockManifest);
23: 		});
24: 		it("Errors when the manifest cannot be parsed", () => {
25: 			jest.spyOn(fs, "existsSync").mockReturnValueOnce(true);
26: 			jest.spyOn(fs, "readFileSync").mockReturnValueOnce("_");
27: 			expect(getManifest).toThrowError("Unexpected token '_', \"_\" is not valid JSON");
28: 		});
29: 		it("Caches the result", () => {
30: 			jest.spyOn(fs, "existsSync").mockReturnValue(true);
31: 			const readSpy = jest.spyOn(fs, "readFileSync").mockReturnValueOnce(JSON.stringify(mockManifest));
32: 			const manifestOne = getManifest();
33: 			const manifestTwo = getManifest();
34: 			expect(manifestOne).toEqual(manifestTwo);
35: 			expect(readSpy).toHaveBeenCalledTimes(1);
36: 		});
37: 	});
38: 	describe("getSoftwareMinimumVersion", () => {
39: 		it("Reads the minimum version from the manifest", () => {
40: 			jest.spyOn(fs, "existsSync").mockReturnValue(true);
41: 			const readSpy = jest.spyOn(fs, "readFileSync").mockReturnValueOnce(
42: 				JSON.stringify({
43: 					Software: {
44: 						MinimumVersion: "6.5",
45: 					},
46: 				} satisfies Pick<Manifest, "Software">),
47: 			);
48: 			const version = getSoftwareMinimumVersion();
49: 			expect(version.major).toEqual(6);
50: 			expect(version.minor).toEqual(5);
51: 			expect(readSpy).toBeCalledTimes(1);
52: 		});
53: 		it("Caches the result", () => {
54: 			jest.spyOn(fs, "existsSync").mockReturnValue(true);
55: 			const readSpy = jest.spyOn(fs, "readFileSync").mockReturnValueOnce(JSON.stringify(mockManifest));
56: 			const versionOne = getSoftwareMinimumVersion();
57: 			const versionTwo = getSoftwareMinimumVersion();
58: 			expect(versionOne).toEqual(versionTwo);
59: 			expect(readSpy).toHaveBeenCalledTimes(1);
60: 		});
61: 	});
62: });
</file>

<file path="src/plugin/__tests__/profiles.test.ts">
 1: import type { SwitchToProfile } from "../../api";
 2: import { Version } from "../common/version";
 3: import { connection } from "../connection";
 4: import { switchToProfile } from "../profiles";
 5: jest.mock("../connection");
 6: jest.mock("../logging");
 7: jest.mock("../manifest");
 8: describe("profiles", () => {
 9: 	describe("switchToProfile", () => {
10: 		it("sends", async () => {
11: 			await switchToProfile("DEV1");
12: 			await switchToProfile("DEV2", "Custom Profile (1)");
13: 			await switchToProfile("DEV3", "Custom Profile (2)", 2);
14: 			expect(connection.send).toHaveBeenCalledTimes(3);
15: 			expect(connection.send).toHaveBeenNthCalledWith<[SwitchToProfile]>(1, {
16: 				event: "switchToProfile",
17: 				context: connection.registrationParameters.pluginUUID,
18: 				device: "DEV1",
19: 				payload: {
20: 					profile: undefined,
21: 					page: undefined,
22: 				},
23: 			});
24: 			expect(connection.send).toHaveBeenNthCalledWith<[SwitchToProfile]>(2, {
25: 				event: "switchToProfile",
26: 				context: connection.registrationParameters.pluginUUID,
27: 				device: "DEV2",
28: 				payload: {
29: 					profile: "Custom Profile (1)",
30: 					page: undefined,
31: 				},
32: 			});
33: 			expect(connection.send).toHaveBeenNthCalledWith<[SwitchToProfile]>(3, {
34: 				event: "switchToProfile",
35: 				context: connection.registrationParameters.pluginUUID,
36: 				device: "DEV3",
37: 				payload: {
38: 					profile: "Custom Profile (2)",
39: 					page: 2,
40: 				},
41: 			});
42: 		});
43: 		it("validates page parameter requires 6.5 (connection)", () => {
44: 			jest.spyOn(connection, "version", "get").mockReturnValueOnce(new Version("6.4"));
45: 			expect(() => switchToProfile("DEV1", "Profile", 1)).toThrow(
46: 				`[ERR_NOT_SUPPORTED]: Switching to a profile page requires Stream Deck version 6.5 or higher, but current version is 6.4; please update Stream Deck and the "Software.MinimumVersion" in the plugin's manifest to "6.5" or higher.`,
47: 			);
48: 		});
49: 	});
50: });
</file>

<file path="src/plugin/__tests__/settings.test.ts">
  1: import {
  2: 	type DidReceiveGlobalSettings,
  3: 	type DidReceiveSettings,
  4: 	type GetGlobalSettings,
  5: 	type SetGlobalSettings,
  6: } from "../../api";
  7: import { type Settings } from "../../api/__mocks__/events";
  8: import { actionStore } from "../actions/store";
  9: import { connection } from "../connection";
 10: import type { DidReceiveGlobalSettingsEvent, DidReceiveSettingsEvent } from "../events";
 11: import { getGlobalSettings, onDidReceiveGlobalSettings, onDidReceiveSettings, setGlobalSettings } from "../settings";
 12: jest.mock("../connection");
 13: jest.mock("../logging");
 14: jest.mock("../manifest");
 15: jest.mock("../actions/store");
 16: describe("settings", () => {
 17: 	describe("sending", () => {
 18: 		it("getGlobalSettings", async () => {
 19: 			const settings = getGlobalSettings<Settings>();
 20: 			expect(connection.send).toHaveBeenCalledTimes(1);
 21: 			expect(connection.send).toHaveBeenLastCalledWith({
 22: 				event: "getGlobalSettings",
 23: 				context: connection.registrationParameters.pluginUUID,
 24: 			} as GetGlobalSettings);
 25: 			expect(Promise.race([settings, false])).resolves.toBe(false);
 26: 			connection.emit("didReceiveGlobalSettings", {
 27: 				event: "didReceiveGlobalSettings",
 28: 				payload: {
 29: 					settings: {
 30: 						name: "Elgato",
 31: 					},
 32: 				},
 33: 			});
 34: 			await settings;
 35: 			expect(settings).resolves.toEqual<Settings>({
 36: 				name: "Elgato",
 37: 			});
 38: 		});
 39: 		it("setGlobalSettings", async () => {
 40: 			await setGlobalSettings({
 41: 				name: "Elgato",
 42: 			});
 43: 			expect(connection.send).toHaveBeenCalledTimes(1);
 44: 			expect(connection.send).toHaveBeenCalledWith<[SetGlobalSettings]>({
 45: 				event: "setGlobalSettings",
 46: 				context: connection.registrationParameters.pluginUUID,
 47: 				payload: {
 48: 					name: "Elgato",
 49: 				},
 50: 			});
 51: 		});
 52: 	});
 53: 	describe("receiving", () => {
 54: 		it("onDidReceiveGlobalSettings", () => {
 55: 			const listener = jest.fn();
 56: 			const ev = {
 57: 				event: "didReceiveGlobalSettings",
 58: 				payload: {
 59: 					settings: {
 60: 						name: "Elgato",
 61: 					},
 62: 				},
 63: 			} satisfies DidReceiveGlobalSettings<Settings>;
 64: 			const disposable = onDidReceiveGlobalSettings(listener);
 65: 			connection.emit("didReceiveGlobalSettings", ev);
 66: 			expect(listener).toHaveBeenCalledTimes(1);
 67: 			expect(listener).toHaveBeenCalledWith<[DidReceiveGlobalSettingsEvent<Settings>]>({
 68: 				settings: {
 69: 					name: "Elgato",
 70: 				},
 71: 				type: "didReceiveGlobalSettings",
 72: 			});
 73: 			disposable.dispose();
 74: 			connection.emit(ev.event, ev as any);
 75: 			expect(listener).toHaveBeenCalledTimes(1);
 76: 		});
 77: 		it("onDidReceiveSettings", () => {
 78: 			const listener = jest.fn();
 79: 			const ev = {
 80: 				action: "com.elgato.test.one",
 81: 				context: "key123",
 82: 				device: "device123",
 83: 				event: "didReceiveSettings",
 84: 				payload: {
 85: 					controller: "Keypad",
 86: 					coordinates: {
 87: 						column: 0,
 88: 						row: 0,
 89: 					},
 90: 					isInMultiAction: false,
 91: 					settings: {
 92: 						name: "Elgato",
 93: 					},
 94: 				},
 95: 			} satisfies DidReceiveSettings<Settings>;
 96: 			const disposable = onDidReceiveSettings(listener);
 97: 			connection.emit("didReceiveSettings", ev);
 98: 			expect(listener).toHaveBeenCalledTimes(1);
 99: 			expect(listener).toHaveBeenCalledWith<[DidReceiveSettingsEvent<Settings>]>({
100: 				action: actionStore.getActionById(ev.context)!,
101: 				payload: ev.payload,
102: 				type: "didReceiveSettings",
103: 			});
104: 			disposable.dispose();
105: 			connection.emit(ev.event, ev as any);
106: 			expect(listener).toHaveBeenCalledTimes(1);
107: 		});
108: 	});
109: });
</file>

<file path="src/plugin/__tests__/system.test.ts">
  1: import type {
  2: 	ApplicationDidLaunch,
  3: 	ApplicationDidTerminate,
  4: 	DidReceiveDeepLink,
  5: 	OpenUrl,
  6: 	SystemDidWakeUp,
  7: } from "../../api";
  8: import { Version } from "../common/version";
  9: import { connection } from "../connection";
 10: import {
 11: 	ApplicationDidLaunchEvent,
 12: 	ApplicationDidTerminateEvent,
 13: 	DidReceiveDeepLinkEvent,
 14: 	SystemDidWakeUpEvent,
 15: } from "../events";
 16: import {
 17: 	onApplicationDidLaunch,
 18: 	onApplicationDidTerminate,
 19: 	onDidReceiveDeepLink,
 20: 	onSystemDidWakeUp,
 21: 	openUrl,
 22: } from "../system";
 23: jest.mock("../connection");
 24: jest.mock("../logging");
 25: jest.mock("../manifest");
 26: describe("system", () => {
 27: 	it("receives onApplicationDidLaunch", () => {
 28: 		const listener = jest.fn();
 29: 		const ev = {
 30: 			event: "applicationDidLaunch",
 31: 			payload: {
 32: 				application: "notepad.exe",
 33: 			},
 34: 		} satisfies ApplicationDidLaunch;
 35: 		const disposable = onApplicationDidLaunch(listener);
 36: 		connection.emit("applicationDidLaunch", ev);
 37: 		expect(listener).toHaveBeenCalledTimes(1);
 38: 		expect(listener).toHaveBeenCalledWith<[ApplicationDidLaunchEvent]>({
 39: 			application: "notepad.exe",
 40: 			type: "applicationDidLaunch",
 41: 		});
 42: 		disposable.dispose();
 43: 		connection.emit(ev.event, ev as any);
 44: 		expect(listener).toHaveBeenCalledTimes(1);
 45: 	});
 46: 	it("receives onApplicationDidTerminate", () => {
 47: 		const listener = jest.fn();
 48: 		const ev = {
 49: 			event: "applicationDidTerminate",
 50: 			payload: {
 51: 				application: "notepad.exe",
 52: 			},
 53: 		} satisfies ApplicationDidTerminate;
 54: 		const disposable = onApplicationDidTerminate(listener);
 55: 		connection.emit("applicationDidTerminate", ev);
 56: 		expect(listener).toHaveBeenCalledTimes(1);
 57: 		expect(listener).toHaveBeenCalledWith<[ApplicationDidTerminateEvent]>({
 58: 			application: "notepad.exe",
 59: 			type: "applicationDidTerminate",
 60: 		});
 61: 		disposable.dispose();
 62: 		connection.emit(ev.event, ev as any);
 63: 		expect(listener).toHaveBeenCalledTimes(1);
 64: 	});
 65: 	describe("onDidReceiveDeepLink", () => {
 66: 		it("propagates", () => {
 67: 			const listener = jest.fn();
 68: 			const ev = {
 69: 				event: "didReceiveDeepLink",
 70: 				payload: {
 71: 					url: "/hello/world?foo=bar#heading",
 72: 				},
 73: 			} satisfies DidReceiveDeepLink;
 74: 			const disposable = onDidReceiveDeepLink(listener);
 75: 			connection.emit("didReceiveDeepLink", ev);
 76: 			expect(listener).toHaveBeenCalledTimes(1);
 77: 			expect(listener).toHaveBeenCalledWith<[DidReceiveDeepLinkEvent]>({
 78: 				url: {
 79: 					fragment: "heading",
 80: 					href: ev.payload.url,
 81: 					path: "/hello/world",
 82: 					query: "foo=bar",
 83: 					queryParameters: new URLSearchParams([["foo", "bar"]]),
 84: 				},
 85: 				type: "didReceiveDeepLink",
 86: 			});
 87: 			disposable.dispose();
 88: 			connection.emit(ev.event, ev as any);
 89: 			expect(listener).toHaveBeenCalledTimes(1);
 90: 		});
 91: 		it("validates requires 6.5 (connection)", () => {
 92: 			jest.spyOn(connection, "version", "get").mockReturnValueOnce(new Version("6.4"));
 93: 			expect(() => onDidReceiveDeepLink(jest.fn())).toThrow(
 94: 				`[ERR_NOT_SUPPORTED]: Receiving deep-link messages requires Stream Deck version 6.5 or higher, but current version is 6.4; please update Stream Deck and the "Software.MinimumVersion" in the plugin's manifest to "6.5" or higher.`,
 95: 			);
 96: 		});
 97: 	});
 98: 	it("Receives onSystemDidWakeUp", () => {
 99: 		const listener = jest.fn();
100: 		const ev = {
101: 			event: "systemDidWakeUp",
102: 		} satisfies SystemDidWakeUp;
103: 		const disposable = onSystemDidWakeUp(listener);
104: 		connection.emit("systemDidWakeUp", ev);
105: 		expect(listener).toHaveBeenCalledTimes(1);
106: 		expect(listener).toHaveBeenCalledWith<[SystemDidWakeUpEvent]>({
107: 			type: "systemDidWakeUp",
108: 		});
109: 		disposable.dispose();
110: 		connection.emit(ev.event, ev as any);
111: 		expect(listener).toHaveBeenCalledTimes(1);
112: 	});
113: 	it("sends", async () => {
114: 		await openUrl("https://www.elgato.com");
115: 		expect(connection.send).toHaveBeenCalledTimes(1);
116: 		expect(connection.send).toHaveBeenCalledWith<[OpenUrl]>({
117: 			event: "openUrl",
118: 			payload: {
119: 				url: "https://www.elgato.com",
120: 			},
121: 		});
122: 	});
123: });
</file>

<file path="src/plugin/__tests__/validation.test.ts">
 1: import { Version } from "../common/version";
 2: import * as ManifestModule from "../manifest";
 3: import { requiresVersion } from "../validation";
 4: jest.mock("../manifest");
 5: describe("requiresVersion", () => {
 6: 	describe("validates application version", () => {
 7: 		beforeEach(() => jest.spyOn(ManifestModule, "getSoftwareMinimumVersion").mockReturnValue(new Version("6.5")));
 8: 		it("handles same versions", () => {
 9: 			const appVersion = new Version("6.5.0.123");
10: 			expect(() => requiresVersion(6.5, appVersion, "Test")).not.toThrow();
11: 		});
12: 		it("handles newer versions", () => {
13: 			const appVersion = new Version("99.0.0.0");
14: 			expect(() => requiresVersion(6.5, appVersion, "Test")).not.toThrow();
15: 		});
16: 		it("throws older version", () => {
17: 			const appVersion = new Version("1.0.0.0");
18: 			expect(() => requiresVersion(99, appVersion, "Test")).toThrow(
19: 				`[ERR_NOT_SUPPORTED]: Test requires Stream Deck version 99.0 or higher, but current version is 1.0; please update Stream Deck and the "Software.MinimumVersion" in the plugin's manifest to "99.0" or higher.`,
20: 			);
21: 		});
22: 	});
23: 	describe("validates Software.MinimumVersion defined within the manifest", () => {
24: 		const appVersion = new Version("99.0");
25: 		it("handles same versions", () => {
26: 			jest.spyOn(ManifestModule, "getSoftwareMinimumVersion").mockReturnValue(new Version("6.5"));
27: 			expect(() => requiresVersion(6.5, appVersion, "Test")).not.toThrow();
28: 		});
29: 		it("handles newer versions", () => {
30: 			jest.spyOn(ManifestModule, "getSoftwareMinimumVersion").mockReturnValue(new Version("99.0"));
31: 			expect(() => requiresVersion(6.5, appVersion, "Test")).not.toThrow();
32: 		});
33: 		it("throws older version", () => {
34: 			jest.spyOn(ManifestModule, "getSoftwareMinimumVersion").mockReturnValue(new Version("1.0"));
35: 			expect(() => requiresVersion(99, appVersion, "Test")).toThrow(
36: 				`[ERR_NOT_SUPPORTED]: Test requires Stream Deck version 99.0 or higher; please update the "Software.MinimumVersion" in the plugin's manifest to "99.0" or higher.`,
37: 			);
38: 		});
39: 	});
40: });
</file>

<file path="src/plugin/actions/__mocks__/store.ts">
 1: import { DeviceType } from "../../../api/device";
 2: import type { Device } from "../../devices";
 3: import { deviceStore } from "../../devices/store";
 4: const { ReadOnlyActionStore } = jest.requireActual("../store");
 5: const { KeyAction } = jest.requireActual("../key");
 6: const { DialAction } = jest.requireActual("../dial");
 7: jest.mock("../../devices/store");
 8: jest.spyOn(deviceStore, "getDeviceById").mockReturnValue({
 9: 	id: "device123",
10: 	isConnected: true,
11: 	name: "Device 1",
12: 	size: {
13: 		columns: 5,
14: 		rows: 3,
15: 	},
16: 	type: DeviceType.StreamDeck,
17: } as unknown as Device);
18: export const actionStore = {
19: 	set: jest.fn(),
20: 	delete: jest.fn(),
21: 	getActionById: jest.fn().mockImplementation((id: string) => {
22: 		if (id === "dial123") {
23: 			return new DialAction({
24: 				action: "com.elgato.test.dial",
25: 				context: id,
26: 				device: "device123",
27: 				event: "willAppear",
28: 				payload: {
29: 					controller: "Encoder",
30: 					coordinates: {
31: 						column: 1,
32: 						row: 2,
33: 					},
34: 					isInMultiAction: false,
35: 					settings: {},
36: 				},
37: 			});
38: 		}
39: 		return new KeyAction({
40: 			action: "com.elgato.test.key",
41: 			context: id,
42: 			device: "device123",
43: 			event: "willAppear",
44: 			payload: {
45: 				controller: "Keypad",
46: 				coordinates: {
47: 					column: 1,
48: 					row: 2,
49: 				},
50: 				isInMultiAction: false,
51: 				settings: {},
52: 			},
53: 		});
54: 	}),
55: };
56: export { ReadOnlyActionStore };
</file>

<file path="src/plugin/actions/__tests__/action.test.ts">
  1: import { DeviceType, type GetSettings, type SetSettings, type ShowAlert, type WillAppear } from "../../../api";
  2: import { Settings } from "../../../api/__mocks__/events";
  3: import { type JsonObject } from "../../../common/json";
  4: import { connection } from "../../connection";
  5: import { Device } from "../../devices/device";
  6: import { deviceStore } from "../../devices/store";
  7: import { Action } from "../action";
  8: import { DialAction } from "../dial";
  9: jest.mock("../../devices/store");
 10: jest.mock("../../logging");
 11: jest.mock("../../manifest");
 12: jest.mock("../../connection");
 13: describe("Action", () => {
 14: 	const source: WillAppear<JsonObject> = {
 15: 		action: "com.test.action.one",
 16: 		context: "action123",
 17: 		device: "device123",
 18: 		event: "willAppear",
 19: 		payload: {
 20: 			controller: "Keypad",
 21: 			coordinates: {
 22: 				column: 1,
 23: 				row: 2,
 24: 			},
 25: 			isInMultiAction: false,
 26: 			settings: {},
 27: 		},
 28: 	};
 29: 	const device = new Device(
 30: 		"device123",
 31: 		{
 32: 			name: "Device 1",
 33: 			size: {
 34: 				columns: 5,
 35: 				rows: 3,
 36: 			},
 37: 			type: DeviceType.StreamDeck,
 38: 		},
 39: 		true,
 40: 	);
 41: 	beforeAll(() => jest.spyOn(deviceStore, "getDeviceById").mockReturnValue(device));
 42: 	it("constructor sets properties from source", () => {
 43: 		const action = new Action(source);
 44: 		expect(action).toBeInstanceOf(Action);
 45: 		expect(action.controllerType).toBe("Keypad");
 46: 		expect(action.device).toBe(device);
 47: 		expect(action.id).toBe(source.context);
 48: 		expect(action.manifestId).toBe(source.action);
 49: 		expect(deviceStore.getDeviceById).toHaveBeenCalledTimes(1);
 50: 		expect(deviceStore.getDeviceById).toHaveBeenLastCalledWith(source.device);
 51: 	});
 52: 	it("getSettings", async () => {
 53: 		const action = new Action(source);
 54: 		const settings = action.getSettings();
 55: 		expect(connection.send).toHaveBeenCalledTimes(1);
 56: 		expect(connection.send).toHaveBeenLastCalledWith<[GetSettings]>({
 57: 			event: "getSettings",
 58: 			context: action.id,
 59: 		});
 60: 		expect(Promise.race([settings, false])).resolves.toBe(false);
 61: 		connection.emit("didReceiveSettings", {
 62: 			action: "com.other.test.one",
 63: 			context: "__other__",
 64: 			event: "didReceiveSettings",
 65: 			device: "device123",
 66: 			payload: {
 67: 				controller: "Keypad",
 68: 				coordinates: {
 69: 					column: 0,
 70: 					row: 0,
 71: 				},
 72: 				isInMultiAction: false,
 73: 				settings: {
 74: 					name: "Other",
 75: 				},
 76: 			},
 77: 		});
 78: 		connection.emit("didReceiveSettings", {
 79: 			action: action.manifestId,
 80: 			context: action.id,
 81: 			event: "didReceiveSettings",
 82: 			device: "device123",
 83: 			payload: {
 84: 				controller: "Keypad",
 85: 				coordinates: {
 86: 					column: 1,
 87: 					row: 3,
 88: 				},
 89: 				isInMultiAction: false,
 90: 				settings: {
 91: 					name: "Elgato",
 92: 				},
 93: 			},
 94: 		});
 95: 		await settings;
 96: 		expect(await settings).toEqual<Settings>({
 97: 			name: "Elgato",
 98: 		});
 99: 	});
100: 	test("keypad type assertion", () => {
101: 		const action = new Action({
102: 			...source,
103: 			payload: {
104: 				...source.payload,
105: 				controller: "Keypad",
106: 			},
107: 		});
108: 		expect(action.isKey()).toBe(true);
109: 		expect(action.isDial()).toBe(false);
110: 	});
111: 	test("encoder type assertion", () => {
112: 		const action = new DialAction({
113: 			...source,
114: 			payload: {
115: 				...source.payload,
116: 				controller: "Encoder",
117: 			},
118: 		} as WillAppear<JsonObject>);
119: 		expect(action.isDial()).toBe(true);
120: 		expect(action.isKey()).toBe(false);
121: 	});
122: 	describe("sending", () => {
123: 		let action!: Action;
124: 		beforeAll(() => (action = new Action(source)));
125: 		it("setSettings", async () => {
126: 			await action.setSettings({
127: 				name: "Elgato",
128: 			});
129: 			expect(connection.send).toHaveBeenCalledTimes(1);
130: 			expect(connection.send).toHaveBeenCalledWith<[SetSettings]>({
131: 				context: action.id,
132: 				event: "setSettings",
133: 				payload: {
134: 					name: "Elgato",
135: 				},
136: 			});
137: 		});
138: 		it("showAlert", async () => {
139: 			await action.showAlert();
140: 			expect(connection.send).toHaveBeenCalledTimes(1);
141: 			expect(connection.send).toHaveBeenCalledWith<[ShowAlert]>({
142: 				context: action.id,
143: 				event: "showAlert",
144: 			});
145: 		});
146: 	});
147: });
</file>

<file path="src/plugin/actions/__tests__/decorators.test.ts">
 1: import { action } from "../decorators";
 2: import { SingletonAction } from "../singleton-action";
 3: describe("action decorator", () => {
 4: 	it("sets the manifestId on untyped action", () => {
 5: 		@action({ UUID: "com.elgato.test.sample" })
 6: 		class SampleAction extends SingletonAction {
 7: 			public onWillAppear(): void {
 8: 			}
 9: 		}
10: 		const sample = new SampleAction();
11: 		expect(sample.manifestId).toBe("com.elgato.test.sample");
12: 	});
13: 	it("sets the manifestId on typed action", () => {
14: 		@action({ UUID: "com.elgato.test.sample" })
15: 		class SampleAction extends SingletonAction<Settings> {
16: 			public onWillAppear(): void {
17: 			}
18: 		}
19: 		const sample = new SampleAction();
20: 		expect(sample.manifestId).toBe("com.elgato.test.sample");
21: 	});
22: });
23: type Settings = {
24: 	name: string;
25: };
</file>

<file path="src/plugin/actions/__tests__/dial.test.ts">
  1: import {
  2: 	DeviceType,
  3: 	type SetFeedback,
  4: 	type SetFeedbackLayout,
  5: 	type SetImage,
  6: 	type SetTriggerDescription,
  7: 	type WillAppear,
  8: } from "../../../api";
  9: import type { JsonObject } from "../../../common/json";
 10: import { connection } from "../../connection";
 11: import { Device } from "../../devices/device";
 12: import { deviceStore } from "../../devices/store";
 13: import { Action } from "../action";
 14: import { DialAction } from "../dial";
 15: jest.mock("../../devices/store");
 16: jest.mock("../../logging");
 17: jest.mock("../../manifest");
 18: jest.mock("../../connection");
 19: describe("DialAction", () => {
 20: 	const source: WillAppear<JsonObject> = {
 21: 		action: "com.test.action.one",
 22: 		context: "action123",
 23: 		device: "device123",
 24: 		event: "willAppear",
 25: 		payload: {
 26: 			controller: "Encoder",
 27: 			coordinates: {
 28: 				column: 1,
 29: 				row: 2,
 30: 			},
 31: 			isInMultiAction: false,
 32: 			settings: {},
 33: 		},
 34: 	};
 35: 	const device = new Device(
 36: 		"device123",
 37: 		{
 38: 			name: "Device 1",
 39: 			size: {
 40: 				columns: 5,
 41: 				rows: 3,
 42: 			},
 43: 			type: DeviceType.StreamDeck,
 44: 		},
 45: 		true,
 46: 	);
 47: 	beforeAll(() => jest.spyOn(deviceStore, "getDeviceById").mockReturnValue(device));
 48: 	it("constructor sets properties from source", () => {
 49: 		const action = new DialAction(source);
 50: 		expect(action).toBeInstanceOf(Action);
 51: 		expect(action.coordinates).not.toBeUndefined();
 52: 		expect(action.coordinates?.column).toBe(1);
 53: 		expect(action.coordinates?.row).toBe(2);
 54: 		expect(action.device).toBe(device);
 55: 		expect(action.id).toBe(source.context);
 56: 		expect(action.manifestId).toBe(source.action);
 57: 		expect(deviceStore.getDeviceById).toHaveBeenCalledTimes(1);
 58: 		expect(deviceStore.getDeviceById).toHaveBeenLastCalledWith(source.device);
 59: 	});
 60: 	it("throws for non encoder", () => {
 61: 		const keypadSource: WillAppear<JsonObject> = {
 62: 			...source,
 63: 			payload: {
 64: 				...source.payload,
 65: 				controller: "Keypad",
 66: 			},
 67: 		};
 68: 		expect(() => new DialAction(keypadSource)).toThrow();
 69: 	});
 70: 	it("JSON has properties", () => {
 71: 		const action = new DialAction({
 72: 			action: "action1",
 73: 			context: "com.test.action.one",
 74: 			device: "dev1",
 75: 			event: "willAppear",
 76: 			payload: {
 77: 				controller: "Encoder",
 78: 				settings: {},
 79: 				isInMultiAction: false,
 80: 				coordinates: {
 81: 					column: 1,
 82: 					row: 2,
 83: 				},
 84: 			},
 85: 		});
 86: 		const jsonStr = JSON.stringify(action);
 87: 		const jsonObj: DialAction = JSON.parse(jsonStr);
 88: 		expect(jsonObj.controllerType).toBe(action.controllerType);
 89: 		expect(jsonObj.coordinates).toStrictEqual(action.coordinates);
 90: 		expect(jsonObj.device).toStrictEqual({ id: action.device.id });
 91: 		expect(jsonObj.id).toBe(action.id);
 92: 		expect(jsonObj.manifestId).toBe(action.manifestId);
 93: 	});
 94: 	describe("sending", () => {
 95: 		let action!: DialAction;
 96: 		beforeAll(() => (action = new DialAction(source)));
 97: 		it("setFeedback", async () => {
 98: 			await action.setFeedback({
 99: 				bar: 50,
100: 				title: "Hello world",
101: 			});
102: 			expect(connection.send).toHaveBeenCalledTimes(1);
103: 			expect(connection.send).toHaveBeenCalledWith<[SetFeedback]>({
104: 				context: action.id,
105: 				event: "setFeedback",
106: 				payload: {
107: 					bar: 50,
108: 					title: "Hello world",
109: 				},
110: 			});
111: 		});
112: 		it("Sends setFeedbackLayout", async () => {
113: 			await action.setFeedbackLayout("CustomLayout.json");
114: 			expect(connection.send).toHaveBeenCalledTimes(1);
115: 			expect(connection.send).toHaveBeenCalledWith<[SetFeedbackLayout]>({
116: 				context: action.id,
117: 				event: "setFeedbackLayout",
118: 				payload: {
119: 					layout: "CustomLayout.json",
120: 				},
121: 			});
122: 		});
123: 		it("setImage", async () => {
124: 			await action.setImage();
125: 			await action.setImage("./imgs/test.png");
126: 			expect(connection.send).toHaveBeenCalledTimes(2);
127: 			expect(connection.send).toHaveBeenNthCalledWith<[SetImage]>(1, {
128: 				context: action.id,
129: 				event: "setImage",
130: 				payload: {
131: 					image: undefined,
132: 					state: undefined,
133: 					target: undefined,
134: 				},
135: 			});
136: 			expect(connection.send).toHaveBeenNthCalledWith<[SetImage]>(2, {
137: 				context: action.id,
138: 				event: "setImage",
139: 				payload: {
140: 					image: "./imgs/test.png",
141: 				},
142: 			});
143: 		});
144: 		it("setTitle", async () => {
145: 			await action.setTitle("Hello world");
146: 			expect(connection.send).toHaveBeenCalledTimes(1);
147: 			expect(connection.send).toHaveBeenCalledWith<[SetFeedback]>({
148: 				context: action.id,
149: 				event: "setFeedback",
150: 				payload: {
151: 					title: "Hello world",
152: 				},
153: 			});
154: 		});
155: 		it("setTriggerDescription", async () => {
156: 			await action.setTriggerDescription();
157: 			await action.setTriggerDescription({
158: 				longTouch: "Long-touch",
159: 				push: "Push",
160: 				rotate: "Rotate",
161: 				touch: "Touch",
162: 			});
163: 			expect(connection.send).toHaveBeenCalledTimes(2);
164: 			expect(connection.send).toHaveBeenNthCalledWith<[SetTriggerDescription]>(1, {
165: 				event: "setTriggerDescription",
166: 				context: action.id,
167: 				payload: {},
168: 			});
169: 			expect(connection.send).toHaveBeenNthCalledWith<[SetTriggerDescription]>(2, {
170: 				event: "setTriggerDescription",
171: 				context: action.id,
172: 				payload: {
173: 					longTouch: "Long-touch",
174: 					push: "Push",
175: 					rotate: "Rotate",
176: 					touch: "Touch",
177: 				},
178: 			});
179: 		});
180: 	});
181: });
</file>

<file path="src/plugin/actions/__tests__/key.test.ts">
  1: import {
  2: 	DeviceType,
  3: 	type SetImage,
  4: 	type SetState,
  5: 	type SetTitle,
  6: 	type ShowOk,
  7: 	Target,
  8: 	type WillAppear,
  9: } from "../../../api";
 10: import type { JsonObject } from "../../../common/json";
 11: import { connection } from "../../connection";
 12: import { Device } from "../../devices/device";
 13: import { deviceStore } from "../../devices/store";
 14: import { Action } from "../action";
 15: import { KeyAction } from "../key";
 16: jest.mock("../../devices/store");
 17: jest.mock("../../logging");
 18: jest.mock("../../manifest");
 19: jest.mock("../../connection");
 20: describe("KeyAction", () => {
 21: 	const source: WillAppear<JsonObject> = {
 22: 		action: "com.test.action.one",
 23: 		context: "action123",
 24: 		device: "device123",
 25: 		event: "willAppear",
 26: 		payload: {
 27: 			controller: "Keypad",
 28: 			coordinates: {
 29: 				column: 1,
 30: 				row: 2,
 31: 			},
 32: 			isInMultiAction: false,
 33: 			settings: {},
 34: 		},
 35: 	};
 36: 	const device = new Device(
 37: 		"dev1",
 38: 		{
 39: 			name: "Device 1",
 40: 			size: {
 41: 				columns: 5,
 42: 				rows: 3,
 43: 			},
 44: 			type: DeviceType.StreamDeck,
 45: 		},
 46: 		true,
 47: 	);
 48: 	beforeAll(() => jest.spyOn(deviceStore, "getDeviceById").mockReturnValue(device));
 49: 	it("constructor sets context", () => {
 50: 		const action = new KeyAction(source);
 51: 		expect(action).toBeInstanceOf(Action);
 52: 		expect(action.coordinates).not.toBeUndefined();
 53: 		expect(action.coordinates?.column).toBe(1);
 54: 		expect(action.coordinates?.row).toBe(2);
 55: 		expect(action.device).toBe(device);
 56: 		expect(action.id).toBe(source.context);
 57: 		expect(action.manifestId).toBe(source.action);
 58: 		expect(deviceStore.getDeviceById).toHaveBeenCalledTimes(1);
 59: 		expect(deviceStore.getDeviceById).toHaveBeenLastCalledWith(source.device);
 60: 	});
 61: 	it("throws for non keypad", () => {
 62: 		const encoderSource: WillAppear<JsonObject> = {
 63: 			action: "com.test.action.one",
 64: 			context: "action1",
 65: 			device: "dev1",
 66: 			event: "willAppear",
 67: 			payload: {
 68: 				controller: "Encoder",
 69: 				coordinates: {
 70: 					column: 1,
 71: 					row: 2,
 72: 				},
 73: 				isInMultiAction: false,
 74: 				settings: {},
 75: 			},
 76: 		};
 77: 		expect(() => new KeyAction(encoderSource)).toThrow();
 78: 	});
 79: 	it("does not have coordinates when multi-action", () => {
 80: 		const action = new KeyAction({
 81: 			action: "action1",
 82: 			context: "com.test.action.one",
 83: 			device: "dev1",
 84: 			event: "willAppear",
 85: 			payload: {
 86: 				controller: "Keypad",
 87: 				settings: {},
 88: 				isInMultiAction: true,
 89: 			},
 90: 		});
 91: 		expect(action.coordinates).toBeUndefined();
 92: 	});
 93: 	it("JSON has properties", () => {
 94: 		const action = new KeyAction({
 95: 			action: "action1",
 96: 			context: "com.test.action.one",
 97: 			device: "dev1",
 98: 			event: "willAppear",
 99: 			payload: {
100: 				controller: "Keypad",
101: 				settings: {},
102: 				isInMultiAction: false,
103: 				coordinates: {
104: 					column: 1,
105: 					row: 2,
106: 				},
107: 			},
108: 		});
109: 		const jsonStr = JSON.stringify(action);
110: 		const jsonObj: KeyAction = JSON.parse(jsonStr);
111: 		expect(jsonObj.controllerType).toBe(action.controllerType);
112: 		expect(jsonObj.coordinates).toStrictEqual(action.coordinates);
113: 		expect(jsonObj.device).toStrictEqual({ id: action.device.id });
114: 		expect(jsonObj.id).toBe(action.id);
115: 		expect(jsonObj.isInMultiAction).toBe(action.isInMultiAction());
116: 		expect(jsonObj.manifestId).toBe(action.manifestId);
117: 	});
118: 	describe("sending", () => {
119: 		let action!: KeyAction;
120: 		beforeAll(() => (action = new KeyAction(source)));
121: 		it("setImage", async () => {
122: 			await action.setImage();
123: 			await action.setImage("./imgs/test.png", {
124: 				state: 1,
125: 				target: Target.Hardware,
126: 			});
127: 			expect(connection.send).toHaveBeenCalledTimes(2);
128: 			expect(connection.send).toHaveBeenNthCalledWith<[SetImage]>(1, {
129: 				context: action.id,
130: 				event: "setImage",
131: 				payload: {
132: 					image: undefined,
133: 					state: undefined,
134: 					target: undefined,
135: 				},
136: 			});
137: 			expect(connection.send).toHaveBeenNthCalledWith<[SetImage]>(2, {
138: 				context: action.id,
139: 				event: "setImage",
140: 				payload: {
141: 					image: "./imgs/test.png",
142: 					state: 1,
143: 					target: Target.Hardware,
144: 				},
145: 			});
146: 		});
147: 		it("setState", async () => {
148: 			await action.setState(1);
149: 			expect(connection.send).toHaveBeenCalledTimes(1);
150: 			expect(connection.send).toHaveBeenCalledWith<[SetState]>({
151: 				context: action.id,
152: 				event: "setState",
153: 				payload: {
154: 					state: 1,
155: 				},
156: 			});
157: 		});
158: 		it("setTitle", async () => {
159: 			await action.setTitle("Hello world");
160: 			await action.setTitle("This is a test", { state: 1, target: Target.Software });
161: 			expect(connection.send).toHaveBeenCalledTimes(2);
162: 			expect(connection.send).toHaveBeenNthCalledWith<[SetTitle]>(1, {
163: 				event: "setTitle",
164: 				context: action.id,
165: 				payload: {
166: 					title: "Hello world",
167: 				},
168: 			});
169: 			expect(connection.send).toHaveBeenNthCalledWith<[SetTitle]>(2, {
170: 				event: "setTitle",
171: 				context: action.id,
172: 				payload: {
173: 					state: 1,
174: 					target: Target.Software,
175: 					title: "This is a test",
176: 				},
177: 			});
178: 		});
179: 		it("showOk", async () => {
180: 			await action.showOk();
181: 			expect(connection.send).toHaveBeenCalledTimes(1);
182: 			expect(connection.send).toHaveBeenCalledWith<[ShowOk]>({
183: 				context: action.id,
184: 				event: "showOk",
185: 			});
186: 		});
187: 	});
188: });
</file>

<file path="src/plugin/actions/__tests__/service.test.ts">
  1: import type {
  2: 	DialDown,
  3: 	DialRotate,
  4: 	DialUp,
  5: 	DidReceivePropertyInspectorMessage,
  6: 	DidReceiveSettings,
  7: 	KeyDown,
  8: 	KeyUp,
  9: 	PropertyInspectorDidAppear,
 10: 	PropertyInspectorDidDisappear,
 11: 	TitleParametersDidChange,
 12: 	TouchTap,
 13: 	WillAppear,
 14: 	WillDisappear,
 15: } from "../../../api";
 16: import { Settings } from "../../../api/__mocks__/events";
 17: import { JsonObject } from "../../../common/json";
 18: import { connection } from "../../connection";
 19: import {
 20: 	type DialDownEvent,
 21: 	type DialRotateEvent,
 22: 	type DialUpEvent,
 23: 	type DidReceiveSettingsEvent,
 24: 	type KeyDownEvent,
 25: 	type KeyUpEvent,
 26: 	type PropertyInspectorDidAppearEvent,
 27: 	type PropertyInspectorDidDisappearEvent,
 28: 	type SendToPluginEvent,
 29: 	type TitleParametersDidChangeEvent,
 30: 	type TouchTapEvent,
 31: 	type WillAppearEvent,
 32: 	type WillDisappearEvent,
 33: } from "../../events";
 34: import type { UIController } from "../../ui";
 35: import { ActionContext } from "../context";
 36: import { DialAction } from "../dial";
 37: import { KeyAction } from "../key";
 38: import { actionService, type ActionService } from "../service";
 39: import { SingletonAction } from "../singleton-action";
 40: import { actionStore } from "../store";
 41: jest.mock("../store");
 42: jest.mock("../../devices/store");
 43: jest.mock("../../connection");
 44: jest.mock("../../logging");
 45: jest.mock("../../manifest");
 46: describe("actions", () => {
 47: 	describe("event emitters", () => {
 48: 		it("receives onDialDown", () => {
 49: 			const listener = jest.fn();
 50: 			const ev = {
 51: 				action: "com.elgato.test.dial",
 52: 				context: "dial123",
 53: 				device: "device123",
 54: 				event: "dialDown",
 55: 				payload: {
 56: 					controller: "Encoder",
 57: 					coordinates: {
 58: 						column: 2,
 59: 						row: 0,
 60: 					},
 61: 					settings: {
 62: 						name: "Hello world",
 63: 					},
 64: 				},
 65: 			} satisfies DialDown<Settings>;
 66: 			const disposable = actionService.onDialDown(listener);
 67: 			connection.emit("dialDown", ev);
 68: 			expect(listener).toHaveBeenCalledTimes(1);
 69: 			expect(listener).toHaveBeenCalledWith<[DialDownEvent<Settings>]>({
 70: 				action: actionStore.getActionById(ev.context) as DialAction,
 71: 				payload: ev.payload,
 72: 				type: "dialDown",
 73: 			});
 74: 			disposable.dispose();
 75: 			connection.emit(ev.event, ev as any);
 76: 			expect(listener).toHaveBeenCalledTimes(1);
 77: 		});
 78: 		it("receives onDialRotate", () => {
 79: 			const listener = jest.fn();
 80: 			const ev = {
 81: 				action: "com.elgato.test.dial",
 82: 				context: "dial123",
 83: 				device: "device123",
 84: 				event: "dialRotate",
 85: 				payload: {
 86: 					controller: "Encoder",
 87: 					coordinates: {
 88: 						column: 2,
 89: 						row: 0,
 90: 					},
 91: 					pressed: false,
 92: 					settings: {
 93: 						name: "Hello world",
 94: 					},
 95: 					ticks: 1,
 96: 				},
 97: 			} satisfies DialRotate<Settings>;
 98: 			const disposable = actionService.onDialRotate(listener);
 99: 			connection.emit("dialRotate", ev);
100: 			expect(listener).toHaveBeenCalledTimes(1);
101: 			expect(listener).toHaveBeenCalledWith<[DialRotateEvent<Settings>]>({
102: 				action: actionStore.getActionById(ev.context) as DialAction,
103: 				payload: ev.payload,
104: 				type: "dialRotate",
105: 			});
106: 			disposable.dispose();
107: 			connection.emit(ev.event, ev as any);
108: 			expect(listener).toHaveBeenCalledTimes(1);
109: 		});
110: 		it("receives onDialUp", () => {
111: 			const listener = jest.fn();
112: 			const ev = {
113: 				action: "com.elgato.test.dial",
114: 				context: "dial123",
115: 				device: "device123",
116: 				event: "dialUp",
117: 				payload: {
118: 					controller: "Encoder",
119: 					coordinates: {
120: 						column: 2,
121: 						row: 0,
122: 					},
123: 					settings: {
124: 						name: "Hello world",
125: 					},
126: 				},
127: 			} satisfies DialUp<Settings>;
128: 			const disposable = actionService.onDialUp(listener);
129: 			connection.emit("dialUp", ev);
130: 			expect(listener).toHaveBeenCalledTimes(1);
131: 			expect(listener).toHaveBeenCalledWith<[DialUpEvent<Settings>]>({
132: 				action: actionStore.getActionById(ev.context) as DialAction,
133: 				payload: ev.payload,
134: 				type: "dialUp",
135: 			});
136: 			disposable.dispose();
137: 			connection.emit(ev.event, ev as any);
138: 			expect(listener).toHaveBeenCalledTimes(1);
139: 		});
140: 		it("receives onKeyDown", () => {
141: 			const listener = jest.fn();
142: 			const ev = {
143: 				action: "com.elgato.test.key",
144: 				context: "key123",
145: 				device: "device123",
146: 				event: "keyDown",
147: 				payload: {
148: 					controller: "Keypad",
149: 					coordinates: {
150: 						column: 2,
151: 						row: 0,
152: 					},
153: 					isInMultiAction: false,
154: 					settings: {
155: 						name: "Hello world",
156: 					},
157: 				},
158: 			} satisfies KeyDown<Settings>;
159: 			const disposable = actionService.onKeyDown(listener);
160: 			connection.emit("keyDown", ev);
161: 			expect(listener).toHaveBeenCalledTimes(1);
162: 			expect(listener).toHaveBeenCalledWith<[KeyDownEvent<Settings>]>({
163: 				action: actionStore.getActionById(ev.context) as KeyAction,
164: 				payload: ev.payload,
165: 				type: "keyDown",
166: 			});
167: 			disposable.dispose();
168: 			connection.emit(ev.event, ev as any);
169: 			expect(listener).toHaveBeenCalledTimes(1);
170: 		});
171: 		it("receives onKeyUp", () => {
172: 			const listener = jest.fn();
173: 			const ev = {
174: 				action: "com.elgato.test.key",
175: 				context: "key123",
176: 				device: "device123",
177: 				event: "keyUp",
178: 				payload: {
179: 					controller: "Keypad",
180: 					coordinates: {
181: 						column: 2,
182: 						row: 0,
183: 					},
184: 					isInMultiAction: false,
185: 					settings: {
186: 						name: "Hello world",
187: 					},
188: 				},
189: 			} satisfies KeyUp<Settings>;
190: 			const disposable = actionService.onKeyUp(listener);
191: 			connection.emit("keyUp", ev);
192: 			expect(listener).toHaveBeenCalledTimes(1);
193: 			expect(listener).toHaveBeenCalledWith<[KeyUpEvent<Settings>]>({
194: 				action: actionStore.getActionById(ev.context) as KeyAction,
195: 				payload: ev.payload,
196: 				type: "keyUp",
197: 			});
198: 			disposable.dispose();
199: 			connection.emit(ev.event, ev as any);
200: 			expect(listener).toHaveBeenCalledTimes(1);
201: 		});
202: 		it("receives onTitleParametersDidChange", () => {
203: 			const listener = jest.fn();
204: 			const ev = {
205: 				action: "com.elgato.test.key",
206: 				context: "key123",
207: 				device: "device123",
208: 				event: "titleParametersDidChange",
209: 				payload: {
210: 					controller: "Keypad",
211: 					coordinates: {
212: 						column: 2,
213: 						row: 0,
214: 					},
215: 					settings: {
216: 						name: "Hello world",
217: 					},
218: 					title: "Title goes here...",
219: 					titleParameters: {
220: 						fontFamily: "Arial",
221: 						fontSize: 13,
222: 						fontStyle: "Bold",
223: 						fontUnderline: false,
224: 						showTitle: true,
225: 						titleAlignment: "bottom",
226: 						titleColor: "white",
227: 					},
228: 				},
229: 			} satisfies TitleParametersDidChange<Settings>;
230: 			const disposable = actionService.onTitleParametersDidChange(listener);
231: 			connection.emit("titleParametersDidChange", ev);
232: 			expect(listener).toHaveBeenCalledTimes(1);
233: 			expect(listener).toHaveBeenCalledWith<[TitleParametersDidChangeEvent<Settings>]>({
234: 				action: actionStore.getActionById(ev.context) as KeyAction,
235: 				payload: ev.payload,
236: 				type: "titleParametersDidChange",
237: 			});
238: 			disposable.dispose();
239: 			connection.emit(ev.event, ev as any);
240: 			expect(listener).toHaveBeenCalledTimes(1);
241: 		});
242: 		it("receives onTouchTap", () => {
243: 			const listener = jest.fn();
244: 			const ev = {
245: 				action: "com.elgato.test.dial",
246: 				context: "dial123",
247: 				device: "device123",
248: 				event: "touchTap",
249: 				payload: {
250: 					controller: "Encoder",
251: 					coordinates: {
252: 						column: 2,
253: 						row: 0,
254: 					},
255: 					settings: {
256: 						name: "Hello world",
257: 					},
258: 					hold: false,
259: 					tapPos: [13, 13],
260: 				},
261: 			} satisfies TouchTap<Settings>;
262: 			const disposable = actionService.onTouchTap(listener);
263: 			connection.emit("touchTap", ev);
264: 			expect(listener).toHaveBeenCalledTimes(1);
265: 			expect(listener).toHaveBeenCalledWith<[TouchTapEvent<Settings>]>({
266: 				action: actionStore.getActionById(ev.context) as DialAction,
267: 				payload: ev.payload,
268: 				type: "touchTap",
269: 			});
270: 			disposable.dispose();
271: 			connection.emit(ev.event, ev as any);
272: 			expect(listener).toHaveBeenCalledTimes(1);
273: 		});
274: 		it("receives onWillAppear", () => {
275: 			const listener = jest.fn();
276: 			const ev = {
277: 				action: "com.elgato.test.key",
278: 				context: "key123",
279: 				device: "device123",
280: 				event: "willAppear",
281: 				payload: {
282: 					controller: "Encoder",
283: 					coordinates: {
284: 						column: 2,
285: 						row: 0,
286: 					},
287: 					isInMultiAction: false,
288: 					settings: {
289: 						name: "Hello world",
290: 					},
291: 				},
292: 			} satisfies WillAppear<Settings>;
293: 			const disposable = actionService.onWillAppear(listener);
294: 			connection.emit("willAppear", ev);
295: 			expect(listener).toHaveBeenCalledTimes(1);
296: 			expect(listener).toHaveBeenCalledWith<[WillAppearEvent<Settings>]>({
297: 				action: actionStore.getActionById(ev.context) as KeyAction,
298: 				payload: ev.payload,
299: 				type: "willAppear",
300: 			});
301: 			disposable.dispose();
302: 			connection.emit(ev.event, ev as any);
303: 			expect(listener).toHaveBeenCalledTimes(1);
304: 		});
305: 		it("receives onWillDisappear", () => {
306: 			const listener = jest.fn();
307: 			const ev = {
308: 				action: "com.elgato.test.key",
309: 				context: "context123",
310: 				device: "device123",
311: 				event: "willDisappear",
312: 				payload: {
313: 					controller: "Encoder",
314: 					coordinates: {
315: 						column: 2,
316: 						row: 0,
317: 					},
318: 					isInMultiAction: false,
319: 					settings: {
320: 						name: "Hello world",
321: 					},
322: 				},
323: 			} satisfies WillDisappear<Settings>;
324: 			const disposable = actionService.onWillDisappear(listener);
325: 			connection.emit("willDisappear", ev);
326: 			expect(listener).toHaveBeenCalledTimes(1);
327: 			expect(listener).toHaveBeenCalledWith<[WillDisappearEvent<Settings>]>({
328: 				action: new ActionContext(ev),
329: 				payload: ev.payload,
330: 				type: "willDisappear",
331: 			});
332: 			disposable.dispose();
333: 			connection.emit(ev.event, ev as any);
334: 			expect(listener).toHaveBeenCalledTimes(1);
335: 		});
336: 	});
337: 	describe("registering an action", () => {
338: 		const keyManifestId = "com.elgato.test.key";
339: 		const dialManifestId = "com.elgato.test.dial";
340: 		const actions = jest.fn() as unknown as IterableIterator<DialAction<JsonObject> | KeyAction<JsonObject>>;
341: 		it("validates the manifestId is not undefined", () => {
342: 			const action: SingletonAction = {
343: 				manifestId: undefined,
344: 				actions,
345: 			};
346: 			expect(() => actionService.registerAction(action)).toThrow("The action's manifestId cannot be undefined.");
347: 		});
348: 		it("validates when action does not exist in manifest", () => {
349: 			const action: SingletonAction = {
350: 				actions,
351: 				manifestId: "com.elgato.action-service.__one",
352: 			};
353: 			expect(() => actionService.registerAction(action)).toThrow("com.elgato.action-service.__one");
354: 		});
355: 		it("ignore undefined handlers", () => {
356: 			const spyOnAddListener = jest.spyOn(connection, "addListener");
357: 			const spyOnDisposableOn = jest.spyOn(connection, "disposableOn");
358: 			const spyOnOn = jest.spyOn(connection, "on");
359: 			const spyOnOnce = jest.spyOn(connection, "once");
360: 			const spyOnPrependListener = jest.spyOn(connection, "prependListener");
361: 			const spyOnPrependOnceListener = jest.spyOn(connection, "prependOnceListener");
362: 			actionService.registerAction({
363: 				actions,
364: 				manifestId: keyManifestId,
365: 			});
366: 			expect(spyOnAddListener).not.toHaveBeenCalled();
367: 			expect(spyOnDisposableOn).not.toHaveBeenCalled();
368: 			expect(spyOnOn).not.toHaveBeenCalled();
369: 			expect(spyOnOnce).not.toHaveBeenCalled();
370: 			expect(spyOnPrependListener).not.toHaveBeenCalled();
371: 			expect(spyOnPrependOnceListener).not.toHaveBeenCalled();
372: 		});
373: 		it("routes onDialDown", () => {
374: 			const listener = jest.fn();
375: 			const ev = {
376: 				action: dialManifestId,
377: 				context: "dial123",
378: 				device: "device123",
379: 				event: "dialDown",
380: 				payload: {
381: 					controller: "Encoder",
382: 					coordinates: {
383: 						column: 2,
384: 						row: 0,
385: 					},
386: 					settings: {
387: 						name: "Hello world",
388: 					},
389: 				},
390: 			} satisfies DialDown<Settings>;
391: 			actionService.registerAction({
392: 				actions,
393: 				manifestId: ev.action,
394: 				onDialDown: listener,
395: 			});
396: 			connection.emit("dialDown", ev);
397: 			expect(listener).toHaveBeenCalledTimes(1);
398: 			expect(listener).toHaveBeenCalledWith<[DialDownEvent<Settings>]>({
399: 				action: actionStore.getActionById(ev.context) as DialAction,
400: 				payload: ev.payload,
401: 				type: "dialDown",
402: 			});
403: 		});
404: 		it("routes onDialRotate", () => {
405: 			const listener = jest.fn();
406: 			const ev = {
407: 				action: dialManifestId,
408: 				context: "dial123",
409: 				device: "device123",
410: 				event: "dialRotate",
411: 				payload: {
412: 					controller: "Encoder",
413: 					coordinates: {
414: 						column: 2,
415: 						row: 0,
416: 					},
417: 					pressed: false,
418: 					settings: {
419: 						name: "Hello world",
420: 					},
421: 					ticks: 1,
422: 				},
423: 			} satisfies DialRotate<Settings>;
424: 			actionService.registerAction({
425: 				actions,
426: 				manifestId: ev.action,
427: 				onDialRotate: listener,
428: 			});
429: 			connection.emit("dialRotate", ev);
430: 			expect(listener).toHaveBeenCalledTimes(1);
431: 			expect(listener).toHaveBeenCalledWith<[DialRotateEvent<Settings>]>({
432: 				action: actionStore.getActionById(ev.context) as DialAction,
433: 				payload: ev.payload,
434: 				type: "dialRotate",
435: 			});
436: 		});
437: 		it("routes onDialUp", () => {
438: 			const listener = jest.fn();
439: 			const ev = {
440: 				action: dialManifestId,
441: 				context: "dial123",
442: 				device: "device123",
443: 				event: "dialUp",
444: 				payload: {
445: 					controller: "Encoder",
446: 					coordinates: {
447: 						column: 2,
448: 						row: 0,
449: 					},
450: 					settings: {
451: 						name: "Hello world",
452: 					},
453: 				},
454: 			} satisfies DialUp<Settings>;
455: 			actionService.registerAction({
456: 				actions,
457: 				manifestId: ev.action,
458: 				onDialUp: listener,
459: 			});
460: 			connection.emit("dialUp", ev);
461: 			expect(listener).toHaveBeenCalledTimes(1);
462: 			expect(listener).toHaveBeenCalledWith<[DialUpEvent<Settings>]>({
463: 				action: actionStore.getActionById(ev.context) as DialAction,
464: 				payload: ev.payload,
465: 				type: "dialUp",
466: 			});
467: 		});
468: 		it("routes sendToPlugin", () => {
469: 			const listener = jest.fn();
470: 			const ev = {
471: 				action: keyManifestId,
472: 				context: "key123",
473: 				event: "sendToPlugin",
474: 				payload: {
475: 					name: "Hello world",
476: 				},
477: 			} satisfies DidReceivePropertyInspectorMessage<Settings>;
478: 			actionService.registerAction({
479: 				actions,
480: 				manifestId: ev.action,
481: 				onSendToPlugin: listener,
482: 			});
483: 			connection.emit("sendToPlugin", ev);
484: 			expect(listener).toHaveBeenCalledTimes(1);
485: 			expect(listener).toHaveBeenCalledWith<[SendToPluginEvent<Settings, Settings>]>({
486: 				action: actionStore.getActionById(ev.context) as KeyAction,
487: 				payload: {
488: 					name: "Hello world",
489: 				},
490: 				type: "sendToPlugin",
491: 			});
492: 		});
493: 		it("routes onDidReceiveGlobalSettings", () => {
494: 			const listener = jest.fn();
495: 			const ev = {
496: 				action: keyManifestId,
497: 				context: "key123",
498: 				device: "device123",
499: 				event: "didReceiveSettings",
500: 				payload: {
501: 					controller: "Encoder",
502: 					coordinates: {
503: 						column: 2,
504: 						row: 0,
505: 					},
506: 					isInMultiAction: false,
507: 					settings: {
508: 						name: "Hello world",
509: 					},
510: 				},
511: 			} satisfies DidReceiveSettings<Settings>;
512: 			actionService.registerAction({
513: 				actions,
514: 				manifestId: ev.action,
515: 				onDidReceiveSettings: listener,
516: 			});
517: 			connection.emit("didReceiveSettings", ev);
518: 			expect(listener).toHaveBeenCalledTimes(1);
519: 			expect(listener).toHaveBeenCalledWith<[DidReceiveSettingsEvent<Settings>]>({
520: 				action: actionStore.getActionById(ev.context) as KeyAction,
521: 				payload: ev.payload,
522: 				type: "didReceiveSettings",
523: 			});
524: 		});
525: 		it("routes onKeyDown", () => {
526: 			const listener = jest.fn();
527: 			const ev = {
528: 				action: keyManifestId,
529: 				context: "key123",
530: 				device: "device123",
531: 				event: "keyDown",
532: 				payload: {
533: 					controller: "Keypad",
534: 					coordinates: {
535: 						column: 2,
536: 						row: 0,
537: 					},
538: 					isInMultiAction: false,
539: 					settings: {
540: 						name: "Hello world",
541: 					},
542: 				},
543: 			} satisfies KeyDown<Settings>;
544: 			actionService.registerAction({
545: 				actions,
546: 				manifestId: ev.action,
547: 				onKeyDown: listener,
548: 			});
549: 			connection.emit("keyDown", ev);
550: 			expect(listener).toHaveBeenCalledTimes(1);
551: 			expect(listener).toHaveBeenCalledWith<[KeyDownEvent<Settings>]>({
552: 				action: actionStore.getActionById(ev.context) as KeyAction,
553: 				payload: ev.payload,
554: 				type: "keyDown",
555: 			});
556: 		});
557: 		it("routes onKeyUp", () => {
558: 			const listener = jest.fn();
559: 			const ev = {
560: 				action: keyManifestId,
561: 				context: "key123",
562: 				device: "device123",
563: 				event: "keyUp",
564: 				payload: {
565: 					controller: "Keypad",
566: 					coordinates: {
567: 						column: 2,
568: 						row: 0,
569: 					},
570: 					isInMultiAction: false,
571: 					settings: {
572: 						name: "Hello world",
573: 					},
574: 				},
575: 			} satisfies KeyUp<Settings>;
576: 			actionService.registerAction({
577: 				actions,
578: 				manifestId: ev.action,
579: 				onKeyUp: listener,
580: 			});
581: 			connection.emit("keyUp", ev);
582: 			expect(listener).toHaveBeenCalledTimes(1);
583: 			expect(listener).toHaveBeenCalledWith<[KeyUpEvent<Settings>]>({
584: 				action: actionStore.getActionById(ev.context) as KeyAction,
585: 				payload: ev.payload,
586: 				type: "keyUp",
587: 			});
588: 		});
589: 		it("routes onPropertyInspectorDidAppear", () => {
590: 			const listener = jest.fn();
591: 			const ev = {
592: 				action: keyManifestId,
593: 				context: "key123",
594: 				device: "device123",
595: 				event: "propertyInspectorDidAppear",
596: 			} satisfies PropertyInspectorDidAppear;
597: 			actionService.registerAction({
598: 				actions,
599: 				manifestId: ev.action,
600: 				onPropertyInspectorDidAppear: listener,
601: 			});
602: 			connection.emit("propertyInspectorDidAppear", ev);
603: 			expect(listener).toHaveBeenCalledTimes(1);
604: 			expect(listener).toHaveBeenCalledWith<[PropertyInspectorDidAppearEvent<Settings>]>({
605: 				action: actionStore.getActionById(ev.context) as KeyAction,
606: 				type: "propertyInspectorDidAppear",
607: 			});
608: 		});
609: 		it("routes onPropertyInspectorDidDisappear", () => {
610: 			const listener = jest.fn();
611: 			const ev = {
612: 				action: keyManifestId,
613: 				context: "key123",
614: 				device: "device123",
615: 				event: "propertyInspectorDidDisappear",
616: 			} satisfies PropertyInspectorDidDisappear;
617: 			actionService.registerAction({
618: 				actions,
619: 				manifestId: ev.action,
620: 				onPropertyInspectorDidDisappear: listener,
621: 			});
622: 			connection.emit("propertyInspectorDidDisappear", ev);
623: 			expect(listener).toHaveBeenCalledTimes(1);
624: 			expect(listener).toHaveBeenCalledWith<[PropertyInspectorDidDisappearEvent<Settings>]>({
625: 				action: actionStore.getActionById(ev.context) as KeyAction,
626: 				type: "propertyInspectorDidDisappear",
627: 			});
628: 		});
629: 		it("routes onTitleParametersDidChange", () => {
630: 			const listener = jest.fn();
631: 			const ev = {
632: 				action: keyManifestId,
633: 				context: "key123",
634: 				device: "device123",
635: 				event: "titleParametersDidChange",
636: 				payload: {
637: 					controller: "Keypad",
638: 					coordinates: {
639: 						column: 2,
640: 						row: 0,
641: 					},
642: 					settings: {
643: 						name: "Hello world",
644: 					},
645: 					title: "Title goes here...",
646: 					titleParameters: {
647: 						fontFamily: "Arial",
648: 						fontSize: 13,
649: 						fontStyle: "Bold",
650: 						fontUnderline: false,
651: 						showTitle: true,
652: 						titleAlignment: "bottom",
653: 						titleColor: "white",
654: 					},
655: 				},
656: 			} satisfies TitleParametersDidChange<Settings>;
657: 			actionService.registerAction({
658: 				actions,
659: 				manifestId: ev.action,
660: 				onTitleParametersDidChange: listener,
661: 			});
662: 			connection.emit("titleParametersDidChange", ev);
663: 			expect(listener).toHaveBeenCalledTimes(1);
664: 			expect(listener).toHaveBeenCalledWith<[TitleParametersDidChangeEvent<Settings>]>({
665: 				action: actionStore.getActionById(ev.context) as KeyAction,
666: 				payload: ev.payload,
667: 				type: "titleParametersDidChange",
668: 			});
669: 		});
670: 		it("routes onTouchTap", () => {
671: 			const listener = jest.fn();
672: 			const ev = {
673: 				action: dialManifestId,
674: 				context: "dial123",
675: 				device: "device123",
676: 				event: "touchTap",
677: 				payload: {
678: 					controller: "Encoder",
679: 					coordinates: {
680: 						column: 2,
681: 						row: 0,
682: 					},
683: 					settings: {
684: 						name: "Hello world",
685: 					},
686: 					hold: false,
687: 					tapPos: [13, 13],
688: 				},
689: 			} satisfies TouchTap<Settings>;
690: 			actionService.registerAction({
691: 				actions,
692: 				manifestId: ev.action,
693: 				onTouchTap: listener,
694: 			});
695: 			connection.emit("touchTap", ev);
696: 			expect(listener).toHaveBeenCalledTimes(1);
697: 			expect(listener).toHaveBeenCalledWith<[TouchTapEvent<Settings>]>({
698: 				action: actionStore.getActionById(ev.context) as DialAction,
699: 				payload: ev.payload,
700: 				type: "touchTap",
701: 			});
702: 		});
703: 		it("routes onWillAppear", () => {
704: 			const listener = jest.fn();
705: 			const ev = {
706: 				action: keyManifestId,
707: 				context: "key123",
708: 				device: "device123",
709: 				event: "willAppear",
710: 				payload: {
711: 					controller: "Encoder",
712: 					coordinates: {
713: 						column: 2,
714: 						row: 0,
715: 					},
716: 					isInMultiAction: false,
717: 					settings: {
718: 						name: "Hello world",
719: 					},
720: 				},
721: 			} satisfies WillAppear<Settings>;
722: 			actionService.registerAction({
723: 				actions,
724: 				manifestId: ev.action,
725: 				onWillAppear: listener,
726: 			});
727: 			connection.emit("willAppear", ev);
728: 			expect(listener).toHaveBeenCalledTimes(1);
729: 			expect(listener).toHaveBeenCalledWith<[WillAppearEvent<Settings>]>({
730: 				action: actionStore.getActionById(ev.context) as KeyAction,
731: 				payload: ev.payload,
732: 				type: "willAppear",
733: 			});
734: 		});
735: 		it("routes onWillDisappear", () => {
736: 			const listener = jest.fn();
737: 			const ev = {
738: 				action: keyManifestId,
739: 				context: "key123",
740: 				device: "device123",
741: 				event: "willDisappear",
742: 				payload: {
743: 					controller: "Encoder",
744: 					coordinates: {
745: 						column: 2,
746: 						row: 0,
747: 					},
748: 					isInMultiAction: false,
749: 					settings: {
750: 						name: "Hello world",
751: 					},
752: 				},
753: 			} satisfies WillDisappear<Settings>;
754: 			actionService.registerAction({
755: 				actions,
756: 				manifestId: ev.action,
757: 				onWillDisappear: listener,
758: 			});
759: 			connection.emit("willDisappear", ev);
760: 			expect(listener).toHaveBeenCalledTimes(1);
761: 			expect(listener).toHaveBeenCalledWith<[WillDisappearEvent<Settings>]>({
762: 				action: new ActionContext(ev),
763: 				payload: ev.payload,
764: 				type: "willDisappear",
765: 			});
766: 		});
767: 	});
768: });
</file>

<file path="src/plugin/actions/action.ts">
 1: import type { DidReceiveSettings } from "../../api";
 2: import type { JsonObject } from "../../common/json";
 3: import { connection } from "../connection";
 4: import { ActionContext } from "./context";
 5: import type { DialAction } from "./dial";
 6: import type { KeyAction } from "./key";
 7: export class Action<T extends JsonObject = JsonObject> extends ActionContext {
 8: 	public getSettings<U extends JsonObject = T>(): Promise<U> {
 9: 		return new Promise((resolve) => {
10: 			const callback = (ev: DidReceiveSettings<U>): void => {
11: 				if (ev.context == this.id) {
12: 					resolve(ev.payload.settings);
13: 					connection.removeListener("didReceiveSettings", callback);
14: 				}
15: 			};
16: 			connection.on("didReceiveSettings", callback);
17: 			connection.send({
18: 				event: "getSettings",
19: 				context: this.id,
20: 			});
21: 		});
22: 	}
23: 	public isDial(): this is DialAction {
24: 		return this.controllerType === "Encoder";
25: 	}
26: 	public isKey(): this is KeyAction {
27: 		return this.controllerType === "Keypad";
28: 	}
29: 	public setSettings<U extends JsonObject = T>(settings: U): Promise<void> {
30: 		return connection.send({
31: 			event: "setSettings",
32: 			context: this.id,
33: 			payload: settings,
34: 		});
35: 	}
36: 	public showAlert(): Promise<void> {
37: 		return connection.send({
38: 			event: "showAlert",
39: 			context: this.id,
40: 		});
41: 	}
42: }
</file>

<file path="src/plugin/actions/context.ts">
 1: import type { Controller, WillAppear, WillDisappear } from "../../api";
 2: import type { JsonObject } from "../../common/json";
 3: import type { Device } from "../devices";
 4: import { deviceStore } from "../devices/store";
 5: export class ActionContext {
 6: 	readonly #device: Device;
 7: 	readonly #source: WillAppear<JsonObject> | WillDisappear<JsonObject>;
 8: 	constructor(source: WillAppear<JsonObject> | WillDisappear<JsonObject>) {
 9: 		this.#source = source;
10: 		const device = deviceStore.getDeviceById(source.device);
11: 		if (!device) {
12: 			throw new Error(`Failed to initialize action; device ${source.device} not found`);
13: 		}
14: 		this.#device = device;
15: 	}
16: 	public get controllerType(): Controller {
17: 		return this.#source.payload.controller;
18: 	}
19: 	public get device(): Device {
20: 		return this.#device;
21: 	}
22: 	public get id(): string {
23: 		return this.#source.context;
24: 	}
25: 	public get manifestId(): string {
26: 		return this.#source.action;
27: 	}
28: 	public toJSON(): object {
29: 		return {
30: 			controllerType: this.controllerType,
31: 			device: this.device,
32: 			id: this.id,
33: 			manifestId: this.manifestId,
34: 		};
35: 	}
36: }
</file>

<file path="src/plugin/actions/decorators.ts">
 1: import type { Manifest } from "../../api";
 2: import type { Constructor, Unpack } from "../common/utils";
 3: import type { SingletonAction } from "./singleton-action";
 4: type ActionDefinition = Pick<Unpack<Manifest["Actions"]>, "UUID">;
 5: export function action(definition: ActionDefinition) {
 6: 	const manifestId = definition.UUID;
 7: 	return function <T extends Constructor<SingletonAction>>(target: T, context: ClassDecoratorContext) {
 8: 		return class extends target {
 9: 			public readonly manifestId: string | undefined = manifestId;
10: 		};
11: 	};
12: }
</file>

<file path="src/plugin/actions/dial.ts">
 1: import type { Coordinates, FeedbackPayload, SetTriggerDescription, WillAppear } from "../../api";
 2: import type { JsonObject } from "../../common/json";
 3: import type { KeyOf } from "../../common/utils";
 4: import { connection } from "../connection";
 5: import { Action } from "./action";
 6: export class DialAction<T extends JsonObject = JsonObject> extends Action<T> {
 7: 	readonly #coordinates: Readonly<Coordinates>;
 8: 	constructor(source: WillAppear<JsonObject>) {
 9: 		super(source);
10: 		if (source.payload.controller !== "Encoder") {
11: 			throw new Error("Unable to create DialAction; source event is not a Encoder");
12: 		}
13: 		this.#coordinates = Object.freeze(source.payload.coordinates);
14: 	}
15: 	public get coordinates(): Readonly<Coordinates> {
16: 		return this.#coordinates;
17: 	}
18: 	public setFeedback(feedback: FeedbackPayload): Promise<void> {
19: 		return connection.send({
20: 			event: "setFeedback",
21: 			context: this.id,
22: 			payload: feedback,
23: 		});
24: 	}
25: 	public setFeedbackLayout(layout: string): Promise<void> {
26: 		return connection.send({
27: 			event: "setFeedbackLayout",
28: 			context: this.id,
29: 			payload: {
30: 				layout,
31: 			},
32: 		});
33: 	}
34: 	public setImage(image?: string): Promise<void> {
35: 		return connection.send({
36: 			event: "setImage",
37: 			context: this.id,
38: 			payload: {
39: 				image,
40: 			},
41: 		});
42: 	}
43: 	public setTitle(title: string): Promise<void> {
44: 		return this.setFeedback({ title });
45: 	}
46: 	public setTriggerDescription(descriptions?: TriggerDescriptionOptions): Promise<void> {
47: 		return connection.send({
48: 			event: "setTriggerDescription",
49: 			context: this.id,
50: 			payload: descriptions || {},
51: 		});
52: 	}
53: 	public override toJSON(): object {
54: 		return {
55: 			...super.toJSON(),
56: 			coordinates: this.coordinates,
57: 		};
58: 	}
59: }
60: export type TriggerDescriptionOptions = KeyOf<SetTriggerDescription, "payload">;
</file>

<file path="src/plugin/actions/index.ts">
1: export type { Action } from "./action";
2: export type { ActionContext } from "./context";
3: export { action } from "./decorators";
4: export type { DialAction, TriggerDescriptionOptions } from "./dial";
5: export type { ImageOptions, KeyAction, TitleOptions } from "./key";
6: export type { ActionService } from "./service";
7: export { SingletonAction } from "./singleton-action";
</file>

<file path="src/plugin/actions/key.ts">
 1: import type { Coordinates, SetImage, SetTitle, State, WillAppear } from "../../api";
 2: import type { JsonObject } from "../../common/json";
 3: import type { KeyOf } from "../../common/utils";
 4: import { connection } from "../connection";
 5: import { Action } from "./action";
 6: export class KeyAction<T extends JsonObject = JsonObject> extends Action<T> {
 7: 	readonly #coordinates: Readonly<Coordinates> | undefined;
 8: 	readonly #source: WillAppear<JsonObject>;
 9: 	constructor(source: WillAppear<JsonObject>) {
10: 		super(source);
11: 		if (source.payload.controller !== "Keypad") {
12: 			throw new Error("Unable to create KeyAction; source event is not a Keypad");
13: 		}
14: 		this.#coordinates = !source.payload.isInMultiAction ? Object.freeze(source.payload.coordinates) : undefined;
15: 		this.#source = source;
16: 	}
17: 	public get coordinates(): Coordinates | undefined {
18: 		return this.#coordinates;
19: 	}
20: 	public isInMultiAction(): boolean {
21: 		return this.#source.payload.isInMultiAction;
22: 	}
23: 	public setImage(image?: string, options?: ImageOptions): Promise<void> {
24: 		return connection.send({
25: 			event: "setImage",
26: 			context: this.id,
27: 			payload: {
28: 				image,
29: 				...options,
30: 			},
31: 		});
32: 	}
33: 	public setState(state: State): Promise<void> {
34: 		return connection.send({
35: 			event: "setState",
36: 			context: this.id,
37: 			payload: {
38: 				state,
39: 			},
40: 		});
41: 	}
42: 	public setTitle(title?: string, options?: TitleOptions): Promise<void> {
43: 		return connection.send({
44: 			event: "setTitle",
45: 			context: this.id,
46: 			payload: {
47: 				title,
48: 				...options,
49: 			},
50: 		});
51: 	}
52: 	public showOk(): Promise<void> {
53: 		return connection.send({
54: 			event: "showOk",
55: 			context: this.id,
56: 		});
57: 	}
58: 	public override toJSON(): object {
59: 		return {
60: 			...super.toJSON(),
61: 			coordinates: this.coordinates,
62: 			isInMultiAction: this.isInMultiAction(),
63: 		};
64: 	}
65: }
66: export type ImageOptions = Omit<KeyOf<SetImage, "payload">, "image">;
67: export type TitleOptions = Omit<KeyOf<SetTitle, "payload">, "title">;
</file>

<file path="src/plugin/actions/service.ts">
  1: import type {
  2: 	DialDown,
  3: 	DialRotate,
  4: 	DialUp,
  5: 	KeyDown,
  6: 	KeyUp,
  7: 	TitleParametersDidChange,
  8: 	TouchTap,
  9: 	WillAppear,
 10: 	WillDisappear,
 11: } from "../../api";
 12: import type { IDisposable } from "../../common/disposable";
 13: import { ActionEvent } from "../../common/events";
 14: import type { JsonObject } from "../../common/json";
 15: import { connection } from "../connection";
 16: import {
 17: 	DialDownEvent,
 18: 	DialRotateEvent,
 19: 	DialUpEvent,
 20: 	KeyDownEvent,
 21: 	KeyUpEvent,
 22: 	TitleParametersDidChangeEvent,
 23: 	TouchTapEvent,
 24: 	WillAppearEvent,
 25: 	WillDisappearEvent,
 26: } from "../events";
 27: import { getManifest } from "../manifest";
 28: import { onDidReceiveSettings } from "../settings";
 29: import { ui } from "../ui";
 30: import { Action } from "./action";
 31: import { ActionContext } from "./context";
 32: import { DialAction } from "./dial";
 33: import { KeyAction } from "./key";
 34: import type { SingletonAction } from "./singleton-action";
 35: import { actionStore, ReadOnlyActionStore } from "./store";
 36: const manifest = getManifest();
 37: class ActionService extends ReadOnlyActionStore {
 38: 	constructor() {
 39: 		super();
 40: 		connection.prependListener("willAppear", (ev) => {
 41: 			const action = ev.payload.controller === "Encoder" ? new DialAction(ev) : new KeyAction(ev);
 42: 			actionStore.set(action);
 43: 		});
 44: 		connection.prependListener("willDisappear", (ev) => actionStore.delete(ev.context));
 45: 	}
 46: 	public onDialDown<T extends JsonObject = JsonObject>(listener: (ev: DialDownEvent<T>) => void): IDisposable {
 47: 		return connection.disposableOn("dialDown", (ev: DialDown<T>) => {
 48: 			const action = actionStore.getActionById(ev.context);
 49: 			if (action?.isDial()) {
 50: 				listener(new ActionEvent(action, ev));
 51: 			}
 52: 		});
 53: 	}
 54: 	public onDialRotate<T extends JsonObject = JsonObject>(listener: (ev: DialRotateEvent<T>) => void): IDisposable {
 55: 		return connection.disposableOn("dialRotate", (ev: DialRotate<T>) => {
 56: 			const action = actionStore.getActionById(ev.context);
 57: 			if (action?.isDial()) {
 58: 				listener(new ActionEvent(action, ev));
 59: 			}
 60: 		});
 61: 	}
 62: 	public onDialUp<T extends JsonObject = JsonObject>(listener: (ev: DialUpEvent<T>) => void): IDisposable {
 63: 		return connection.disposableOn("dialUp", (ev: DialUp<T>) => {
 64: 			const action = actionStore.getActionById(ev.context);
 65: 			if (action?.isDial()) {
 66: 				listener(new ActionEvent(action, ev));
 67: 			}
 68: 		});
 69: 	}
 70: 	public onKeyDown<T extends JsonObject = JsonObject>(listener: (ev: KeyDownEvent<T>) => void): IDisposable {
 71: 		return connection.disposableOn("keyDown", (ev: KeyDown<T>) => {
 72: 			const action = actionStore.getActionById(ev.context);
 73: 			if (action?.isKey()) {
 74: 				listener(new ActionEvent(action, ev));
 75: 			}
 76: 		});
 77: 	}
 78: 	public onKeyUp<T extends JsonObject = JsonObject>(listener: (ev: KeyUpEvent<T>) => void): IDisposable {
 79: 		return connection.disposableOn("keyUp", (ev: KeyUp<T>) => {
 80: 			const action = actionStore.getActionById(ev.context);
 81: 			if (action?.isKey()) {
 82: 				listener(new ActionEvent(action, ev));
 83: 			}
 84: 		});
 85: 	}
 86: 	public onTitleParametersDidChange<T extends JsonObject = JsonObject>(
 87: 		listener: (ev: TitleParametersDidChangeEvent<T>) => void,
 88: 	): IDisposable {
 89: 		return connection.disposableOn("titleParametersDidChange", (ev: TitleParametersDidChange<T>) => {
 90: 			const action = actionStore.getActionById(ev.context);
 91: 			if (action) {
 92: 				listener(new ActionEvent(action, ev));
 93: 			}
 94: 		});
 95: 	}
 96: 	public onTouchTap<T extends JsonObject = JsonObject>(listener: (ev: TouchTapEvent<T>) => void): IDisposable {
 97: 		return connection.disposableOn("touchTap", (ev: TouchTap<T>) => {
 98: 			const action = actionStore.getActionById(ev.context);
 99: 			if (action?.isDial()) {
100: 				listener(new ActionEvent(action, ev));
101: 			}
102: 		});
103: 	}
104: 	public onWillAppear<T extends JsonObject = JsonObject>(listener: (ev: WillAppearEvent<T>) => void): IDisposable {
105: 		return connection.disposableOn("willAppear", (ev: WillAppear<T>) => {
106: 			const action = actionStore.getActionById(ev.context);
107: 			if (action) {
108: 				listener(new ActionEvent(action, ev));
109: 			}
110: 		});
111: 	}
112: 	public onWillDisappear<T extends JsonObject = JsonObject>(
113: 		listener: (ev: WillDisappearEvent<T>) => void,
114: 	): IDisposable {
115: 		return connection.disposableOn("willDisappear", (ev: WillDisappear<T>) =>
116: 			listener(new ActionEvent(new ActionContext(ev), ev)),
117: 		);
118: 	}
119: 	public registerAction<TAction extends SingletonAction<TSettings>, TSettings extends JsonObject = JsonObject>(
120: 		action: TAction,
121: 	): void {
122: 		if (action.manifestId === undefined) {
123: 			throw new Error("The action's manifestId cannot be undefined.");
124: 		}
125: 		if (!manifest.Actions.some((a) => a.UUID === action.manifestId)) {
126: 			throw new Error(`The action's manifestId was not found within the manifest: ${action.manifestId}`);
127: 		}
128: 		const { manifestId } = action;
129: 		const route = <TEventArgs extends RoutingEvent<TSettings>>(
130: 			fn: (listener: (ev: TEventArgs) => void) => IDisposable,
131: 			listener: ((ev: TEventArgs) => Promise<void> | void) | undefined,
132: 		): void => {
133: 			const boundedListener = listener?.bind(action);
134: 			if (boundedListener === undefined) {
135: 				return;
136: 			}
137: 			fn.bind(action)(async (ev) => {
138: 				if (ev.action.manifestId == manifestId) {
139: 					await boundedListener(ev);
140: 				}
141: 			});
142: 		};
143: 		route(this.onDialDown, action.onDialDown);
144: 		route(this.onDialUp, action.onDialUp);
145: 		route(this.onDialRotate, action.onDialRotate);
146: 		route(ui.onSendToPlugin, action.onSendToPlugin);
147: 		route(onDidReceiveSettings, action.onDidReceiveSettings);
148: 		route(this.onKeyDown, action.onKeyDown);
149: 		route(this.onKeyUp, action.onKeyUp);
150: 		route(ui.onDidAppear, action.onPropertyInspectorDidAppear);
151: 		route(ui.onDidDisappear, action.onPropertyInspectorDidDisappear);
152: 		route(this.onTitleParametersDidChange, action.onTitleParametersDidChange);
153: 		route(this.onTouchTap, action.onTouchTap);
154: 		route(this.onWillAppear, action.onWillAppear);
155: 		route(this.onWillDisappear, action.onWillDisappear);
156: 	}
157: }
158: export const actionService = new ActionService();
159: export { type ActionService };
160: type RoutingEvent<T extends JsonObject> = {
161: 	action: Action<T> | ActionContext;
162: };
</file>

<file path="src/plugin/actions/singleton-action.ts">
 1: import type streamDeck from "../";
 2: import type { Enumerable } from "../../common/enumerable";
 3: import type { JsonObject, JsonValue } from "../../common/json";
 4: import type { DialAction } from "../actions/dial";
 5: import type { KeyAction } from "../actions/key";
 6: import type {
 7: 	DialDownEvent,
 8: 	DialRotateEvent,
 9: 	DialUpEvent,
10: 	DidReceiveSettingsEvent,
11: 	KeyDownEvent,
12: 	KeyUpEvent,
13: 	PropertyInspectorDidAppearEvent,
14: 	PropertyInspectorDidDisappearEvent,
15: 	SendToPluginEvent,
16: 	TitleParametersDidChangeEvent,
17: 	TouchTapEvent,
18: 	WillAppearEvent,
19: 	WillDisappearEvent,
20: } from "../events";
21: import type { Action } from "./action";
22: import { actionStore } from "./store";
23: export class SingletonAction<T extends JsonObject = JsonObject> {
24: 	public readonly manifestId: string | undefined;
25: 	public get actions(): Enumerable<DialAction<T> | KeyAction<T>> {
26: 		return actionStore.filter((a) => a.manifestId === this.manifestId);
27: 	}
28: 	public onDialDown?(ev: DialDownEvent<T>): Promise<void> | void;
29: 	public onDialRotate?(ev: DialRotateEvent<T>): Promise<void> | void;
30: 	public onDialUp?(ev: DialUpEvent<T>): Promise<void> | void;
31: 	public onDidReceiveSettings?(ev: DidReceiveSettingsEvent<T>): Promise<void> | void;
32: 	public onKeyDown?(ev: KeyDownEvent<T>): Promise<void> | void;
33: 	public onKeyUp?(ev: KeyUpEvent<T>): Promise<void> | void;
34: 	public onPropertyInspectorDidAppear?(ev: PropertyInspectorDidAppearEvent<T>): Promise<void> | void;
35: 	public onPropertyInspectorDidDisappear?(ev: PropertyInspectorDidDisappearEvent<T>): Promise<void> | void;
36: 	public onSendToPlugin?(ev: SendToPluginEvent<JsonValue, T>): Promise<void> | void;
37: 	public onTitleParametersDidChange?(ev: TitleParametersDidChangeEvent<T>): Promise<void> | void;
38: 	public onTouchTap?(ev: TouchTapEvent<T>): Promise<void> | void;
39: 	public onWillAppear?(ev: WillAppearEvent<T>): Promise<void> | void;
40: 	public onWillDisappear?(ev: WillDisappearEvent<T>): Promise<void> | void;
41: }
</file>

<file path="src/plugin/actions/store.ts">
 1: import { Enumerable } from "../../common/enumerable";
 2: import type { DialAction } from "./dial";
 3: import type { KeyAction } from "./key";
 4: const __items = new Map<string, DialAction | KeyAction>();
 5: export class ReadOnlyActionStore extends Enumerable<DialAction | KeyAction> {
 6: 	constructor() {
 7: 		super(__items);
 8: 	}
 9: 	public getActionById(id: string): DialAction | KeyAction | undefined {
10: 		return __items.get(id);
11: 	}
12: }
13: class ActionStore extends ReadOnlyActionStore {
14: 	public delete(id: string): void {
15: 		__items.delete(id);
16: 	}
17: 	public set(action: DialAction | KeyAction): void {
18: 		__items.set(action.id, action);
19: 	}
20: }
21: export const actionStore = new ActionStore();
</file>

<file path="src/plugin/common/__tests__/utils.test.ts">
 1: import path from "node:path";
 2: import type { isDebugMode } from "../utils";
 3: import { getPluginUUID } from "../utils";
 4: describe("getPluginUUID", () => {
 5: 	const cases = [
 6: 		{
 7: 			name: "Parses with .sdPlugin suffix",
 8: 			cwd: path.join("tests", "com.elgato.test.sdPlugin"),
 9: 			expected: "com.elgato.test",
10: 		},
11: 		{
12: 			name: "Parses without .sdPlugin suffix",
13: 			cwd: path.join("tests", "com.elgato.test"),
14: 			expected: "com.elgato.test",
15: 		},
16: 	];
17: 	it.each(cases)("$name", async ({ cwd, expected }) => {
18: 		jest.spyOn(process, "cwd").mockReturnValue(cwd);
19: 		const pluginUUID = getPluginUUID();
20: 		expect(pluginUUID).toBe(expected);
21: 	});
22: });
23: describe("isDebugMode", () => {
24: 	let origArgs: string[] = [];
25: 	beforeEach(() => (origArgs = process.execArgv));
26: 	afterEach(() => {
27: 		process.execArgv = origArgs;
28: 		jest.resetModules();
29: 	});
30: 	const cases = [
31: 		{
32: 			args: [],
33: 			expected: false,
34: 		},
35: 		{
36: 			args: ["--no-addons", "--enable-source-maps"],
37: 			expected: false,
38: 		},
39: 		{
40: 			args: ["--inspect=127.0.0.1:1234", "--no-addons", "--enable-source-maps"],
41: 			expected: true,
42: 		},
43: 		{
44: 			args: ["--no-addons", "--enable-source-maps", "--inspect=127.0.0.1:1234"],
45: 			expected: true,
46: 		},
47: 		{
48: 			args: ["--no-addons", "--inspect=127.0.0.1:1234", "--enable-source-maps"],
49: 			expected: true,
50: 		},
51: 		{
52: 			args: ["--inspect"],
53: 			expected: true,
54: 		},
55: 		{
56: 			args: ["--inspect=12345"],
57: 			expected: true,
58: 		},
59: 		{
60: 			args: ["--inspect=127.0.0.1:1234"],
61: 			expected: true,
62: 		},
63: 		{
64: 			args: ["--inspect-brk"],
65: 			expected: true,
66: 		},
67: 		{
68: 			args: ["--inspect-brk=127.0.0.1:1234"],
69: 			expected: true,
70: 		},
71: 		{
72: 			args: ["--inspect-port=1234"],
73: 			expected: true,
74: 		},
75: 		{
76: 			args: ["--inspect-port=127.0.0.1:1234"],
77: 			expected: true,
78: 		},
79: 	];
80: 	it.each(cases)("$args returns $expected", async ({ args, expected }) => {
81: 		const { isDebugMode } = (await require("../utils")) as typeof import("../utils");
82: 		process.execArgv = args;
83: 		expect(isDebugMode()).toBe(expected);
84: 	});
85: 	it("Caches result", async () => {
86: 		const { isDebugMode } = (await require("../utils")) as typeof import("../utils");
87: 		process.execArgv = ["--inspect", "127.0.0.1"];
88: 		expect(isDebugMode()).toBe(true);
89: 		process.execArgv = [];
90: 		expect(isDebugMode()).toBe(true);
91: 	});
92: });
</file>

<file path="src/plugin/common/__tests__/version.test.ts">
  1: import { Version } from "../version";
  2: describe("serialization", () => {
  3: 	describe("valid", () => {
  4: 		const cases = [
  5: 			{
  6: 				name: "major",
  7: 				value: "1",
  8: 				expected: [1, 0, 0, 0],
  9: 			},
 10: 			{
 11: 				name: "minor",
 12: 				value: "0.2",
 13: 				expected: [0, 2, 0, 0],
 14: 			},
 15: 			{
 16: 				name: "patch",
 17: 				value: "0.0.3",
 18: 				expected: [0, 0, 3, 0],
 19: 			},
 20: 			{
 21: 				name: "build",
 22: 				value: "0.0.0.789",
 23: 				expected: [0, 0, 0, 789],
 24: 			},
 25: 			{
 26: 				name: "major, minor",
 27: 				value: "1.2",
 28: 				expected: [1, 2, 0, 0],
 29: 			},
 30: 			{
 31: 				name: "major, patch",
 32: 				value: "1.0.13",
 33: 				expected: [1, 0, 13, 0],
 34: 			},
 35: 			{
 36: 				name: "major, build",
 37: 				value: "1.0.0.99",
 38: 				expected: [1, 0, 0, 99],
 39: 			},
 40: 			{
 41: 				name: "major, minor, patch",
 42: 				value: "1.2.3",
 43: 				expected: [1, 2, 3, 0],
 44: 			},
 45: 			{
 46: 				name: "major, minor, build",
 47: 				value: "1.2.0.4",
 48: 				expected: [1, 2, 0, 4],
 49: 			},
 50: 			{
 51: 				name: "major, patch, build",
 52: 				value: "1.0.3.4",
 53: 				expected: [1, 0, 3, 4],
 54: 			},
 55: 			{
 56: 				name: "major, minor, patch, build",
 57: 				value: "1.2.3.456",
 58: 				expected: [1, 2, 3, 456],
 59: 			},
 60: 		];
 61: 		it.each(cases)("parses $name", ({ value, expected }) => {
 62: 			const version = new Version(value);
 63: 			expect(version.major).toBe(expected[0]);
 64: 			expect(version.minor).toBe(expected[1]);
 65: 			expect(version.patch).toBe(expected[2]);
 66: 			expect(version.build).toBe(expected[3]);
 67: 		});
 68: 		it.each(cases)("stringifies $name", ({ value }) => {
 69: 			const version = new Version(value);
 70: 			expect(`${version}`).toBe(`${version.major}.${version.minor}`);
 71: 		});
 72: 	});
 73: 	describe("invalid", () => {
 74: 		const cases = [
 75: 			{
 76: 				name: "empty",
 77: 				value: "",
 78: 			},
 79: 			{
 80: 				name: "double period",
 81: 				value: "1..2",
 82: 			},
 83: 			{
 84: 				name: "zero before number",
 85: 				value: "1.02",
 86: 			},
 87: 			{
 88: 				name: "alphabetical",
 89: 				value: "abc",
 90: 			},
 91: 			{
 92: 				name: "tag name",
 93: 				value: "1.2.3-beta.1",
 94: 			},
 95: 		];
 96: 		it.each(cases)("$name", ({ value }) => {
 97: 			expect(() => new Version(value)).toThrow(
 98: 				`Invalid format; expected "{major}[.{minor}[.{patch}[.{build}]]]" but was "${value}"`,
 99: 			);
100: 		});
101: 	});
102: });
103: describe("comparison", () => {
104: 	const testCases = [
105: 		{
106: 			name: "same (1)",
107: 			x: "1.1.1.1",
108: 			y: "1.1.1.1",
109: 			expected: 0,
110: 		},
111: 		{
112: 			name: "same (2)",
113: 			x: "1.2.3.4",
114: 			y: "1.2.3.4",
115: 			expected: 0,
116: 		},
117: 		{
118: 			name: "major version (lesser)",
119: 			x: "1.0.0.0",
120: 			y: "2.0.0.0",
121: 			expected: -1,
122: 		},
123: 		{
124: 			name: "major version (greater)",
125: 			x: "2.0.0.0",
126: 			y: "1.0.0.0",
127: 			expected: 1,
128: 		},
129: 		{
130: 			name: "minor version (lesser)",
131: 			x: "0.1.0.0",
132: 			y: "0.2.0.0",
133: 			expected: -1,
134: 		},
135: 		{
136: 			name: "minor version (greater)",
137: 			x: "0.2.0.0",
138: 			y: "0.1.0.0",
139: 			expected: 1,
140: 		},
141: 		{
142: 			name: "patch version (lesser)",
143: 			x: "0.0.1.0",
144: 			y: "0.0.2.0",
145: 			expected: -1,
146: 		},
147: 		{
148: 			name: "patch version (greater)",
149: 			x: "0.0.2.0",
150: 			y: "0.0.1.0",
151: 			expected: 1,
152: 		},
153: 		{
154: 			name: "build version (lesser)",
155: 			x: "0.0.0.1",
156: 			y: "0.0.0.2",
157: 			expected: -1,
158: 		},
159: 		{
160: 			name: "build version (greater)",
161: 			x: "0.0.0.2",
162: 			y: "0.0.0.1",
163: 			expected: 1,
164: 		},
165: 	];
166: 	it.each(testCases)("$name", ({ x, y, expected }) => {
167: 		const versionX = new Version(x);
168: 		const versionY = new Version(y);
169: 		expect(versionX.compareTo(versionY)).toBe(expected);
170: 	});
171: });
</file>

<file path="src/plugin/common/utils.ts">
 1: import path from "node:path";
 2: let __isDebugMode: boolean | undefined = undefined;
 3: export function isDebugMode(): boolean {
 4: 	if (__isDebugMode === undefined) {
 5: 		__isDebugMode = process.execArgv.some((arg) => {
 6: 			const name = arg.split("=")[0];
 7: 			return name === "--inspect" || name === "--inspect-brk" || name === "--inspect-port";
 8: 		});
 9: 	}
10: 	return __isDebugMode;
11: }
12: export function getPluginUUID(): string {
13: 	const name = path.basename(process.cwd());
14: 	const suffixIndex = name.lastIndexOf(".sdPlugin");
15: 	return suffixIndex < 0 ? name : name.substring(0, suffixIndex);
16: }
17: type UnionKeys<T> = T extends T ? keyof T : never;
18: export type Constructor<T> = {
19: 	new (...args: any[]): T;
20: };
21: export type Enumerate<TLength extends number, TAcc extends number[] = []> = TAcc["length"] extends TLength
22: 	? TAcc[number]
23: 	: Enumerate<TLength, [...TAcc, TAcc["length"]]>;
24: export type Unpack<T> = T extends (infer U)[] ? U : T;
25: export type StrictUnion<TUnion, TStrict = TUnion> = TStrict extends unknown
26: 	? Partial<Record<Exclude<UnionKeys<TUnion>, keyof TStrict>, never>> & TStrict
27: 	: never;
</file>

<file path="src/plugin/common/version.ts">
 1: export class Version {
 2: 	public readonly build: number;
 3: 	public readonly major: number;
 4: 	public readonly minor: number;
 5: 	public readonly patch: number;
 6: 	constructor(value: string) {
 7: 		const result = value.match(/^(0|[1-9]\d*)(?:\.(0|[1-9]\d*))?(?:\.(0|[1-9]\d*))?(?:\.(0|[1-9]\d*))?$/);
 8: 		if (result === null) {
 9: 			throw new Error(`Invalid format; expected "{major}[.{minor}[.{patch}[.{build}]]]" but was "${value}"`);
10: 		}
11: 		[, this.major, this.minor, this.patch, this.build] = [...result.map<number>((value) => parseInt(value) || 0)];
12: 	}
13: 	public compareTo(other: VersionInfo): number {
14: 		const segments = ({ major, minor, build, patch }: VersionInfo): number[] => [major, minor, build, patch];
15: 		const thisSegments = segments(this);
16: 		const otherSegments = segments(other);
17: 		for (let i = 0; i < 4; i++) {
18: 			if (thisSegments[i] < otherSegments[i]) {
19: 				return -1;
20: 			} else if (thisSegments[i] > otherSegments[i]) {
21: 				return 1;
22: 			}
23: 		}
24: 		return 0;
25: 	}
26: 	public toString(): string {
27: 		return `${this.major}.${this.minor}`;
28: 	}
29: }
30: type VersionInfo = Pick<Version, "build" | "major" | "minor" | "patch">;
</file>

<file path="src/plugin/devices/__mocks__/index.ts">
 1: import { DeviceType } from "../../../api/device";
 2: import { type Device } from "../device";
 3: export const deviceService = {
 4: 	getDeviceById: jest.fn().mockImplementation((id: string) => {
 5: 		return {
 6: 			actions: Array.from([]).values(),
 7: 			id,
 8: 			name: "Device One",
 9: 			size: {
10: 				columns: 5,
11: 				rows: 3,
12: 			},
13: 			type: DeviceType.StreamDeckXL,
14: 			isConnected: true,
15: 		} satisfies {
16: 			[K in keyof Device]: Device[K];
17: 		};
18: 	}),
19: };
</file>

<file path="src/plugin/devices/__tests__/service.test.ts">
  1: import type { DeviceDidConnectEvent, DeviceDidDisconnectEvent } from "../..";
  2: import { type DeviceDidConnect, type DeviceDidDisconnect, DeviceType } from "../../../api";
  3: import { type connection as Connection } from "../../connection";
  4: import { Device } from "../device";
  5: import type { DeviceService } from "../service";
  6: jest.mock("../../actions/store", () => {});
  7: jest.mock("../../connection");
  8: jest.mock("../../logging");
  9: jest.mock("../../manifest");
 10: describe("devices", () => {
 11: 	let connection!: typeof Connection;
 12: 	let deviceService!: DeviceService;
 13: 	beforeEach(async () => {
 14: 		jest.resetModules();
 15: 		({ connection } = await require("../../connection"));
 16: 		({ deviceService } = (await require("../service")) as typeof import("../service"));
 17: 	});
 18: 	it("applies callback with forEach", () => {
 19: 		const ev = {
 20: 			event: "deviceDidConnect",
 21: 			device: "devices.test.ts.1",
 22: 			deviceInfo: {
 23: 				name: "Device 1",
 24: 				size: { columns: 8, rows: 4 },
 25: 				type: DeviceType.StreamDeckXL,
 26: 			},
 27: 		} satisfies DeviceDidConnect;
 28: 		connection.emit("connected", connection.registrationParameters.info);
 29: 		connection.emit("deviceDidConnect", ev);
 30: 		const listener = jest.fn();
 31: 		deviceService.forEach(listener);
 32: 		expect(listener).toHaveBeenCalledTimes(2);
 33: 		expect(listener).toHaveBeenNthCalledWith<[Device]>(
 34: 			1,
 35: 			new Device(
 36: 				connection.registrationParameters.info.devices[0].id,
 37: 				connection.registrationParameters.info.devices[0],
 38: 				false,
 39: 			),
 40: 		);
 41: 		expect(listener).toHaveBeenNthCalledWith<[Device]>(2, new Device(ev.device, ev.deviceInfo, true));
 42: 	});
 43: 	it("counts devices", () => {
 44: 		connection.emit("connected", connection.registrationParameters.info);
 45: 		expect(deviceService.length).toBe(1);
 46: 		const ev = {
 47: 			event: "deviceDidConnect",
 48: 			device: "devices.test.ts.1",
 49: 			deviceInfo: {
 50: 				name: "Device 1",
 51: 				size: { columns: 8, rows: 4 },
 52: 				type: DeviceType.StreamDeckXL,
 53: 			},
 54: 		} satisfies DeviceDidConnect;
 55: 		connection.emit("deviceDidConnect", ev);
 56: 		expect(deviceService.length).toBe(2);
 57: 		connection.emit("deviceDidDisconnect", {
 58: 			device: ev.device,
 59: 			event: "deviceDidDisconnect",
 60: 		});
 61: 		expect(deviceService.length).toBe(2);
 62: 	});
 63: 	it("adds devices from registration info", () => {
 64: 		connection.emit("connected", connection.registrationParameters.info);
 65: 		expect(deviceService.length).toBe(1);
 66: 		const [device] = deviceService;
 67: 		expect(device.id).toBe(connection.registrationParameters.info.devices[0].id);
 68: 		expect(device.isConnected).toBeFalsy();
 69: 		expect(device.name).toBe(connection.registrationParameters.info.devices[0].name);
 70: 		expect(device.size).toEqual(connection.registrationParameters.info.devices[0].size);
 71: 		expect(device.type).toBe(connection.registrationParameters.info.devices[0].type);
 72: 	});
 73: 	it("adds device on deviceDidConnect", () => {
 74: 		connection.emit("deviceDidConnect", {
 75: 			event: "deviceDidConnect",
 76: 			device: "__NEW_DEV__",
 77: 			deviceInfo: {
 78: 				name: "New Device",
 79: 				size: {
 80: 					columns: 8,
 81: 					rows: 8,
 82: 				},
 83: 				type: DeviceType.StreamDeckMobile,
 84: 			},
 85: 		});
 86: 		expect(deviceService.length).toBe(1);
 87: 		const [device] = deviceService;
 88: 		expect(device.id).toBe("__NEW_DEV__");
 89: 		expect(device.isConnected).toBeTruthy();
 90: 		expect(device.name).toBe("New Device");
 91: 		expect(device.size?.columns).toBe(8);
 92: 		expect(device.size?.rows).toBe(8);
 93: 		expect(device.type).toBe(DeviceType.StreamDeckMobile);
 94: 	});
 95: 	describe("getDeviceById", () => {
 96: 		it("known identifier", () => {
 97: 			connection.emit("deviceDidConnect", {
 98: 				event: "deviceDidConnect",
 99: 				device: "devices.test.ts.1",
100: 				deviceInfo: {
101: 					name: "New Device",
102: 					size: {
103: 						columns: 8,
104: 						rows: 8,
105: 					},
106: 					type: DeviceType.StreamDeckMobile,
107: 				},
108: 			});
109: 			const device = deviceService.getDeviceById("devices.test.ts.1");
110: 			expect(device).not.toBeUndefined();
111: 			expect(device!.id).toBe("devices.test.ts.1");
112: 			expect(device!.isConnected).toBeTruthy();
113: 			expect(device!.name).toBe("New Device");
114: 			expect(device!.size?.columns).toBe(8);
115: 			expect(device!.size?.rows).toBe(8);
116: 			expect(device!.type).toBe(DeviceType.StreamDeckMobile);
117: 		});
118: 		it("unknown identifier", () => {
119: 			expect(deviceService.getDeviceById("__unknown")).toBeUndefined();
120: 		});
121: 	});
122: 	it("updates device on deviceDidConnect", () => {
123: 		connection.emit("connected", connection.registrationParameters.info);
124: 		const [device] = deviceService;
125: 		expect(device.isConnected).toBeFalsy();
126: 		connection.emit("deviceDidConnect", {
127: 			event: "deviceDidConnect",
128: 			device: connection.registrationParameters.info.devices[0].id,
129: 			deviceInfo: connection.registrationParameters.info.devices[0],
130: 		});
131: 		expect(deviceService.length).toBe(1);
132: 		expect(device.id).toBe(connection.registrationParameters.info.devices[0].id);
133: 		expect(device.isConnected).toBeTruthy();
134: 		expect(device.name).toBe(connection.registrationParameters.info.devices[0].name);
135: 		expect(device.size).toEqual(connection.registrationParameters.info.devices[0].size);
136: 		expect(device.type).toBe(connection.registrationParameters.info.devices[0].type);
137: 	});
138: 	it("updates device on deviceDidDisconnect", () => {
139: 		connection.emit("connected", connection.registrationParameters.info);
140: 		const [device] = deviceService;
141: 		expect(device.isConnected).toBeFalsy();
142: 		connection.emit("deviceDidConnect", {
143: 			event: "deviceDidConnect",
144: 			device: connection.registrationParameters.info.devices[0].id,
145: 			deviceInfo: connection.registrationParameters.info.devices[0],
146: 		});
147: 		expect(device.isConnected).toBeTruthy();
148: 		connection.emit("deviceDidDisconnect", {
149: 			event: "deviceDidDisconnect",
150: 			device: connection.registrationParameters.info.devices[0].id,
151: 		});
152: 		expect(deviceService.length).toBe(1);
153: 		expect(device.id).toBe(connection.registrationParameters.info.devices[0].id);
154: 		expect(device.isConnected).toBeFalsy();
155: 		expect(device.name).toBe(connection.registrationParameters.info.devices[0].name);
156: 		expect(device.size).toEqual(connection.registrationParameters.info.devices[0].size);
157: 		expect(device.type).toBe(connection.registrationParameters.info.devices[0].type);
158: 	});
159: 	it("ignores unknown devices on deviceDidDisconnect", () => {
160: 		connection.emit("connected", connection.registrationParameters.info);
161: 		const [device] = deviceService;
162: 		expect(device.isConnected).toBeFalsy();
163: 		connection.emit("deviceDidDisconnect", {
164: 			event: "deviceDidDisconnect",
165: 			device: "__UNKNOWN_DEVICE__",
166: 		});
167: 		expect(deviceService.length).toBe(1);
168: 		expect(device.id).toBe(connection.registrationParameters.info.devices[0].id);
169: 		expect(device.isConnected).toBeFalsy();
170: 		expect(device.name).toBe(connection.registrationParameters.info.devices[0].name);
171: 		expect(device.size).toEqual(connection.registrationParameters.info.devices[0].size);
172: 		expect(device.type).toBe(connection.registrationParameters.info.devices[0].type);
173: 	});
174: 	it("receives onDeviceDidConnect", () => {
175: 		const listener = jest.fn();
176: 		const ev = {
177: 			device: "device123",
178: 			deviceInfo: {
179: 				name: "Test device",
180: 				size: {
181: 					columns: 8,
182: 					rows: 4,
183: 				},
184: 				type: DeviceType.StreamDeckXL,
185: 			},
186: 			event: "deviceDidConnect",
187: 		} satisfies DeviceDidConnect;
188: 		const disposable = deviceService.onDeviceDidConnect(listener);
189: 		connection.emit("deviceDidConnect", ev);
190: 		expect(listener).toHaveBeenCalledTimes(1);
191: 		expect(listener).toHaveBeenCalledWith<[DeviceDidConnectEvent]>({
192: 			device: new Device(ev.device, ev.deviceInfo, true),
193: 			type: "deviceDidConnect",
194: 		});
195: 		disposable.dispose();
196: 		connection.emit(ev.event, ev as any);
197: 		expect(listener).toHaveBeenCalledTimes(1);
198: 	});
199: 	it("receives onDeviceDidDisconnect", () => {
200: 		connection.emit("connected", connection.registrationParameters.info);
201: 		const listener = jest.fn();
202: 		const ev = {
203: 			device: connection.registrationParameters.info.devices[0].id,
204: 			event: "deviceDidDisconnect",
205: 		} satisfies DeviceDidDisconnect;
206: 		const disposable = deviceService.onDeviceDidDisconnect(listener);
207: 		connection.emit("deviceDidDisconnect", ev);
208: 		expect(listener).toHaveBeenCalledTimes(1);
209: 		expect(listener).toHaveBeenCalledWith<[DeviceDidDisconnectEvent]>({
210: 			device: new Device(
211: 				connection.registrationParameters.info.devices[0].id,
212: 				connection.registrationParameters.info.devices[0],
213: 				false,
214: 			),
215: 			type: "deviceDidDisconnect",
216: 		});
217: 		disposable.dispose();
218: 		connection.emit(ev.event, ev as any);
219: 		expect(listener).toHaveBeenCalledTimes(1);
220: 	});
221: });
</file>

<file path="src/plugin/devices/device.ts">
 1: import type { DeviceInfo, DeviceType, Size } from "../../api";
 2: import type { DialAction } from "../actions/dial";
 3: import type { KeyAction } from "../actions/key";
 4: import { actionStore } from "../actions/store";
 5: import { connection } from "../connection";
 6: export class Device {
 7: 	#isConnected: boolean = false;
 8: 	#info: DeviceInfo;
 9: 	public readonly id: string;
10: 	constructor(id: string, info: DeviceInfo, isConnected: boolean) {
11: 		this.id = id;
12: 		this.#info = info;
13: 		this.#isConnected = isConnected;
14: 		connection.prependListener("deviceDidConnect", (ev) => {
15: 			if (ev.device === this.id) {
16: 				this.#info = ev.deviceInfo;
17: 				this.#isConnected = true;
18: 			}
19: 		});
20: 		connection.prependListener("deviceDidDisconnect", (ev) => {
21: 			if (ev.device === this.id) {
22: 				this.#isConnected = false;
23: 			}
24: 		});
25: 	}
26: 	public get actions(): IterableIterator<DialAction | KeyAction> {
27: 		return actionStore.filter((a) => a.device.id === this.id);
28: 	}
29: 	public get isConnected(): boolean {
30: 		return this.#isConnected;
31: 	}
32: 	public get name(): string {
33: 		return this.#info.name;
34: 	}
35: 	public get size(): Size {
36: 		return this.#info.size;
37: 	}
38: 	public get type(): DeviceType {
39: 		return this.#info.type;
40: 	}
41: }
</file>

<file path="src/plugin/devices/index.ts">
1: export type { Device } from "./device";
2: export type { DeviceService } from "./service";
</file>

<file path="src/plugin/devices/service.ts">
 1: import type { IDisposable } from "../../common/disposable";
 2: import { connection } from "../connection";
 3: import { type DeviceDidConnectEvent, type DeviceDidDisconnectEvent, DeviceEvent } from "../events";
 4: import { Device } from "./device";
 5: import { deviceStore, ReadOnlyDeviceStore } from "./store";
 6: class DeviceService extends ReadOnlyDeviceStore {
 7: 	constructor() {
 8: 		super();
 9: 		connection.once("connected", (info) => {
10: 			info.devices.forEach((dev) => deviceStore.set(new Device(dev.id, dev, false)));
11: 		});
12: 		connection.on("deviceDidConnect", ({ device: id, deviceInfo }) => {
13: 			if (!deviceStore.getDeviceById(id)) {
14: 				deviceStore.set(new Device(id, deviceInfo, true));
15: 			}
16: 		});
17: 	}
18: 	public onDeviceDidConnect(listener: (ev: DeviceDidConnectEvent) => void): IDisposable {
19: 		return connection.disposableOn("deviceDidConnect", (ev) =>
20: 			listener(new DeviceEvent(ev, this.getDeviceById(ev.device)!)),
21: 		);
22: 	}
23: 	public onDeviceDidDisconnect(listener: (ev: DeviceDidDisconnectEvent) => void): IDisposable {
24: 		return connection.disposableOn("deviceDidDisconnect", (ev) =>
25: 			listener(new DeviceEvent(ev, this.getDeviceById(ev.device)!)),
26: 		);
27: 	}
28: }
29: export const deviceService = new DeviceService();
30: export { type DeviceService };
</file>

<file path="src/plugin/devices/store.ts">
 1: import { Enumerable } from "../../common/enumerable";
 2: import type { Device } from "./device";
 3: const __items = new Map<string, Device>();
 4: export class ReadOnlyDeviceStore extends Enumerable<Device> {
 5: 	constructor() {
 6: 		super(__items);
 7: 	}
 8: 	public getDeviceById(deviceId: string): Device | undefined {
 9: 		return __items.get(deviceId);
10: 	}
11: }
12: class DeviceStore extends ReadOnlyDeviceStore {
13: 	public set(device: Device): void {
14: 		__items.set(device.id, device);
15: 	}
16: }
17: export const deviceStore = new DeviceStore();
</file>

<file path="src/plugin/events/__tests__/deep-link-event.test.ts">
 1: import { DeepLinkURL } from "../deep-link-event";
 2: describe("DeepLinkURL", () => {
 3: 	it("parses path", () => {
 4: 		const url = new DeepLinkURL("/hello/world");
 5: 		expect(url.fragment).toBe("");
 6: 		expect(url.href).toBe("/hello/world");
 7: 		expect(url.path).toBe("/hello/world");
 8: 		expect(url.query).toBe("");
 9: 		expect(url.queryParameters.size).toBe(0);
10: 	});
11: 	/**
12: 	 * Asserts all {@link DeepLinkURL} properties are correct when the path and query are specified.
13: 	 */
14: 	it("parses path, and query", () => {
15: 		const url = new DeepLinkURL("/hello?foo=bar");
16: 		expect(url.fragment).toBe("");
17: 		expect(url.href).toBe("/hello?foo=bar");
18: 		expect(url.path).toBe("/hello");
19: 		expect(url.query).toBe("foo=bar");
20: 		expect(url.queryParameters.size).toBe(1);
21: 		expect(url.queryParameters.get("foo")).toBe("bar");
22: 	});
23: 	it("parses path, query, and fragment", () => {
24: 		const url = new DeepLinkURL("/hello?foo=bar#heading");
25: 		expect(url.fragment).toBe("heading");
26: 		expect(url.href).toBe("/hello?foo=bar#heading");
27: 		expect(url.path).toBe("/hello");
28: 		expect(url.query).toBe("foo=bar");
29: 		expect(url.queryParameters.size).toBe(1);
30: 		expect(url.queryParameters.get("foo")).toBe("bar");
31: 	});
32: 	it("parses query", () => {
33: 		const url = new DeepLinkURL("/?foo=bar");
34: 		expect(url.fragment).toBe("");
35: 		expect(url.href).toBe("/?foo=bar");
36: 		expect(url.path).toBe("/");
37: 		expect(url.query).toBe("foo=bar");
38: 		expect(url.queryParameters.size).toBe(1);
39: 		expect(url.queryParameters.get("foo")).toBe("bar");
40: 	});
41: 	it("parses query, and fragment", () => {
42: 		const url = new DeepLinkURL("/?foo=bar#heading");
43: 		expect(url.fragment).toBe("heading");
44: 		expect(url.href).toBe("/?foo=bar#heading");
45: 		expect(url.path).toBe("/");
46: 		expect(url.query).toBe("foo=bar");
47: 		expect(url.queryParameters.size).toBe(1);
48: 		expect(url.queryParameters.get("foo")).toBe("bar");
49: 	});
50: 	it("parses fragment", () => {
51: 		const url = new DeepLinkURL("/#heading");
52: 		expect(url.fragment).toBe("heading");
53: 		expect(url.href).toBe("/#heading");
54: 		expect(url.path).toBe("/");
55: 		expect(url.query).toBe("");
56: 		expect(url.queryParameters.size).toBe(0);
57: 	});
58: 	/**
59: 	 * Asserts all {@link DeepLinkURL} properties are correct when the the fragment's number sign (#) is specified before the query's question mark (?).
60: 	 */
61: 	it("parses path when fragment is before query", () => {
62: 		const url = new DeepLinkURL("/hello#?heading");
63: 		expect(url.fragment).toBe("?heading");
64: 		expect(url.href).toBe("/hello#?heading");
65: 		expect(url.path).toBe("/hello");
66: 		expect(url.query).toBe("");
67: 		expect(url.queryParameters.size).toBe(0);
68: 	});
69: });
</file>

<file path="src/plugin/events/application-event.ts">
1: import type { ApplicationDidLaunch, ApplicationDidTerminate } from "../../api";
2: import { Event } from "../../common/events";
3: export class ApplicationEvent<T extends ApplicationDidLaunch | ApplicationDidTerminate> extends Event<T> {
4: 	public readonly application: string;
5: 	constructor(source: T) {
6: 		super(source);
7: 		this.application = source.payload.application;
8: 	}
9: }
</file>

<file path="src/plugin/events/deep-link-event.ts">
 1: import type { DidReceiveDeepLink } from "../../api";
 2: import { Event } from "../../common/events";
 3: export class DidReceiveDeepLinkEvent extends Event<DidReceiveDeepLink> {
 4: 	public readonly url: DeepLinkURL;
 5: 	constructor(source: DidReceiveDeepLink) {
 6: 		super(source);
 7: 		this.url = new DeepLinkURL(source.payload.url);
 8: 	}
 9: }
10: const PREFIX = "streamdeck://";
11: export class DeepLinkURL {
12: 	public readonly fragment: string;
13: 	public readonly href: string;
14: 	public readonly path: string;
15: 	public readonly query: string;
16: 	public readonly queryParameters: URLSearchParams;
17: 	constructor(url: string) {
18: 		const refUrl = new URL(`${PREFIX}${url}`);
19: 		this.fragment = refUrl.hash.substring(1);
20: 		this.href = refUrl.href.substring(PREFIX.length);
21: 		this.path = DeepLinkURL.parsePath(this.href);
22: 		this.query = refUrl.search.substring(1);
23: 		this.queryParameters = refUrl.searchParams;
24: 	}
25: 	private static parsePath(href: string): string {
26: 		const indexOf = (char: string): number => {
27: 			const index = href.indexOf(char);
28: 			return index >= 0 ? index : href.length;
29: 		};
30: 		return href.substring(0, Math.min(indexOf("?"), indexOf("#")));
31: 	}
32: }
</file>

<file path="src/plugin/events/device-event.ts">
 1: import type { DeviceDidConnect, DeviceDidDisconnect } from "../../api";
 2: import { Event } from "../../common/events";
 3: export class DeviceEvent<T extends DeviceDidConnect | DeviceDidDisconnect, TDevice> extends Event<T> {
 4: 	constructor(
 5: 		source: T,
 6: 		public readonly device: TDevice,
 7: 	) {
 8: 		super(source);
 9: 	}
10: }
</file>

<file path="src/plugin/events/index.ts">
 1: import type {
 2: 	ApplicationDidLaunch,
 3: 	ApplicationDidTerminate,
 4: 	DeviceDidConnect,
 5: 	DeviceDidDisconnect,
 6: 	DialDown,
 7: 	DialRotate,
 8: 	DialUp,
 9: 	DidReceiveSettings,
10: 	KeyDown,
11: 	KeyUp,
12: 	PropertyInspectorDidAppear,
13: 	PropertyInspectorDidDisappear,
14: 	SystemDidWakeUp,
15: 	TitleParametersDidChange,
16: 	TouchTap,
17: 	WillAppear,
18: 	WillDisappear,
19: } from "../../api";
20: import { type ActionEvent, ActionWithoutPayloadEvent, Event } from "../../common/events";
21: import type { JsonObject } from "../../common/json";
22: import type { ActionContext } from "../actions/context";
23: import type { DialAction } from "../actions/dial";
24: import type { KeyAction } from "../actions/key";
25: import type { Device } from "../devices";
26: import { ApplicationEvent } from "./application-event";
27: import { DeviceEvent } from "./device-event";
28: export { DidReceiveGlobalSettingsEvent } from "../../common/events";
29: export { DidReceiveDeepLinkEvent } from "./deep-link-event";
30: export { SendToPluginEvent } from "./ui-message-event";
31: export { ApplicationEvent, DeviceEvent, Event };
32: export type ApplicationDidLaunchEvent = ApplicationEvent<ApplicationDidLaunch>;
33: export type ApplicationDidTerminateEvent = ApplicationEvent<ApplicationDidTerminate>;
34: export type DeviceDidConnectEvent = DeviceEvent<DeviceDidConnect, Required<Device>>;
35: export type DeviceDidDisconnectEvent = DeviceEvent<DeviceDidDisconnect, Device>;
36: export type DialDownEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
37: 	DialDown<TSettings>,
38: 	DialAction<TSettings>
39: >;
40: export type DialRotateEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
41: 	DialRotate<TSettings>,
42: 	DialAction<TSettings>
43: >;
44: export type DialUpEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
45: 	DialUp<TSettings>,
46: 	DialAction<TSettings>
47: >;
48: export type DidReceiveSettingsEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
49: 	DidReceiveSettings<TSettings>,
50: 	DialAction<TSettings> | KeyAction<TSettings>
51: >;
52: export type KeyDownEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
53: 	KeyDown<TSettings>,
54: 	KeyAction<TSettings>
55: >;
56: export type KeyUpEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<KeyUp<TSettings>, KeyAction<TSettings>>;
57: export type PropertyInspectorDidAppearEvent<TSettings extends JsonObject = JsonObject> = ActionWithoutPayloadEvent<
58: 	PropertyInspectorDidAppear,
59: 	DialAction<TSettings> | KeyAction<TSettings>
60: >;
61: export type PropertyInspectorDidDisappearEvent<TSettings extends JsonObject = JsonObject> = ActionWithoutPayloadEvent<
62: 	PropertyInspectorDidDisappear,
63: 	DialAction<TSettings> | KeyAction<TSettings>
64: >;
65: export type TitleParametersDidChangeEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
66: 	TitleParametersDidChange<TSettings>,
67: 	DialAction<TSettings> | KeyAction<TSettings>
68: >;
69: export type SystemDidWakeUpEvent = Event<SystemDidWakeUp>;
70: export type TouchTapEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
71: 	TouchTap<TSettings>,
72: 	DialAction<TSettings>
73: >;
74: export type WillAppearEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
75: 	WillAppear<TSettings>,
76: 	DialAction<TSettings> | KeyAction<TSettings>
77: >;
78: export type WillDisappearEvent<TSettings extends JsonObject = JsonObject> = ActionEvent<
79: 	WillDisappear<TSettings>,
80: 	ActionContext
81: >;
</file>

<file path="src/plugin/events/ui-message-event.ts">
 1: import type { DidReceivePropertyInspectorMessage } from "../../api";
 2: import { Event } from "../../common/events";
 3: import type { JsonObject, JsonValue } from "../../common/json";
 4: import type { Action } from "../actions/action";
 5: export class SendToPluginEvent<TPayload extends JsonValue, TSettings extends JsonObject> extends Event<
 6: 	DidReceivePropertyInspectorMessage<TPayload>
 7: > {
 8: 	public payload: TPayload;
 9: 	constructor(
10: 		public readonly action: Action<TSettings>,
11: 		source: DidReceivePropertyInspectorMessage<TPayload>,
12: 	) {
13: 		super(source);
14: 		this.payload = source.payload;
15: 	}
16: }
</file>

<file path="src/plugin/logging/__mocks__/index.ts">
1: import { Logger, type LoggerOptions, LogLevel } from "../../../common/logging";
2: const options: LoggerOptions = {
3: 	level: LogLevel.TRACE,
4: 	targets: [{ write: jest.fn() }],
5: };
6: export const logger = new Logger(options);
</file>

<file path="src/plugin/logging/__tests__/file-target.test.ts">
  1: import fs, { Dirent } from "node:fs";
  2: import path from "node:path";
  3: import { LogLevel } from "../../../common/logging";
  4: import { FileTarget, FileTargetOptions } from "../file-target";
  5: jest.mock("node:fs");
  6: describe("FileTarget", () => {
  7: 	afterEach(() => jest.resetAllMocks());
  8: 	it("writes the formatted message", async () => {
  9: 		const mockedFileDescriptor = 13;
 10: 		jest.spyOn(fs, "existsSync").mockReturnValue(false);
 11: 		jest.spyOn(fs, "openSync").mockReturnValue(mockedFileDescriptor);
 12: 		const format = jest.fn().mockReturnValue("Hello world");
 13: 		const options: FileTargetOptions = {
 14: 			dest: path.join("home", "test", "logs"),
 15: 			fileName: "com.elgato.test",
 16: 			format,
 17: 			maxFileCount: 1,
 18: 			maxSize: 1024 * 10 * 10,
 19: 		};
 20: 		const fileTarget = new FileTarget(options);
 21: 		const entry = {
 22: 			level: LogLevel.INFO,
 23: 			data: ["Hello world"],
 24: 			scope: "Test->Logger",
 25: 		};
 26: 		fileTarget.write(entry);
 27: 		expect(format).toHaveBeenCalledTimes(1);
 28: 		expect(format).toHaveBeenCalledWith(entry);
 29: 		expect(fs.openSync).toHaveBeenCalledTimes(1);
 30: 		expect(fs.openSync).toHaveBeenNthCalledWith(1, path.join(options.dest, "com.elgato.test.0.log"), "a");
 31: 		expect(fs.writeSync).toHaveBeenCalledTimes(1);
 32: 		expect(fs.writeSync).toHaveBeenCalledWith(mockedFileDescriptor, "Hello world\n");
 33: 		expect(fs.closeSync).toHaveBeenCalledTimes(1);
 34: 		expect(fs.closeSync).toHaveBeenCalledWith(mockedFileDescriptor);
 35: 	});
 36: 	describe("Re-indexing", () => {
 37: 		it("Occurs on construction", async () => {
 38: 			jest.spyOn(fs, "existsSync").mockReturnValue(true);
 39: 			jest.spyOn(fs, "readdirSync").mockReturnValue([
 40: 				mockDirent("__com.elgato.test.0.log"),
 41: 				mockDirent("com.elgato.test.0.log"),
 42: 				mockDirent("com.elgato.test.log"),
 43: 				mockDirent("com.elgato.test.4.log"),
 44: 				mockDirent("com.elgato.test.5.log"),
 45: 				mockDirent("com.elgato.other.0.log"),
 46: 				mockDirent("com.elgato.test.0.log", true),
 47: 				mockDirent("com.elgato.test.1.log"),
 48: 			]);
 49: 			const options: FileTargetOptions = {
 50: 				dest: path.join("home", "test", "logs"),
 51: 				fileName: "com.elgato.test",
 52: 				format: jest.fn(),
 53: 				maxFileCount: 3,
 54: 				maxSize: 100,
 55: 			};
 56: 			new FileTarget(options);
 57: 			expect(fs.rmSync).toHaveBeenCalledTimes(2);
 58: 			expect(fs.rmSync).toHaveBeenNthCalledWith(1, path.join(options.dest, "com.elgato.test.5.log"));
 59: 			expect(fs.rmSync).toHaveBeenNthCalledWith(2, path.join(options.dest, "com.elgato.test.4.log"));
 60: 			expect(fs.renameSync).toHaveBeenCalledTimes(2);
 61: 			expect(fs.renameSync).toHaveBeenNthCalledWith(
 62: 				1,
 63: 				path.join(options.dest, "com.elgato.test.1.log"),
 64: 				path.join(options.dest, "com.elgato.test.2.log"),
 65: 			);
 66: 			expect(fs.renameSync).toHaveBeenNthCalledWith(
 67: 				2,
 68: 				path.join(options.dest, "com.elgato.test.0.log"),
 69: 				path.join(options.dest, "com.elgato.test.1.log"),
 70: 			);
 71: 		});
 72: 		it("Occurs when size exceeded", async () => {
 73: 			const dirEntries = [mockDirent("com.elgato.test.0.log"), mockDirent("com.elgato.test.1.log")];
 74: 			jest.spyOn(fs, "existsSync").mockReturnValue(true);
 75: 			jest.spyOn(fs, "readdirSync").mockReturnValueOnce(dirEntries);
 76: 			jest.spyOn(fs, "readdirSync").mockReturnValueOnce([...dirEntries, mockDirent("com.elgato.test.2.log")]);
 77: 			const options: FileTargetOptions = {
 78: 				dest: path.join("home", "test", "logs"),
 79: 				fileName: "com.elgato.test",
 80: 				format: jest.fn().mockReturnValue("x".repeat(10)),
 81: 				maxFileCount: 3,
 82: 				maxSize: 29,
 83: 			};
 84: 			const fileTarget = new FileTarget(options);
 85: 			const entry = {
 86: 				level: LogLevel.ERROR,
 87: 				data: [],
 88: 				scope: "",
 89: 			};
 90: 			fileTarget.write(entry);
 91: 			fileTarget.write(entry);
 92: 			fileTarget.write(entry);
 93: 			expect(fs.rmSync).toHaveBeenCalledTimes(1);
 94: 			expect(fs.rmSync).toHaveBeenLastCalledWith(path.join(options.dest, "com.elgato.test.2.log"));
 95: 			expect(fs.renameSync).toHaveBeenCalledTimes(4);
 96: 			expect(fs.renameSync).nthCalledWith(
 97: 				3,
 98: 				path.join(options.dest, "com.elgato.test.1.log"),
 99: 				path.join(options.dest, "com.elgato.test.2.log"),
100: 			);
101: 			expect(fs.renameSync).nthCalledWith(
102: 				4,
103: 				path.join(options.dest, "com.elgato.test.0.log"),
104: 				path.join(options.dest, "com.elgato.test.1.log"),
105: 			);
106: 		});
107: 	});
108: 	function mockDirent(name: string, isDirectory = false) {
109: 		return {
110: 			name,
111: 			isDirectory: jest.fn().mockReturnValue(isDirectory),
112: 		} as unknown as Dirent;
113: 	}
114: });
</file>

<file path="src/plugin/logging/__tests__/index.test.ts">
 1: import path from "node:path";
 2: import { type LoggerOptions, LogLevel } from "../../../common/logging";
 3: import { ConsoleTarget } from "../../../common/logging/console-target";
 4: import { type FileTargetOptions } from "../file-target";
 5: jest.mock("../file-target");
 6: jest.mock("../../../common/logging");
 7: jest.mock("../../common/utils");
 8: describe("createLogger", () => {
 9: 	const mockedCwd = path.join("stream-deck", "tests");
10: 	let utils: typeof import("../../common/utils");
11: 	beforeEach(async () => {
12: 		jest.spyOn(process, "cwd").mockReturnValue(mockedCwd);
13: 		utils = await require("../../common/utils");
14: 		jest.spyOn(utils, "getPluginUUID").mockReturnValue("com.elgato.test");
15: 	});
16: 	afterEach(() => {
17: 		jest.resetModules();
18: 		jest.resetAllMocks();
19: 	});
20: 	describe("default log level", () => {
21: 		it("is DEBUG when isDebugMode() is true", async () => {
22: 			jest.spyOn(utils, "isDebugMode").mockReturnValue(true);
23: 			const spyOnFileTarget = jest.spyOn(await require("../file-target"), "FileTarget");
24: 			const { Logger } = await require("../../../common/logging");
25: 			await require("../index");
26: 			expect(spyOnFileTarget).toHaveBeenCalledTimes(1);
27: 			expect(Logger).toHaveBeenCalledWith<[LoggerOptions]>({
28: 				level: LogLevel.DEBUG,
29: 				minimumLevel: LogLevel.TRACE,
30: 				targets: [expect.any(ConsoleTarget), spyOnFileTarget.mock.instances[0]],
31: 			});
32: 		});
33: 		it("is INFO when isDebugMode() is false", async () => {
34: 			jest.spyOn(utils, "isDebugMode").mockReturnValue(false);
35: 			const spyOnFileTarget = jest.spyOn(await require("../file-target"), "FileTarget");
36: 			const { Logger } = await require("../../../common/logging");
37: 			await require("../index");
38: 			expect(Logger).toHaveBeenCalledWith<[LoggerOptions]>({
39: 				level: LogLevel.INFO,
40: 				minimumLevel: LogLevel.DEBUG,
41: 				targets: [spyOnFileTarget.mock.instances[0]],
42: 			});
43: 		});
44: 	});
45: 	it("initializes the file target from the cwd", async () => {
46: 		jest.spyOn(utils, "isDebugMode").mockReturnValue(false);
47: 		const { FileTarget } = (await require("../file-target")) as typeof import("../file-target");
48: 		const { stringFormatter } = (await require("../../../common/logging")) as typeof import("../../../common/logging");
49: 		await require("../index");
50: 		expect(FileTarget).toHaveBeenLastCalledWith<[FileTargetOptions]>({
51: 			dest: path.join(mockedCwd, "logs"),
52: 			fileName: "com.elgato.test",
53: 			format: stringFormatter(),
54: 			maxFileCount: 10,
55: 			maxSize: 50 * 1024 * 1024,
56: 		});
57: 	});
58: 	it("logs when an uncaught exception is thrown", async () => {
59: 		const spyOnProcessOnce = jest.spyOn(process, "once");
60: 		const { logger } = await require("../index");
61: 		const spyOnLogger = jest.spyOn(logger, "error");
62: 		const err = new Error("Hello world");
63: 		spyOnProcessOnce.mock.calls[0][1](err);
64: 		expect(spyOnProcessOnce).toHaveBeenCalledTimes(1);
65: 		expect(spyOnProcessOnce).toHaveBeenCalledWith("uncaughtException", expect.any(Function));
66: 		expect(spyOnLogger).toHaveBeenCalledTimes(1);
67: 		expect(spyOnLogger).toHaveBeenCalledWith<[string, Error]>("Process encountered uncaught exception", err);
68: 	});
69: 	describe("exports", () => {
70: 		test("LogLevel", async () => {
71: 			const { LogLevel } = await require("../index");
72: 			expect(LogLevel).toBe(LogLevel);
73: 		});
74: 		test("Logger", async () => {
75: 			const { Logger } = await require("../index");
76: 			expect(Logger).toBe(Logger);
77: 		});
78: 	});
79: });
</file>

<file path="src/plugin/logging/file-target.ts">
 1: import fs, { Dirent } from "node:fs";
 2: import path from "node:path";
 3: import { type LogEntry, type LogEntryFormatter, type LogTarget } from "../../common/logging";
 4: export class FileTarget implements LogTarget {
 5: 	private readonly filePath: string;
 6: 	private size = 0;
 7: 	constructor(private readonly options: FileTargetOptions) {
 8: 		this.filePath = this.getLogFilePath();
 9: 		this.reIndex();
10: 	}
11: 	public write(entry: LogEntry): void {
12: 		const fd = fs.openSync(this.filePath, "a");
13: 		try {
14: 			const msg = this.options.format(entry);
15: 			fs.writeSync(fd, msg + "\n");
16: 			this.size += msg.length;
17: 		} finally {
18: 			fs.closeSync(fd);
19: 		}
20: 		if (this.size >= this.options.maxSize) {
21: 			this.reIndex();
22: 			this.size = 0;
23: 		}
24: 	}
25: 	private getLogFilePath(index = 0): string {
26: 		return path.join(this.options.dest, `${this.options.fileName}.${index}.log`);
27: 	}
28: 	private getLogFiles(): LogFileEntry[] {
29: 		const regex = /^\.(\d+)\.log$/;
30: 		return fs
31: 			.readdirSync(this.options.dest, { withFileTypes: true })
32: 			.reduce((prev: LogFileEntry[], entry: Dirent) => {
33: 				if (entry.isDirectory() || entry.name.indexOf(this.options.fileName) < 0) {
34: 					return prev;
35: 				}
36: 				const match = entry.name.substring(this.options.fileName.length).match(regex);
37: 				if (match?.length !== 2) {
38: 					return prev;
39: 				}
40: 				prev.push({
41: 					path: path.join(this.options.dest, entry.name),
42: 					index: parseInt(match[1]),
43: 				});
44: 				return prev;
45: 			}, [])
46: 			.sort(({ index: a }, { index: b }) => {
47: 				return a < b ? -1 : a > b ? 1 : 0;
48: 			});
49: 	}
50: 	private reIndex(): void {
51: 		if (!fs.existsSync(this.options.dest)) {
52: 			fs.mkdirSync(this.options.dest);
53: 			return;
54: 		}
55: 		const logFiles = this.getLogFiles();
56: 		for (let i = logFiles.length - 1; i >= 0; i--) {
57: 			const log = logFiles[i];
58: 			if (i >= this.options.maxFileCount - 1) {
59: 				fs.rmSync(log.path);
60: 			} else {
61: 				fs.renameSync(log.path, this.getLogFilePath(i + 1));
62: 			}
63: 		}
64: 	}
65: }
66: type LogFileEntry = {
67: 	index: number;
68: 	path: string;
69: };
70: export type FileTargetOptions = {
71: 	dest: string;
72: 	fileName: string;
73: 	format: LogEntryFormatter;
74: 	maxFileCount: number;
75: 	maxSize: number;
76: };
</file>

<file path="src/plugin/logging/index.ts">
 1: import path from "node:path";
 2: import { cwd } from "node:process";
 3: import { Logger, LogLevel, type LogTarget, stringFormatter } from "../../common/logging";
 4: import { ConsoleTarget } from "../../common/logging/console-target";
 5: import { getPluginUUID, isDebugMode } from "../common/utils";
 6: import { FileTarget } from "./file-target";
 7: const fileTarget = new FileTarget({
 8: 	dest: path.join(cwd(), "logs"),
 9: 	fileName: getPluginUUID(),
10: 	format: stringFormatter(),
11: 	maxFileCount: 10,
12: 	maxSize: 50 * 1024 * 1024,
13: });
14: const targets: LogTarget[] = [fileTarget];
15: if (isDebugMode()) {
16: 	targets.splice(0, 0, new ConsoleTarget());
17: }
18: export const logger = new Logger({
19: 	level: isDebugMode() ? LogLevel.DEBUG : LogLevel.INFO,
20: 	minimumLevel: isDebugMode() ? LogLevel.TRACE : LogLevel.DEBUG,
21: 	targets,
22: });
23: process.once("uncaughtException", (err) => logger.error("Process encountered uncaught exception", err));
</file>

<file path="src/plugin/ui/__mocks__/router.ts">
1: export const { router } = jest.requireActual("../router") as typeof import("../router");
2: export const getCurrentUI = jest.fn();
</file>

<file path="src/plugin/ui/__tests__/controller.test.ts">
  1: import type {
  2: 	DidReceivePropertyInspectorMessage,
  3: 	PropertyInspectorDidAppear,
  4: 	PropertyInspectorDidDisappear,
  5: } from "../../../api";
  6: import { Settings } from "../../../api/__mocks__/events";
  7: import { actionStore } from "../../actions/store";
  8: import { connection } from "../../connection";
  9: import {
 10: 	PropertyInspectorDidAppearEvent,
 11: 	type PropertyInspectorDidDisappearEvent,
 12: 	SendToPluginEvent,
 13: } from "../../events";
 14: import { ui } from "../controller";
 15: import { PropertyInspector } from "../property-inspector";
 16: import * as RouterModule from "../router";
 17: jest.mock("../router");
 18: jest.mock("../../actions/store");
 19: jest.mock("../../connection");
 20: jest.mock("../../logging");
 21: jest.mock("../../manifest");
 22: describe("UIController", () => {
 23: 	it("gets current", () => {
 24: 		const pi = new PropertyInspector(RouterModule.router, {
 25: 			action: "com.elgato.test.one",
 26: 			context: "key123",
 27: 			device: "dev123",
 28: 		});
 29: 		const spyOnGetCurrentUI = jest.spyOn(RouterModule, "getCurrentUI").mockReturnValue(pi);
 30: 		const current = ui.current;
 31: 		expect(spyOnGetCurrentUI).toHaveBeenCalledTimes(1);
 32: 		expect(current).toBe(pi);
 33: 	});
 34: 	it("receives onDidAppear", () => {
 35: 		const listener = jest.fn();
 36: 		const ev = {
 37: 			action: "com.elgato.test.one",
 38: 			context: "key123",
 39: 			device: "device123",
 40: 			event: "propertyInspectorDidAppear",
 41: 		} satisfies PropertyInspectorDidAppear;
 42: 		const disposable = ui.onDidAppear(listener);
 43: 		connection.emit("propertyInspectorDidAppear", ev);
 44: 		expect(listener).toHaveBeenCalledTimes(1);
 45: 		expect(listener).toHaveBeenCalledWith<[PropertyInspectorDidAppearEvent<Settings>]>({
 46: 			action: actionStore.getActionById(ev.context)!,
 47: 			type: "propertyInspectorDidAppear",
 48: 		});
 49: 		disposable.dispose();
 50: 		connection.emit(ev.event, ev as any);
 51: 		expect(listener).toHaveBeenCalledTimes(1);
 52: 	});
 53: 	it("receives onDidDisappear", () => {
 54: 		const listener = jest.fn();
 55: 		const ev = {
 56: 			action: "com.elgato.test.one",
 57: 			context: "key123",
 58: 			device: "device123",
 59: 			event: "propertyInspectorDidDisappear",
 60: 		} satisfies PropertyInspectorDidDisappear;
 61: 		const disposable = ui.onDidDisappear(listener);
 62: 		connection.emit("propertyInspectorDidDisappear", ev);
 63: 		expect(listener).toHaveBeenCalledTimes(1);
 64: 		expect(listener).toHaveBeenCalledWith<[PropertyInspectorDidDisappearEvent<Settings>]>({
 65: 			action: actionStore.getActionById(ev.context)!,
 66: 			type: "propertyInspectorDidDisappear",
 67: 		});
 68: 		disposable.dispose();
 69: 		connection.emit(ev.event, ev as any);
 70: 		expect(listener).toHaveBeenCalledTimes(1);
 71: 	});
 72: 	it("receives onSendToPlugin", () => {
 73: 		const listener = jest.fn();
 74: 		const ev = {
 75: 			action: "com.elgato.test.one",
 76: 			context: "key123",
 77: 			event: "sendToPlugin",
 78: 			payload: {
 79: 				name: "Hello world",
 80: 			},
 81: 		} satisfies DidReceivePropertyInspectorMessage<Settings>;
 82: 		const disposable = ui.onSendToPlugin(listener);
 83: 		connection.emit("sendToPlugin", ev);
 84: 		expect(listener).toHaveBeenCalledTimes(1);
 85: 		expect(listener).toHaveBeenCalledWith<[SendToPluginEvent<Settings, Settings>]>({
 86: 			action: actionStore.getActionById(ev.context)!,
 87: 			payload: {
 88: 				name: "Hello world",
 89: 			},
 90: 			type: "sendToPlugin",
 91: 		});
 92: 		disposable.dispose();
 93: 		connection.emit(ev.event, ev as any);
 94: 		expect(listener).toHaveBeenCalledTimes(1);
 95: 	});
 96: 	it("registerRoute", () => {
 97: 		const spyOnRoute = jest.spyOn(RouterModule.router, "route");
 98: 		const handler = jest.fn();
 99: 		const options = {
100: 			filter: () => true,
101: 		};
102: 		ui.registerRoute("/register", handler, options);
103: 		expect(spyOnRoute).toHaveBeenCalledTimes(1);
104: 		expect(spyOnRoute).toHaveBeenCalledWith("public:/register", handler, options);
105: 	});
106: });
</file>

<file path="src/plugin/ui/__tests__/property-inspector.test.ts">
 1: import type { SendToPropertyInspector } from "../../../api";
 2: import type { JsonValue } from "../../../common/json";
 3: import type { MessageRequestOptions } from "../../../common/messaging";
 4: import { actionStore } from "../../actions/store";
 5: import { connection } from "../../connection";
 6: import { PropertyInspector } from "../property-inspector";
 7: import { router } from "../router";
 8: jest.mock("../../actions/store");
 9: jest.mock("../../connection");
10: jest.mock("../../logging");
11: jest.mock("../../manifest");
12: describe("PropertyInspector", () => {
13: 	it("initializes context", () => {
14: 		const pi = new PropertyInspector(router, {
15: 			action: "com.elgato.test.key",
16: 			context: "key123",
17: 			device: "dev123",
18: 		});
19: 		expect(actionStore.getActionById).toHaveBeenCalledTimes(1);
20: 		expect(actionStore.getActionById).toHaveBeenLastCalledWith("key123");
21: 		expect(pi.action).toEqual(actionStore.getActionById("key123"));
22: 	});
23: 	describe("fetch", () => {
24: 		test("path and body", async () => {
25: 			const spyOnFetch = jest.spyOn(router, "fetch");
26: 			const pi = new PropertyInspector(router, {
27: 				action: "com.elgato.test.key",
28: 				context: "abc123",
29: 				device: "dev123",
30: 			});
31: 			await pi.fetch("/hello", { name: "Elgato" });
32: 			expect(spyOnFetch).toBeCalledTimes(1);
33: 			expect(spyOnFetch).toHaveBeenLastCalledWith<[string, JsonValue]>("public:/hello", { name: "Elgato" });
34: 		});
35: 		test("request", async () => {
36: 			const spyOnFetch = jest.spyOn(router, "fetch");
37: 			const pi = new PropertyInspector(router, {
38: 				action: "com.elgato.test.key",
39: 				context: "abc123",
40: 				device: "dev123",
41: 			});
42: 			await pi.fetch({
43: 				path: "/hello",
44: 				body: { name: "Elgato" },
45: 				timeout: 1000,
46: 				unidirectional: true,
47: 			});
48: 			expect(spyOnFetch).toBeCalledTimes(1);
49: 			expect(spyOnFetch).toHaveBeenLastCalledWith<[MessageRequestOptions]>({
50: 				path: "public:/hello",
51: 				body: { name: "Elgato" },
52: 				timeout: 1000,
53: 				unidirectional: true,
54: 			});
55: 		});
56: 	});
57: 	it("sends payloads (legacy)", async () => {
58: 		const spyOnSend = jest.spyOn(connection, "send");
59: 		const pi = new PropertyInspector(router, {
60: 			action: "com.elgato.test.key",
61: 			context: "key123",
62: 			device: "dev123",
63: 		});
64: 		await pi.sendToPropertyInspector({ message: "Hello world" });
65: 		expect(spyOnSend).toBeCalledTimes(1);
66: 		expect(spyOnSend).toHaveBeenLastCalledWith<[SendToPropertyInspector]>({
67: 			context: "key123",
68: 			event: "sendToPropertyInspector",
69: 			payload: {
70: 				message: "Hello world",
71: 			},
72: 		});
73: 	});
74: });
</file>

<file path="src/plugin/ui/__tests__/route.test.ts">
  1: import type { MessageRequest } from "../";
  2: import type { PluginCommand, SendToPropertyInspector } from "../../../api";
  3: import type { JsonObject } from "../../../common/json";
  4: import { MessageGateway, MessageResponder } from "../../../common/messaging";
  5: import { PromiseCompletionSource } from "../../../common/promises";
  6: import { action } from "../../actions";
  7: import { SingletonAction } from "../../actions/singleton-action";
  8: import { actionStore } from "../../actions/store";
  9: import { connection } from "../../connection";
 10: import { route } from "../route";
 11: jest.mock("../../actions/store");
 12: jest.mock("../../connection");
 13: jest.mock("../../logging");
 14: jest.mock("../../manifest");
 15: describe("route", () => {
 16: 	let piRouter: MessageGateway<object>;
 17: 	describe("current PI has routes", () => {
 18: 		const ev = {
 19: 			action: "com.elgato.test.key",
 20: 			context: "key123",
 21: 		};
 22: 		beforeEach(() => initialize(ev.context));
 23: 		test("async", async () => {
 24: 			const awaiter = new PromiseCompletionSource();
 25: 			const action = new ActionWithRoutes();
 26: 			action.spyOnGetCharacters.mockImplementation(() => awaiter.setResult(true));
 27: 			const res = await piRouter.fetch("public:/characters", {
 28: 				game: "World of Warcraft",
 29: 			});
 30: 			await awaiter.promise;
 31: 			expect(action.spyOnGetCharacters).toHaveBeenCalledTimes(1);
 32: 			expect(action.spyOnGetCharacters).toHaveBeenLastCalledWith<[MessageRequest<Filter>, MessageResponder]>(
 33: 				{
 34: 					action: actionStore.getActionById(ev.context)!,
 35: 					path: "public:/characters",
 36: 					unidirectional: false,
 37: 					body: {
 38: 						game: "World of Warcraft",
 39: 					},
 40: 				},
 41: 				expect.any(MessageResponder),
 42: 			);
 43: 			expect(res.status).toBe(200);
 44: 			expect(res.ok).toBe(true);
 45: 			expect(res.body).toEqual(["Anduin", "Sylvanas", "Thrall"]);
 46: 		});
 47: 		test("sync", async () => {
 48: 			const awaiter = new PromiseCompletionSource();
 49: 			const action = new ActionWithRoutes();
 50: 			action.spyOnGetCharactersSync.mockImplementation(() => awaiter.setResult(true));
 51: 			const res = await piRouter.fetch("public:/characters-sync", {
 52: 				game: "Mario World",
 53: 			});
 54: 			await awaiter.promise;
 55: 			expect(action.spyOnGetCharactersSync).toHaveBeenCalledTimes(1);
 56: 			expect(action.spyOnGetCharactersSync).toHaveBeenLastCalledWith<[MessageRequest<Filter>, MessageResponder]>(
 57: 				{
 58: 					action: actionStore.getActionById(ev.context)!,
 59: 					path: "public:/characters-sync",
 60: 					unidirectional: false,
 61: 					body: {
 62: 						game: "Mario World",
 63: 					},
 64: 				},
 65: 				expect.any(MessageResponder),
 66: 			);
 67: 			expect(res.status).toBe(200);
 68: 			expect(res.ok).toBe(true);
 69: 			expect(res.body).toEqual(["Mario", "Luigi", "Peach"]);
 70: 		});
 71: 		test("void", async () => {
 72: 			const action = new ActionWithRoutes();
 73: 			const res = await piRouter.fetch("public:/save");
 74: 			expect(action.spyOnSave).toHaveBeenCalledTimes(1);
 75: 			expect(action.spyOnSave).toHaveBeenLastCalledWith<[MessageRequest<Filter>, MessageResponder]>(
 76: 				{
 77: 					action: actionStore.getActionById(ev.context)!,
 78: 					path: "public:/save",
 79: 					unidirectional: false,
 80: 					body: undefined,
 81: 				},
 82: 				expect.any(MessageResponder),
 83: 			);
 84: 			expect(res.status).toBe(200);
 85: 			expect(res.ok).toBe(true);
 86: 			expect(res.body).toBeUndefined();
 87: 		});
 88: 	});
 89: 	describe("current PI does not have routes", () => {
 90: 		beforeEach(() => initialize("dial123"));
 91: 		test("async", async () => {
 92: 			const action = new ActionWithRoutes();
 93: 			const res = await piRouter.fetch("public:/characters", {
 94: 				game: "World of Warcraft",
 95: 			});
 96: 			expect(action.spyOnGetCharacters).toHaveBeenCalledTimes(0);
 97: 			expect(res.status).toBe(501);
 98: 			expect(res.ok).toBe(false);
 99: 			expect(res.body).toBeUndefined();
100: 		});
101: 		test("sync", async () => {
102: 			const action = new ActionWithRoutes();
103: 			const res = await piRouter.fetch("public:/characters-sync", {
104: 				game: "Mario World",
105: 			});
106: 			expect(action.spyOnGetCharactersSync).toHaveBeenCalledTimes(0);
107: 			expect(res.status).toBe(501);
108: 			expect(res.ok).toBe(false);
109: 			expect(res.body).toBeUndefined();
110: 		});
111: 		test("void", async () => {
112: 			const action = new ActionWithRoutes();
113: 			const res = await piRouter.fetch("public:/save");
114: 			expect(action.spyOnSave).toHaveBeenCalledTimes(0);
115: 			expect(res.status).toBe(501);
116: 			expect(res.ok).toBe(false);
117: 			expect(res.body).toBeUndefined();
118: 		});
119: 	});
120: 	function initialize(context: string): void {
121: 		const action = actionStore.getActionById(context)!;
122: 		connection.emit("propertyInspectorDidAppear", {
123: 			action: action?.manifestId,
124: 			context,
125: 			device: "dev123",
126: 			event: "propertyInspectorDidAppear",
127: 		});
128: 		piRouter = new MessageGateway<object>(
129: 			(payload) => {
130: 				connection.emit("sendToPlugin", {
131: 					action: action.manifestId,
132: 					context,
133: 					event: "sendToPlugin",
134: 					payload,
135: 				});
136: 				return true;
137: 			},
138: 			() => ({}),
139: 		);
140: 		jest.spyOn(connection, "send").mockImplementation((cmd: PluginCommand) => {
141: 			if (cmd.event === "sendToPropertyInspector") {
142: 				piRouter.process({
143: 					action: action.manifestId,
144: 					context,
145: 					event: "sendToPropertyInspector",
146: 					payload: (cmd as SendToPropertyInspector<JsonObject>).payload,
147: 				});
148: 			}
149: 			return Promise.resolve();
150: 		});
151: 	}
152: });
153: @action({ UUID: "com.elgato.test.key" })
154: class ActionWithRoutes extends SingletonAction {
155: 	public spyOnGetCharacters = jest.fn();
156: 	public spyOnGetCharactersSync = jest.fn();
157: 	public spyOnSave = jest.fn();
158: 	@route("/characters")
159: 	public getCharacters(req: MessageRequest, res: MessageResponder): Promise<string[]> {
160: 		this.spyOnGetCharacters(req, res);
161: 		return Promise.resolve(["Anduin", "Sylvanas", "Thrall"]);
162: 	}
163: 	@route("/characters-sync")
164: 	public getCharactersSync(req: MessageRequest, res: MessageResponder): string[] {
165: 		this.spyOnGetCharactersSync(req, res);
166: 		return ["Mario", "Luigi", "Peach"];
167: 	}
168: 	@route("/save")
169: 	public save(req: MessageRequest, res: MessageResponder): void {
170: 		this.spyOnSave(req, res);
171: 	}
172: }
173: type Filter = {
174: 	game: string;
175: };
</file>

<file path="src/plugin/ui/__tests__/router.test.ts">
  1: import { MessageRequest } from "..";
  2: import type { DidReceivePropertyInspectorMessage, SendToPropertyInspector } from "../../../api";
  3: import type { MessageRequestOptions } from "../../../common/messaging";
  4: import type { RawMessageRequest } from "../../../common/messaging/message";
  5: import { MessageResponder } from "../../../common/messaging/responder";
  6: import { PromiseCompletionSource } from "../../../common/promises";
  7: import type { Action } from "../../actions";
  8: import { actionStore } from "../../actions/store";
  9: import { connection } from "../../connection";
 10: import { PropertyInspector } from "../property-inspector";
 11: import { getCurrentUI, router } from "../router";
 12: jest.mock("../../actions/store");
 13: jest.mock("../../connection");
 14: jest.mock("../../logging");
 15: jest.mock("../../manifest");
 16: describe("current UI", () => {
 17: 	beforeEach(() => {
 18: 		const context = {
 19: 			action: "__reset__",
 20: 			context: "__reset__",
 21: 			device: "__reset__",
 22: 		};
 23: 		connection.emit("propertyInspectorDidAppear", { event: "propertyInspectorDidAppear", ...context });
 24: 		connection.emit("propertyInspectorDidDisappear", { event: "propertyInspectorDidDisappear", ...context });
 25: 	});
 26: 	it("sets on propertyInspectorDidAppear", () => {
 27: 		connection.emit("propertyInspectorDidAppear", {
 28: 			action: "com.elgato.test.one",
 29: 			context: "key123",
 30: 			device: "dev123",
 31: 			event: "propertyInspectorDidAppear",
 32: 		});
 33: 		const current = getCurrentUI();
 34: 		expect(current).toBeInstanceOf(PropertyInspector);
 35: 		expect(current).not.toBeUndefined();
 36: 		expect(current?.action).toEqual(actionStore.getActionById("key123"));
 37: 	});
 38: 	it("overwrites on propertyInspectorDidAppear", () => {
 39: 		connection.emit("propertyInspectorDidAppear", {
 40: 			action: "com.elgato.test.one",
 41: 			context: "__first__",
 42: 			device: "dev123",
 43: 			event: "propertyInspectorDidAppear",
 44: 		});
 45: 		connection.emit("propertyInspectorDidAppear", {
 46: 			action: "com.elgato.test.one",
 47: 			context: "key123",
 48: 			device: "dev123",
 49: 			event: "propertyInspectorDidAppear",
 50: 		});
 51: 		const current = getCurrentUI();
 52: 		expect(current).toBeInstanceOf(PropertyInspector);
 53: 		expect(current).not.toBeUndefined();
 54: 		expect(current?.action).toEqual(actionStore.getActionById("key123"));
 55: 	});
 56: 	it("clears matching PI", () => {
 57: 		const action = actionStore.getActionById("key123")!;
 58: 		const context = {
 59: 			action: action.manifestId,
 60: 			context: action.id,
 61: 			device: action.device.id,
 62: 		};
 63: 		connection.emit("propertyInspectorDidAppear", {
 64: 			...context,
 65: 			event: "propertyInspectorDidAppear",
 66: 		});
 67: 		expect(getCurrentUI()).not.toBeUndefined();
 68: 		connection.emit("propertyInspectorDidDisappear", {
 69: 			...context,
 70: 			event: "propertyInspectorDidDisappear",
 71: 		});
 72: 		const current = getCurrentUI();
 73: 		expect(current).toBeUndefined();
 74: 	});
 75: 	it("does not clear matching PI with debounce", () => {
 76: 		const action = actionStore.getActionById("key123")!;
 77: 		const context = {
 78: 			action: action.manifestId,
 79: 			context: action.id,
 80: 			device: action.device.id,
 81: 		};
 82: 		connection.emit("propertyInspectorDidAppear", {
 83: 			...context,
 84: 			event: "propertyInspectorDidAppear",
 85: 		});
 86: 		connection.emit("propertyInspectorDidAppear", {
 87: 			...context,
 88: 			event: "propertyInspectorDidAppear",
 89: 		});
 90: 		expect(getCurrentUI()).not.toBeUndefined();
 91: 		connection.emit("propertyInspectorDidDisappear", {
 92: 			...context,
 93: 			event: "propertyInspectorDidDisappear",
 94: 		});
 95: 		const current = getCurrentUI();
 96: 		expect(current).not.toBeUndefined();
 97: 		connection.emit("propertyInspectorDidDisappear", {
 98: 			...context,
 99: 			event: "propertyInspectorDidDisappear",
100: 		});
101: 		expect(getCurrentUI()).toBeUndefined();
102: 	});
103: 	it("does not clear non-matching PI", () => {
104: 		connection.emit("propertyInspectorDidAppear", {
105: 			action: "com.elgato.test.one",
106: 			context: "key123",
107: 			device: "dev123",
108: 			event: "propertyInspectorDidAppear",
109: 		});
110: 		expect(getCurrentUI()).not.toBeUndefined();
111: 		connection.emit("propertyInspectorDidDisappear", {
112: 			action: "com.elgato.test.one",
113: 			context: "dial123",
114: 			device: "dev123",
115: 			event: "propertyInspectorDidDisappear",
116: 		});
117: 		const current = getCurrentUI();
118: 		expect(current).not.toBeUndefined();
119: 	});
120: 	it("proxies fetch to router", async () => {
121: 		const spyOnFetch = jest.spyOn(router, "fetch");
122: 		connection.emit("propertyInspectorDidAppear", {
123: 			action: "com.elgato.test.one",
124: 			context: "key123",
125: 			device: "dev123",
126: 			event: "propertyInspectorDidAppear",
127: 		});
128: 		await getCurrentUI()!.fetch({
129: 			path: "/test",
130: 			unidirectional: true,
131: 			timeout: 1,
132: 		});
133: 		expect(spyOnFetch).toBeCalledTimes(1);
134: 		expect(spyOnFetch).toHaveBeenCalledWith<[MessageRequestOptions]>({
135: 			path: "public:/test",
136: 			timeout: 1,
137: 			unidirectional: true,
138: 		});
139: 	});
140: });
141: describe("router", () => {
142: 	describe("inbound messages", () => {
143: 		it("processes", async () => {
144: 			const spyOnProcess = jest.spyOn(router, "process");
145: 			const ev = {
146: 				action: "com.elgato.test.one",
147: 				context: "key123",
148: 				event: "sendToPlugin",
149: 				payload: {
150: 					__type: "request",
151: 					id: "123-456-7890",
152: 					path: "/test",
153: 					unidirectional: false,
154: 					body: {
155: 						name: "Elgato",
156: 					},
157: 				},
158: 			} satisfies DidReceivePropertyInspectorMessage<RawMessageRequest>;
159: 			const awaiter = new PromiseCompletionSource();
160: 			const listener = jest.fn().mockImplementation(() => awaiter.setResult(true));
161: 			const disposable = router.route("/test", listener);
162: 			connection.emit("sendToPlugin", ev);
163: 			await awaiter.promise;
164: 			expect(spyOnProcess).toBeCalledTimes(1);
165: 			expect(spyOnProcess).toHaveBeenCalledWith(ev);
166: 			expect(listener).toHaveBeenCalledTimes(1);
167: 			expect(listener).toHaveBeenCalledWith<[MessageRequest, MessageResponder]>(
168: 				{
169: 					action: actionStore.getActionById("key123")!,
170: 					path: "/test",
171: 					unidirectional: false,
172: 					body: {
173: 						name: "Elgato",
174: 					},
175: 				},
176: 				expect.any(MessageResponder),
177: 			);
178: 			disposable.dispose();
179: 			connection.emit("sendToPlugin", ev);
180: 			expect(listener).toHaveBeenCalledTimes(1);
181: 		});
182: 	});
183: 	describe("outbound messages", () => {
184: 		describe("with ui", () => {
185: 			let action: Action;
186: 			beforeAll(() => {
187: 				jest.useFakeTimers();
188: 				action = actionStore.getActionById("key123")!;
189: 			});
190: 			afterAll(() => jest.useRealTimers());
191: 			test("path and body", async () => {
192: 				const spyOnSend = jest.spyOn(connection, "send");
193: 				connection.emit("propertyInspectorDidAppear", {
194: 					action: action.manifestId,
195: 					context: action.id,
196: 					device: action.device.id,
197: 					event: "propertyInspectorDidAppear",
198: 				});
199: 				const req = router.fetch("/outbound/path-and-body", { name: "Elgato" });
200: 				jest.runAllTimers();
201: 				await req;
202: 				expect(spyOnSend).toHaveBeenCalledTimes(1);
203: 				expect(spyOnSend).toHaveBeenCalledWith<[SendToPropertyInspector<RawMessageRequest>]>({
204: 					context: action.id,
205: 					event: "sendToPropertyInspector",
206: 					payload: {
207: 						__type: "request",
208: 						id: expect.any(String),
209: 						path: "/outbound/path-and-body",
210: 						unidirectional: false,
211: 						body: {
212: 							name: "Elgato",
213: 						},
214: 					},
215: 				});
216: 			});
217: 			test("request", async () => {
218: 				const spyOnSend = jest.spyOn(connection, "send");
219: 				connection.emit("propertyInspectorDidAppear", {
220: 					action: action.manifestId,
221: 					context: action.id,
222: 					device: action.device.id,
223: 					event: "propertyInspectorDidAppear",
224: 				});
225: 				const req = router.fetch({
226: 					path: "/outbound/request",
227: 					body: { name: "Elgato" },
228: 					timeout: 1000,
229: 					unidirectional: true,
230: 				});
231: 				jest.runAllTimers();
232: 				await req;
233: 				expect(spyOnSend).toHaveBeenCalledTimes(1);
234: 				expect(spyOnSend).toHaveBeenCalledWith<[SendToPropertyInspector<RawMessageRequest>]>({
235: 					context: action.id,
236: 					event: "sendToPropertyInspector",
237: 					payload: {
238: 						__type: "request",
239: 						id: expect.any(String),
240: 						path: "/outbound/request",
241: 						unidirectional: true,
242: 						body: {
243: 							name: "Elgato",
244: 						},
245: 					},
246: 				});
247: 			});
248: 		});
249: 		test("without ui", async () => {
250: 			const action = actionStore.getActionById("without-ui")!;
251: 			const ev = {
252: 				action: action.manifestId,
253: 				context: action.id,
254: 				device: action.device.id,
255: 			};
256: 			connection.emit("propertyInspectorDidAppear", {
257: 				...ev,
258: 				event: "propertyInspectorDidAppear",
259: 			});
260: 			connection.emit("propertyInspectorDidDisappear", {
261: 				...ev,
262: 				event: "propertyInspectorDidDisappear",
263: 			});
264: 			const spyOnSend = jest.spyOn(connection, "send");
265: 			const res = await router.fetch({
266: 				path: "/test",
267: 				body: {
268: 					name: "Elgato",
269: 				},
270: 				unidirectional: true,
271: 				timeout: 1,
272: 			});
273: 			expect(spyOnSend).toHaveBeenCalledTimes(0);
274: 			expect(res.ok).toBe(false);
275: 			expect(res.status).toBe(406);
276: 		});
277: 	});
278: });
</file>

<file path="src/plugin/ui/controller.ts">
 1: import type { DidReceivePropertyInspectorMessage } from "../../api";
 2: import type { IDisposable } from "../../common/disposable";
 3: import { ActionWithoutPayloadEvent } from "../../common/events/action-event";
 4: import type { JsonObject, JsonValue } from "../../common/json";
 5: import { PUBLIC_PATH_PREFIX, type RouteConfiguration } from "../../common/messaging";
 6: import { Action } from "../actions/action";
 7: import { actionStore } from "../actions/store";
 8: import { connection } from "../connection";
 9: import {
10: 	type PropertyInspectorDidAppearEvent,
11: 	type PropertyInspectorDidDisappearEvent,
12: 	SendToPluginEvent,
13: } from "../events";
14: import { type MessageHandler } from "./message";
15: import { type PropertyInspector } from "./property-inspector";
16: import { getCurrentUI, router } from "./router";
17: class UIController {
18: 	public get current(): PropertyInspector | undefined {
19: 		return getCurrentUI();
20: 	}
21: 	public onDidAppear<T extends JsonObject = JsonObject>(
22: 		listener: (ev: PropertyInspectorDidAppearEvent<T>) => void,
23: 	): IDisposable {
24: 		return connection.disposableOn("propertyInspectorDidAppear", (ev) => {
25: 			const action = actionStore.getActionById(ev.context);
26: 			if (action) {
27: 				listener(new ActionWithoutPayloadEvent(action, ev));
28: 			}
29: 		});
30: 	}
31: 	public onDidDisappear<T extends JsonObject = JsonObject>(
32: 		listener: (ev: PropertyInspectorDidDisappearEvent<T>) => void,
33: 	): IDisposable {
34: 		return connection.disposableOn("propertyInspectorDidDisappear", (ev) => {
35: 			const action = actionStore.getActionById(ev.context);
36: 			if (action) {
37: 				listener(new ActionWithoutPayloadEvent(action, ev));
38: 			}
39: 		});
40: 	}
41: 	public onSendToPlugin<TPayload extends JsonValue = JsonValue, TSettings extends JsonObject = JsonObject>(
42: 		listener: (ev: SendToPluginEvent<TPayload, TSettings>) => void,
43: 	): IDisposable {
44: 		return router.disposableOn("unhandledMessage", (ev) => {
45: 			const action = actionStore.getActionById(ev.context);
46: 			if (action) {
47: 				listener(
48: 					new SendToPluginEvent<TPayload, TSettings>(action, ev as DidReceivePropertyInspectorMessage<TPayload>),
49: 				);
50: 			}
51: 		});
52: 	}
53: 	public registerRoute<TBody extends JsonValue = JsonValue, TSettings extends JsonObject = JsonObject>(
54: 		path: string,
55: 		handler: MessageHandler<TBody, TSettings>,
56: 		options?: RouteConfiguration<Action>,
57: 	): IDisposable {
58: 		return router.route(`${PUBLIC_PATH_PREFIX}${path}`, handler, options);
59: 	}
60: }
61: export const ui = new UIController();
62: export { type UIController };
</file>

<file path="src/plugin/ui/index.ts">
1: export { ui, type UIController } from "./controller";
2: export { type MessageHandler, type MessageRequest } from "./message";
3: export { type PropertyInspector } from "./property-inspector";
4: export { route } from "./route";
</file>

<file path="src/plugin/ui/message.ts">
 1: import type { JsonObject, JsonValue } from "../../common/json";
 2: import type { MessageResponder, UnscopedMessageHandler, UnscopedMessageRequest } from "../../common/messaging";
 3: import type { Action } from "../actions/action";
 4: export type MessageRequest<
 5: 	TBody extends JsonValue = JsonValue,
 6: 	TSettings extends JsonObject = JsonObject,
 7: > = UnscopedMessageRequest<Action<TSettings>, TBody>;
 8: export type MessageHandler<TBody extends JsonValue = JsonValue, TSettings extends JsonObject = JsonObject> = (
 9: 	request: MessageRequest<TBody, TSettings>,
10: 	responder: MessageResponder,
11: ) => ReturnType<UnscopedMessageHandler<Action<TSettings>, TBody>>;
</file>

<file path="src/plugin/ui/property-inspector.ts">
 1: import type streamDeck from "../";
 2: import type { ActionIdentifier, DeviceIdentifier } from "../../api";
 3: import type { JsonValue } from "../../common/json";
 4: import {
 5: 	type MessageGateway,
 6: 	type MessageRequestOptions,
 7: 	type MessageResponse,
 8: 	PUBLIC_PATH_PREFIX,
 9: } from "../../common/messaging";
10: import type { Action } from "../actions/action";
11: import type { DialAction } from "../actions/dial";
12: import type { KeyAction } from "../actions/key";
13: import type { SingletonAction } from "../actions/singleton-action";
14: import { actionStore } from "../actions/store";
15: import { connection } from "../connection";
16: export class PropertyInspector implements Pick<MessageGateway<Action>, "fetch"> {
17: 	public readonly action: DialAction | KeyAction;
18: 	constructor(
19: 		private readonly router: MessageGateway<Action>,
20: 		source: ActionIdentifier & DeviceIdentifier,
21: 	) {
22: 		this.action = actionStore.getActionById(source.context)!;
23: 	}
24: 	public async fetch<T extends JsonValue = JsonValue>(request: MessageRequestOptions): Promise<MessageResponse<T>>;
25: 	public async fetch<T extends JsonValue = JsonValue>(path: string, body?: JsonValue): Promise<MessageResponse<T>>;
26: 	public async fetch<T extends JsonValue = JsonValue>(
27: 		requestOrPath: MessageRequestOptions | string,
28: 		bodyOrUndefined?: JsonValue,
29: 	): Promise<MessageResponse<T>> {
30: 		if (typeof requestOrPath === "string") {
31: 			return this.router.fetch(`${PUBLIC_PATH_PREFIX}${requestOrPath}`, bodyOrUndefined);
32: 		} else {
33: 			return this.router.fetch({
34: 				...requestOrPath,
35: 				path: `${PUBLIC_PATH_PREFIX}${requestOrPath.path}`,
36: 			});
37: 		}
38: 	}
39: 	public sendToPropertyInspector(payload: JsonValue): Promise<void> {
40: 		return connection.send({
41: 			event: "sendToPropertyInspector",
42: 			context: this.action.id,
43: 			payload,
44: 		});
45: 	}
46: }
</file>

<file path="src/plugin/ui/route.ts">
 1: import type { JsonObject, JsonValue } from "../../common/json";
 2: import { type MessageResponder, PUBLIC_PATH_PREFIX } from "../../common/messaging";
 3: import type { SingletonAction } from "../actions/singleton-action";
 4: import type { MessageHandler, MessageRequest } from "./message";
 5: import { router } from "./router";
 6: export function route<
 7: 	TBody extends JsonValue = JsonValue,
 8: 	TSettings extends JsonObject = JsonObject,
 9: 	TResult extends ReturnType<MessageHandler<TBody, TSettings>> = undefined,
10: >(
11: 	path: string,
12: ): (
13: 	target: MessageHandler<TBody, TSettings>,
14: 	context: ClassMethodDecoratorContext<SingletonAction>,
15: ) => OptionalParameterMessageHandler<TBody, TSettings, TResult> | void {
16: 	return function (
17: 		target: MessageHandler<TBody, TSettings>,
18: 		context: ClassMethodDecoratorContext<SingletonAction>,
19: 	): void {
20: 		context.addInitializer(function () {
21: 			router.route(`${PUBLIC_PATH_PREFIX}${path}`, target.bind(this), {
22: 				filter: (source) => source.manifestId === this.manifestId,
23: 			});
24: 		});
25: 	};
26: }
27: type OptionalParameterMessageHandler<TBody extends JsonValue, TSettings extends JsonObject, TResult> = (
28: 	request?: MessageRequest<TBody, TSettings>,
29: 	responder?: MessageResponder,
30: ) => TResult;
</file>

<file path="src/plugin/ui/router.ts">
 1: import type { PropertyInspectorDidAppear, PropertyInspectorDidDisappear } from "../../api";
 2: import type { JsonValue } from "../../common/json";
 3: import { MessageGateway } from "../../common/messaging";
 4: import { Action } from "../actions/action";
 5: import { actionStore } from "../actions/store";
 6: import { connection } from "../connection";
 7: import { PropertyInspector } from "./property-inspector";
 8: let current: PropertyInspector | undefined;
 9: let debounceCount = 0;
10: export function getCurrentUI(): PropertyInspector | undefined {
11: 	return current;
12: }
13: const router = new MessageGateway<Action>(
14: 	async (payload: JsonValue) => {
15: 		const current = getCurrentUI();
16: 		if (current) {
17: 			await connection.send({
18: 				event: "sendToPropertyInspector",
19: 				context: current.action.id,
20: 				payload,
21: 			});
22: 			return true;
23: 		}
24: 		return false;
25: 	},
26: 	(source) => actionStore.getActionById(source.context)!,
27: );
28: function isCurrent(ev: PropertyInspectorDidAppear | PropertyInspectorDidDisappear): boolean {
29: 	return (
30: 		current?.action?.id === ev.context &&
31: 		current?.action?.manifestId === ev.action &&
32: 		current?.action?.device?.id === ev.device
33: 	);
34: }
35: connection.on("propertyInspectorDidAppear", (ev) => {
36: 	if (isCurrent(ev)) {
37: 		debounceCount++;
38: 	} else {
39: 		debounceCount = 1;
40: 		current = new PropertyInspector(router, ev);
41: 	}
42: });
43: connection.on("propertyInspectorDidDisappear", (ev) => {
44: 	if (isCurrent(ev)) {
45: 		debounceCount--;
46: 		if (debounceCount <= 0) {
47: 			current = undefined;
48: 		}
49: 	}
50: });
51: connection.on("sendToPlugin", (ev) => router.process(ev));
52: export { router };
</file>

<file path="src/plugin/connection.ts">
  1: import WebSocket from "ws";
  2: import type { PluginCommand, PluginEventMap, RegistrationInfo } from "../api";
  3: import { RegistrationParameter } from "../api";
  4: import { EventEmitter } from "../common/event-emitter";
  5: import { PromiseCompletionSource } from "../common/promises";
  6: import { Version } from "./common/version";
  7: import { logger } from "./logging";
  8: class Connection extends EventEmitter<ExtendedEventMap> {
  9: 	private _registrationParameters: RegistrationParameters | undefined;
 10: 	private _version: Version | undefined;
 11: 	private canConnect = true;
 12: 	private connection = new PromiseCompletionSource<WebSocket>();
 13: 	private readonly logger = logger.createScope("Connection");
 14: 	public get registrationParameters(): RegistrationParameters {
 15: 		return (this._registrationParameters ??= this.getRegistrationParameters());
 16: 	}
 17: 	public get version(): Version {
 18: 		return (this._version ??= new Version(this.registrationParameters.info.application.version));
 19: 	}
 20: 	public async connect(): Promise<void> {
 21: 		if (this.canConnect) {
 22: 			this.canConnect = false;
 23: 			const webSocket = new WebSocket(`ws://127.0.0.1:${this.registrationParameters.port}`);
 24: 			webSocket.onmessage = (ev: WebSocket.MessageEvent): void => this.tryEmit(ev);
 25: 			webSocket.onopen = (): void => {
 26: 				webSocket.send(
 27: 					JSON.stringify({
 28: 						event: this.registrationParameters.registerEvent,
 29: 						uuid: this.registrationParameters.pluginUUID,
 30: 					}),
 31: 				);
 32: 				this.connection.setResult(webSocket);
 33: 				this.emit("connected", this.registrationParameters.info);
 34: 			};
 35: 		}
 36: 		await this.connection.promise;
 37: 	}
 38: 	public async send(command: PluginCommand): Promise<void> {
 39: 		const connection = await this.connection.promise;
 40: 		const message = JSON.stringify(command);
 41: 		this.logger.trace(message);
 42: 		connection.send(message);
 43: 	}
 44: 	private getRegistrationParameters(): RegistrationParameters {
 45: 		const params: Partial<RegistrationParameters> = {
 46: 			port: undefined,
 47: 			info: undefined,
 48: 			pluginUUID: undefined,
 49: 			registerEvent: undefined,
 50: 		};
 51: 		const scopedLogger = logger.createScope("RegistrationParameters");
 52: 		for (let i = 0; i < process.argv.length - 1; i++) {
 53: 			const param = process.argv[i];
 54: 			const value = process.argv[++i];
 55: 			switch (param) {
 56: 				case RegistrationParameter.Port:
 57: 					scopedLogger.debug(`port=${value}`);
 58: 					params.port = value;
 59: 					break;
 60: 				case RegistrationParameter.PluginUUID:
 61: 					scopedLogger.debug(`pluginUUID=${value}`);
 62: 					params.pluginUUID = value;
 63: 					break;
 64: 				case RegistrationParameter.RegisterEvent:
 65: 					scopedLogger.debug(`registerEvent=${value}`);
 66: 					params.registerEvent = value;
 67: 					break;
 68: 				case RegistrationParameter.Info:
 69: 					scopedLogger.debug(`info=${value}`);
 70: 					params.info = JSON.parse(value);
 71: 					break;
 72: 				default:
 73: 					i--;
 74: 					break;
 75: 			}
 76: 		}
 77: 		const invalidArgs: string[] = [];
 78: 		const validate = (name: string, value: unknown): void => {
 79: 			if (value === undefined) {
 80: 				invalidArgs.push(name);
 81: 			}
 82: 		};
 83: 		validate(RegistrationParameter.Port, params.port);
 84: 		validate(RegistrationParameter.PluginUUID, params.pluginUUID);
 85: 		validate(RegistrationParameter.RegisterEvent, params.registerEvent);
 86: 		validate(RegistrationParameter.Info, params.info);
 87: 		if (invalidArgs.length > 0) {
 88: 			throw new Error(
 89: 				`Unable to establish a connection with Stream Deck, missing command line arguments: ${invalidArgs.join(", ")}`,
 90: 			);
 91: 		}
 92: 		return params as RegistrationParameters;
 93: 	}
 94: 	private tryEmit(ev: WebSocket.MessageEvent): void {
 95: 		try {
 96: 			const message = JSON.parse(ev.data.toString());
 97: 			if (message.event) {
 98: 				this.logger.trace(ev.data.toString());
 99: 				this.emit(message.event, message);
100: 			} else {
101: 				this.logger.warn(`Received unknown message: ${ev.data}`);
102: 			}
103: 		} catch (err) {
104: 			this.logger.error(`Failed to parse message: ${ev.data}`, err);
105: 		}
106: 	}
107: }
108: type RegistrationParameters = {
109: 	info: RegistrationInfo;
110: 	pluginUUID: string;
111: 	port: string;
112: 	registerEvent: string;
113: };
114: type ExtendedEventMap = PluginEventMap & {
115: 	connected: [info: RegistrationInfo];
116: };
117: export const connection = new Connection();
</file>

<file path="src/plugin/i18n.ts">
 1: import fs from "node:fs";
 2: import path from "node:path";
 3: import { type Language } from "../api";
 4: import { parseLocalizations } from "../common/i18n";
 5: import { type JsonObject } from "../common/json";
 6: import { logger } from "./logging";
 7: export function fileSystemLocaleProvider(language: Language): JsonObject | null {
 8: 	const filePath = path.join(process.cwd(), `${language}.json`);
 9: 	if (!fs.existsSync(filePath)) {
10: 		return null;
11: 	}
12: 	try {
13: 		const contents = fs.readFileSync(filePath, { flag: "r" })?.toString();
14: 		return parseLocalizations(contents);
15: 	} catch (err) {
16: 		logger.error(`Failed to load translations from ${filePath}`, err);
17: 		return null;
18: 	}
19: }
</file>

<file path="src/plugin/index.ts">
 1: import type { Manifest, RegistrationInfo } from "../api";
 2: import { I18nProvider } from "../common/i18n";
 3: import { type Logger, registerCreateLogEntryRoute } from "../common/logging";
 4: import { actionService, type ActionService } from "./actions/service";
 5: import { connection } from "./connection";
 6: import { deviceService, type DeviceService } from "./devices/service";
 7: import { fileSystemLocaleProvider } from "./i18n";
 8: import { logger } from "./logging";
 9: import { getManifest } from "./manifest";
10: import * as profiles from "./profiles";
11: import * as settings from "./settings";
12: import * as system from "./system";
13: import { ui, type UIController } from "./ui";
14: import { router } from "./ui/router";
15: export {
16: 	BarSubType,
17: 	DeviceType,
18: 	Target,
19: 	type Bar,
20: 	type Controller,
21: 	type Coordinates,
22: 	type DeviceInfo,
23: 	type FeedbackPayload,
24: 	type GBar,
25: 	type Language,
26: 	type Manifest,
27: 	type Pixmap,
28: 	type RegistrationInfo,
29: 	type Size,
30: 	type State,
31: 	type Text,
32: } from "../api";
33: export { Enumerable } from "../common/enumerable";
34: export { EventEmitter, EventsOf } from "../common/event-emitter";
35: export { type JsonObject, type JsonPrimitive, type JsonValue } from "../common/json";
36: export { LogLevel } from "../common/logging";
37: export {
38: 	type MessageRequestOptions,
39: 	type MessageResponder,
40: 	type MessageResponse,
41: 	type RouteConfiguration,
42: 	type StatusCode,
43: } from "../common/messaging";
44: export * from "./actions";
45: export * from "./devices";
46: export type * from "./events";
47: export { route, type MessageRequest, type PropertyInspector } from "./ui";
48: export { type Logger };
49: let i18n: I18nProvider | undefined;
50: export const streamDeck = {
51: 	get actions(): ActionService {
52: 		return actionService;
53: 	},
54: 	get devices(): DeviceService {
55: 		return deviceService;
56: 	},
57: 	get i18n(): I18nProvider {
58: 		return (i18n ??= new I18nProvider(this.info.application.language, fileSystemLocaleProvider));
59: 	},
60: 	get info(): Omit<RegistrationInfo, "devices"> {
61: 		return connection.registrationParameters.info;
62: 	},
63: 	get logger(): Logger {
64: 		return logger;
65: 	},
66: 	get manifest(): Manifest {
67: 		return getManifest();
68: 	},
69: 	get profiles(): typeof profiles {
70: 		return profiles;
71: 	},
72: 	get settings(): typeof settings {
73: 		return settings;
74: 	},
75: 	get system(): typeof system {
76: 		return system;
77: 	},
78: 	get ui(): UIController {
79: 		return ui;
80: 	},
81: 	connect(): Promise<void> {
82: 		return connection.connect();
83: 	},
84: };
85: registerCreateLogEntryRoute(router, logger);
86: export default streamDeck;
</file>

<file path="src/plugin/manifest.ts">
 1: import { existsSync, readFileSync } from "node:fs";
 2: import { join } from "node:path";
 3: import { Manifest } from "../api";
 4: import { Version } from "./common/version";
 5: let manifest: Manifest;
 6: let softwareMinimumVersion: Version;
 7: export function getSoftwareMinimumVersion(): Version {
 8: 	return (softwareMinimumVersion ??= new Version(getManifest().Software.MinimumVersion));
 9: }
10: export function getManifest(): Manifest {
11: 	return (manifest ??= readManifest());
12: }
13: function readManifest(): Manifest {
14: 	const path = join(process.cwd(), "manifest.json");
15: 	if (!existsSync(path)) {
16: 		throw new Error("Failed to read manifest.json as the file does not exist.");
17: 	}
18: 	return JSON.parse(
19: 		readFileSync(path, {
20: 			encoding: "utf-8",
21: 			flag: "r",
22: 		}).toString(),
23: 	);
24: }
</file>

<file path="src/plugin/profiles.ts">
 1: import { connection } from "./connection";
 2: import { requiresVersion } from "./validation";
 3: export function switchToProfile(deviceId: string, profile?: string, page?: number): Promise<void> {
 4: 	if (page !== undefined) {
 5: 		requiresVersion(6.5, connection.version, "Switching to a profile page");
 6: 	}
 7: 	return connection.send({
 8: 		event: "switchToProfile",
 9: 		context: connection.registrationParameters.pluginUUID,
10: 		device: deviceId,
11: 		payload: {
12: 			page,
13: 			profile,
14: 		},
15: 	});
16: }
</file>

<file path="src/plugin/settings.ts">
 1: import type { DidReceiveGlobalSettings, DidReceiveSettings } from "../api";
 2: import type { IDisposable } from "../common/disposable";
 3: import { ActionEvent } from "../common/events";
 4: import type { JsonObject } from "../common/json";
 5: import { Action } from "./actions/action";
 6: import { actionStore } from "./actions/store";
 7: import { connection } from "./connection";
 8: import { DidReceiveGlobalSettingsEvent, DidReceiveSettingsEvent } from "./events";
 9: export function getGlobalSettings<T extends JsonObject = JsonObject>(): Promise<T> {
10: 	return new Promise((resolve) => {
11: 		connection.once("didReceiveGlobalSettings", (ev: DidReceiveGlobalSettings<T>) => resolve(ev.payload.settings));
12: 		connection.send({
13: 			event: "getGlobalSettings",
14: 			context: connection.registrationParameters.pluginUUID,
15: 		});
16: 	});
17: }
18: export function onDidReceiveGlobalSettings<T extends JsonObject = JsonObject>(
19: 	listener: (ev: DidReceiveGlobalSettingsEvent<T>) => void,
20: ): IDisposable {
21: 	return connection.disposableOn("didReceiveGlobalSettings", (ev: DidReceiveGlobalSettings<T>) =>
22: 		listener(new DidReceiveGlobalSettingsEvent(ev)),
23: 	);
24: }
25: export function onDidReceiveSettings<T extends JsonObject = JsonObject>(
26: 	listener: (ev: DidReceiveSettingsEvent<T>) => void,
27: ): IDisposable {
28: 	return connection.disposableOn("didReceiveSettings", (ev: DidReceiveSettings<T>) => {
29: 		const action = actionStore.getActionById(ev.context);
30: 		if (action) {
31: 			listener(new ActionEvent(action, ev));
32: 		}
33: 	});
34: }
35: export function setGlobalSettings<T extends JsonObject>(settings: T): Promise<void> {
36: 	return connection.send({
37: 		event: "setGlobalSettings",
38: 		context: connection.registrationParameters.pluginUUID,
39: 		payload: settings,
40: 	});
41: }
</file>

<file path="src/plugin/system.ts">
 1: import type { Manifest, SystemDidWakeUp } from "../api";
 2: import type { IDisposable } from "../common/disposable";
 3: import { connection } from "./connection";
 4: import {
 5: 	ApplicationDidLaunchEvent,
 6: 	ApplicationDidTerminateEvent,
 7: 	ApplicationEvent,
 8: 	DidReceiveDeepLinkEvent,
 9: 	Event,
10: 	SystemDidWakeUpEvent,
11: } from "./events";
12: import { requiresVersion } from "./validation";
13: export function onApplicationDidLaunch(listener: (ev: ApplicationDidLaunchEvent) => void): IDisposable {
14: 	return connection.disposableOn("applicationDidLaunch", (ev) => listener(new ApplicationEvent(ev)));
15: }
16: export function onApplicationDidTerminate(listener: (ev: ApplicationDidTerminateEvent) => void): IDisposable {
17: 	return connection.disposableOn("applicationDidTerminate", (ev) => listener(new ApplicationEvent(ev)));
18: }
19: export function onDidReceiveDeepLink(listener: (ev: DidReceiveDeepLinkEvent) => void): IDisposable {
20: 	requiresVersion(6.5, connection.version, "Receiving deep-link messages");
21: 	return connection.disposableOn("didReceiveDeepLink", (ev) => listener(new DidReceiveDeepLinkEvent(ev)));
22: }
23: export function onSystemDidWakeUp(listener: (ev: SystemDidWakeUpEvent) => void): IDisposable {
24: 	return connection.disposableOn("systemDidWakeUp", (ev) => listener(new Event<SystemDidWakeUp>(ev)));
25: }
26: export function openUrl(url: string): Promise<void> {
27: 	return connection.send({
28: 		event: "openUrl",
29: 		payload: {
30: 			url,
31: 		},
32: 	});
33: }
</file>

<file path="src/plugin/tsconfig.build.json">
 1: {
 2:     "extends": "../../tsconfig.json",
 3:     "compilerOptions": {
 4:         "declaration": true,
 5:         "declarationDir": "../../dist/types"
 6:     },
 7:     "exclude": [
 8:         "../../tests",
 9:         "../ui/",
10:         "../**/__mocks__/",
11:         "../**/__tests__/"
12:     ]
13: }
</file>

<file path="src/plugin/validation.ts">
 1: import { Version } from "./common/version";
 2: import { getSoftwareMinimumVersion } from "./manifest";
 3: export function requiresVersion(minimumVersion: number, streamDeckVersion: Version, feature: string): never | void {
 4: 	const required = {
 5: 		major: Math.floor(minimumVersion),
 6: 		minor: (minimumVersion % 1) * 10,
 7: 		patch: 0,
 8: 		build: 0,
 9: 	};
10: 	if (streamDeckVersion.compareTo(required) === -1) {
11: 		throw new Error(
12: 			`[ERR_NOT_SUPPORTED]: ${feature} requires Stream Deck version ${required.major}.${required.minor} or higher, but current version is ${streamDeckVersion.major}.${streamDeckVersion.minor}; please update Stream Deck and the "Software.MinimumVersion" in the plugin's manifest to "${required.major}.${required.minor}" or higher.`,
13: 		);
14: 	} else if (getSoftwareMinimumVersion().compareTo(required) === -1) {
15: 		throw new Error(
16: 			`[ERR_NOT_SUPPORTED]: ${feature} requires Stream Deck version ${required.major}.${required.minor} or higher; please update the "Software.MinimumVersion" in the plugin's manifest to "${required.major}.${required.minor}" or higher.`,
17: 		);
18: 	}
19: }
</file>

<file path="src/ui/__mocks__/connection.ts">
 1: import { actionInfo, registrationInfo } from "../../api/registration/__mocks__";
 2: import type { ConnectionInfo } from "../connection";
 3: const { connection } = jest.requireActual<typeof import("../connection")>("../connection");
 4: jest.spyOn(connection, "getInfo").mockReturnValue(
 5: 	Promise.resolve<ConnectionInfo>({
 6: 		actionInfo,
 7: 		info: registrationInfo,
 8: 		uuid: "abc123",
 9: 	}),
10: );
11: jest.spyOn(connection, "send").mockReturnValue(Promise.resolve());
12: export { connection };
</file>

<file path="src/ui/__mocks__/logging.ts">
1: export { logger } from "../../plugin/logging/__mocks__/index";
</file>

<file path="src/ui/__tests__/connection.test.ts">
  1: import { WS as WebSocketServer } from "jest-websocket-mock";
  2: import { ActionInfo, RegistrationInfo } from "..";
  3: import { type DidReceiveGlobalSettings } from "../../api";
  4: import { actionInfo, registrationInfo } from "../../api/registration/__mocks__/";
  5: import type { connection as UIConnection } from "../connection";
  6: describe("connection", () => {
  7: 	let connection!: typeof UIConnection;
  8: 	let server!: WebSocketServer;
  9: 	const port = "12345";
 10: 	beforeEach(async () => {
 11: 		jest.resetModules();
 12: 		({ connection } = await require("../connection"));
 13: 		server = new WebSocketServer(`ws://127.0.0.1:${port}`, { jsonProtocol: true });
 14: 	});
 15: 	afterEach(() => WebSocketServer.clean());
 16: 	it("connectElgatoStreamDeckSocket should exist on the window", () => {
 17: 		expect(window.connectElgatoStreamDeckSocket).not.toBeUndefined();
 18: 	});
 19: 	it("registers", async () => {
 20: 		const event = "register";
 21: 		const uuid = "123_registers";
 22: 		await window.connectElgatoStreamDeckSocket(
 23: 			port,
 24: 			uuid,
 25: 			event,
 26: 			JSON.stringify(registrationInfo),
 27: 			JSON.stringify(actionInfo),
 28: 		);
 29: 		await expect(server).toReceiveMessage({ event, uuid });
 30: 	});
 31: 	it("emits connecting and connected", async () => {
 32: 		const uuid = "123_emits-connected";
 33: 		const connectingSpy = jest.fn();
 34: 		const connectedSpy = jest.fn();
 35: 		connection.on("connecting", connectingSpy);
 36: 		connection.on("connected", connectedSpy);
 37: 		await window.connectElgatoStreamDeckSocket(
 38: 			port,
 39: 			uuid,
 40: 			"register",
 41: 			JSON.stringify(registrationInfo),
 42: 			JSON.stringify(actionInfo),
 43: 		);
 44: 		await connection.getInfo();
 45: 		expect(connectingSpy).toHaveBeenCalledTimes(1);
 46: 		expect(connectingSpy).toBeCalledWith<[RegistrationInfo, ActionInfo]>(registrationInfo, actionInfo);
 47: 		expect(connectedSpy).toHaveBeenCalledTimes(1);
 48: 		expect(connectedSpy).toBeCalledWith<[RegistrationInfo, ActionInfo]>(registrationInfo, actionInfo);
 49: 		expect(connectingSpy.mock.invocationCallOrder[0]).toBeLessThan(connectedSpy.mock.invocationCallOrder[0]);
 50: 	});
 51: 	it("resolve info", async () => {
 52: 		const uuid = "123-resolve-info";
 53: 		await window.connectElgatoStreamDeckSocket(
 54: 			port,
 55: 			uuid,
 56: 			"register",
 57: 			JSON.stringify(registrationInfo),
 58: 			JSON.stringify(actionInfo),
 59: 		);
 60: 		const info = await connection.getInfo();
 61: 		expect(info.actionInfo).toEqual(actionInfo);
 62: 		expect(info.info).toEqual(registrationInfo);
 63: 		expect(info.uuid).toBe(uuid);
 64: 	});
 65: 	it("sends", async () => {
 66: 		const event = "register";
 67: 		const uuid = "123-sends";
 68: 		await window.connectElgatoStreamDeckSocket(
 69: 			port,
 70: 			uuid,
 71: 			event,
 72: 			JSON.stringify(registrationInfo),
 73: 			JSON.stringify(actionInfo),
 74: 		);
 75: 		await connection.send({
 76: 			event: "setSettings",
 77: 			action: "com.elgato.test.actionOne",
 78: 			context: "abc123",
 79: 			payload: {
 80: 				message: "Hello world",
 81: 			},
 82: 		});
 83: 		await expect(server).toReceiveMessage({
 84: 			event,
 85: 			uuid,
 86: 		});
 87: 		await expect(server).toReceiveMessage({
 88: 			event: "setSettings",
 89: 			action: "com.elgato.test.actionOne",
 90: 			context: "abc123",
 91: 			payload: {
 92: 				message: "Hello world",
 93: 			},
 94: 		});
 95: 	});
 96: 	it("propagates messages", async () => {
 97: 		const listener = jest.fn();
 98: 		connection.on("didReceiveGlobalSettings", listener);
 99: 		await window.connectElgatoStreamDeckSocket(
100: 			port,
101: 			"123-propagate-messages",
102: 			"register",
103: 			JSON.stringify(registrationInfo),
104: 			JSON.stringify(actionInfo),
105: 		);
106: 		server.send({
107: 			event: "didReceiveGlobalSettings",
108: 			payload: {
109: 				settings: {
110: 					message: "Hello world",
111: 				},
112: 			},
113: 		} satisfies DidReceiveGlobalSettings<Settings>);
114: 		expect(listener).toHaveBeenCalledTimes(1);
115: 		expect(listener).toHaveBeenCalledWith<[DidReceiveGlobalSettings<Settings>]>({
116: 			event: "didReceiveGlobalSettings",
117: 			payload: {
118: 				settings: {
119: 					message: "Hello world",
120: 				},
121: 			},
122: 		});
123: 	});
124: });
125: type Settings = {
126: 	message: string;
127: };
</file>

<file path="src/ui/__tests__/i18n.test.ts">
  1: jest.mock("../logging");
  2: describe("i18n", () => {
  3: 	afterEach(() => {
  4: 		jest.resetAllMocks();
  5: 		jest.resetModules();
  6: 	});
  7: 	it("should use navigator language as default", async () => {
  8: 		const mockedXMLHttpRequest = {
  9: 			open: jest.fn(),
 10: 			send: jest.fn(),
 11: 			response: JSON.stringify({ Localization: { Hello: "Hallo Welt" } }),
 12: 		};
 13: 		jest
 14: 			.spyOn(window, "location", "get")
 15: 			.mockReturnValue({ href: "file:///c:/temp/com.elgato.test.sdPlugin/ui/pi.html" } as unknown as Location);
 16: 		jest.spyOn(window, "XMLHttpRequest").mockImplementation(() => mockedXMLHttpRequest as unknown as XMLHttpRequest);
 17: 		jest.spyOn(window.navigator, "language", "get").mockReturnValue("de");
 18: 		const { i18n } = (await require("../i18n")) as typeof import("../i18n");
 19: 		const result = i18n.translate("Hello");
 20: 		expect(result).toBe("Hallo Welt");
 21: 		expect(mockedXMLHttpRequest.open).toHaveBeenCalledTimes(1);
 22: 		expect(mockedXMLHttpRequest.open).toHaveBeenCalledWith(
 23: 			"GET",
 24: 			"file:///c:/temp/com.elgato.test.sdPlugin/de.json",
 25: 			false,
 26: 		);
 27: 	});
 28: 	it("should ignore localized navigation language", async () => {
 29: 		const mockedXMLHttpRequest = {
 30: 			open: jest.fn(),
 31: 			send: jest.fn(),
 32: 			response: JSON.stringify({ Localization: { Hello: "Hello world" } }),
 33: 		};
 34: 		jest
 35: 			.spyOn(window, "location", "get")
 36: 			.mockReturnValue({ href: "file:///c:/temp/com.elgato.test.sdPlugin/ui/pi.html" } as unknown as Location);
 37: 		jest.spyOn(window, "XMLHttpRequest").mockImplementation(() => mockedXMLHttpRequest as unknown as XMLHttpRequest);
 38: 		jest.spyOn(window.navigator, "language", "get").mockReturnValue("en-US");
 39: 		const { i18n } = (await require("../i18n")) as typeof import("../i18n");
 40: 		const result = i18n.translate("Hello");
 41: 		expect(result).toBe("Hello world");
 42: 		expect(mockedXMLHttpRequest.open).toHaveBeenCalledTimes(1);
 43: 		expect(mockedXMLHttpRequest.open).toHaveBeenCalledWith(
 44: 			"GET",
 45: 			"file:///c:/temp/com.elgato.test.sdPlugin/en.json",
 46: 			false,
 47: 		);
 48: 	});
 49: });
 50: describe("xmlHttpRequestLocaleProviderSync", () => {
 51: 	let xmlHttpRequestLocaleProviderSync: typeof import("../i18n").xmlHttpRequestLocaleProviderSync;
 52: 	beforeEach(async () => {
 53: 		jest
 54: 			.spyOn(window, "location", "get")
 55: 			.mockReturnValue({ href: "file:///c:/temp/com.elgato.test.sdPlugin/ui/pi.html" } as unknown as Location);
 56: 		({ xmlHttpRequestLocaleProviderSync } = await require("../i18n"));
 57: 	});
 58: 	afterEach(() => jest.resetAllMocks());
 59: 	it("reads from the language JSON file", () => {
 60: 		const mockedXMLHttpRequest = {
 61: 			open: jest.fn(),
 62: 			send: jest.fn(),
 63: 			response: JSON.stringify({
 64: 				Localization: {
 65: 					Hello: "Hello world",
 66: 				},
 67: 			}),
 68: 		};
 69: 		jest.spyOn(window, "XMLHttpRequest").mockImplementation(() => mockedXMLHttpRequest as unknown as XMLHttpRequest);
 70: 		const translations = xmlHttpRequestLocaleProviderSync("en");
 71: 		expect(translations).toEqual({ Hello: "Hello world" });
 72: 		expect(mockedXMLHttpRequest.open).toHaveBeenCalledTimes(1);
 73: 		expect(mockedXMLHttpRequest.open).toHaveBeenCalledWith(
 74: 			"GET",
 75: 			"file:///c:/temp/com.elgato.test.sdPlugin/en.json",
 76: 			false,
 77: 		);
 78: 		expect(mockedXMLHttpRequest.send).toHaveBeenCalledTimes(1);
 79: 	});
 80: 	it("returns null when the file is not found", () => {
 81: 		const mockedXMLHttpRequest = {
 82: 			open: jest.fn(),
 83: 			send: jest.fn().mockImplementation(() => {
 84: 				throw new DOMException(undefined, "NOT_FOUND_ERR");
 85: 			}),
 86: 			response: null,
 87: 		};
 88: 		jest.spyOn(window, "XMLHttpRequest").mockImplementation(() => mockedXMLHttpRequest as unknown as XMLHttpRequest);
 89: 		const spyOnConsoleWarn = jest.spyOn(console, "warn").mockImplementationOnce(() => {});
 90: 		const translations = xmlHttpRequestLocaleProviderSync("de");
 91: 		expect(translations).toBeNull();
 92: 		expect(spyOnConsoleWarn).toHaveBeenCalledTimes(1);
 93: 		expect(spyOnConsoleWarn).toHaveBeenCalledWith("Missing localization file: de.json");
 94: 	});
 95: 	it("logs an error when the contents are not JSON", async () => {
 96: 		const mockedXMLHttpRequest = {
 97: 			open: jest.fn(),
 98: 			send: jest.fn(),
 99: 			response: `{"value":invalid}`,
100: 		};
101: 		jest.spyOn(window, "XMLHttpRequest").mockImplementation(() => mockedXMLHttpRequest as unknown as XMLHttpRequest);
102: 		const { logger } = await require("../logging");
103: 		const spyOnLogError = jest.spyOn(logger, "error");
104: 		const translations = xmlHttpRequestLocaleProviderSync("es");
105: 		expect(translations).toBeNull();
106: 		expect(spyOnLogError).toHaveBeenCalledTimes(1);
107: 		expect(spyOnLogError).toHaveBeenCalledWith(
108: 			"Failed to load translations from file:///c:/temp/com.elgato.test.sdPlugin/es.json",
109: 			expect.any(SyntaxError),
110: 		);
111: 	});
112: 	it("logs an error when the structure is incorrect", async () => {
113: 		const mockedXMLHttpRequest = {
114: 			open: jest.fn(),
115: 			send: jest.fn(),
116: 			response: `{"NotLocalization":"Incorrect format"}`,
117: 		};
118: 		jest.spyOn(window, "XMLHttpRequest").mockImplementation(() => mockedXMLHttpRequest as unknown as XMLHttpRequest);
119: 		const { logger } = await require("../logging");
120: 		const spyOnLogError = jest.spyOn(logger, "error");
121: 		const translations = xmlHttpRequestLocaleProviderSync("ja");
122: 		expect(translations).toBeNull();
123: 		expect(spyOnLogError).toHaveBeenCalledTimes(1);
124: 		expect(spyOnLogError).toHaveBeenCalledWith(
125: 			`Failed to load translations from file:///c:/temp/com.elgato.test.sdPlugin/ja.json`,
126: 			expect.any(TypeError),
127: 		);
128: 	});
129: });
130: describe("cwd", () => {
131: 	let cwd: typeof import("../i18n").cwd;
132: 	beforeAll(async () => ({ cwd } = await require("../i18n")));
133: 	it("should find folder ending in .sdPlugin", () => {
134: 		jest
135: 			.spyOn(window, "location", "get")
136: 			.mockReturnValue({ href: "file:///c:/plugins/com.elgato.test.sdPlugin/pi.html" } as unknown as Location);
137: 		expect(cwd()).toBe("file:///c:/plugins/com.elgato.test.sdPlugin/");
138: 	});
139: 	it("should return the entire path minus the file when .sdPlugin not found", () => {
140: 		jest
141: 			.spyOn(window, "location", "get")
142: 			.mockReturnValue({ href: "file:///c:/test/folder/ui/pi.html" } as unknown as Location);
143: 		expect(cwd()).toBe("file:///c:/test/folder/ui/");
144: 	});
145: });
</file>

<file path="src/ui/__tests__/index.test.ts">
 1: import streamDeck from "../";
 2: import { DeviceType } from "../../api";
 3: import { actionInfo, registrationInfo } from "../../api/registration/__mocks__";
 4: import { EventEmitter } from "../../common/event-emitter";
 5: import { LogLevel } from "../../common/logging";
 6: import { connection } from "../connection";
 7: import { plugin } from "../plugin";
 8: import * as settings from "../settings";
 9: import * as system from "../system";
10: jest.mock("../connection");
11: describe("streamDeck", () => {
12: 	it("exports namespaces", () => {
13: 		expect(streamDeck.plugin).toStrictEqual(plugin);
14: 		expect(streamDeck.settings).toStrictEqual(settings);
15: 		expect(streamDeck.system).toStrictEqual(system);
16: 	});
17: 	it("exports enums, classes, and functions", async () => {
18: 		const index = (await require("../index")) as typeof import("../index");
19: 		expect(index.DeviceType).toBe(DeviceType);
20: 		expect(index.EventEmitter).toBe(EventEmitter);
21: 		expect(index.LogLevel).toBe(LogLevel);
22: 	});
23: 	it("receives onConnecting", () => {
24: 		const listener = jest.fn();
25: 		const disposable = streamDeck.onConnecting(listener);
26: 		connection.emit("connecting", registrationInfo, actionInfo);
27: 		expect(listener).toHaveBeenCalledTimes(1);
28: 		expect(listener).toHaveBeenCalledWith(registrationInfo, actionInfo);
29: 		disposable.dispose();
30: 		connection.emit("connecting", registrationInfo, actionInfo);
31: 		expect(listener).toHaveBeenCalledTimes(1);
32: 	});
33: 	it("receives onConnected", () => {
34: 		const listener = jest.fn();
35: 		const disposable = streamDeck.onConnected(listener);
36: 		connection.emit("connected", registrationInfo, actionInfo);
37: 		expect(listener).toHaveBeenCalledTimes(1);
38: 		expect(listener).toHaveBeenCalledWith(registrationInfo, actionInfo);
39: 		disposable.dispose();
40: 		connection.emit("connected", registrationInfo, actionInfo);
41: 		expect(listener).toHaveBeenCalledTimes(1);
42: 	});
43: });
</file>

<file path="src/ui/__tests__/logging.test.ts">
 1: import * as LoggingModule from "../../common/logging";
 2: import { router } from "../plugin";
 3: jest.mock("../../common/logging");
 4: jest.mock("../plugin");
 5: describe("Logging", () => {
 6: 	it("constructs a logger", async () => {
 7: 		const spyOnLogger = jest.spyOn(LoggingModule, "Logger");
 8: 		const { logger } = (await require("../logging")) as typeof import("../logging");
 9: 		expect(logger).toBe(spyOnLogger.mock.instances[0]);
10: 		expect(spyOnLogger).toHaveBeenCalledTimes(1);
11: 		expect(spyOnLogger).toHaveBeenCalledWith<[LoggingModule.LoggerOptions]>({
12: 			level: LoggingModule.LogLevel.DEBUG,
13: 			targets: [expect.any(LoggingModule.ConsoleTarget), LoggingModule.createRoutedLogTarget(router)],
14: 		});
15: 	});
16: });
</file>

<file path="src/ui/__tests__/plugin.test.ts">
  1: import type { MessageRequest, SendToPropertyInspectorEvent } from "..";
  2: import type { DidReceivePluginMessage, SendToPlugin } from "../../api";
  3: import { actionInfo } from "../../api/registration/__mocks__";
  4: import type { RawMessageRequest } from "../../common/messaging/message";
  5: import { MessageResponder } from "../../common/messaging/responder";
  6: import { PromiseCompletionSource } from "../../common/promises";
  7: import { connection } from "../connection";
  8: import { plugin, type PluginController, router } from "../plugin";
  9: import { getSettings, setSettings } from "../settings";
 10: jest.mock("../connection");
 11: describe("plugin", () => {
 12: 	let uuid!: string;
 13: 	beforeAll(async () => ({ uuid } = await connection.getInfo()));
 14: 	describe("fetch", () => {
 15: 		beforeAll(() => jest.useFakeTimers());
 16: 		afterAll(() => jest.useRealTimers());
 17: 		const mockUUID = "ab038da2-77b0-441b-a4f5-c8d33f17a7a2";
 18: 		beforeEach(() => (global.crypto.randomUUID = () => mockUUID));
 19: 		test("path and body", async () => {
 20: 			const spyOnSend = jest.spyOn(connection, "send");
 21: 			const req = plugin.fetch("/outbound/path-and-body", { name: "Elgato" });
 22: 			jest.runAllTimers();
 23: 			await req;
 24: 			expect(spyOnSend).toHaveBeenCalledTimes(1);
 25: 			expect(spyOnSend).toHaveBeenCalledWith<[SendToPlugin<RawMessageRequest>]>({
 26: 				action: actionInfo.action,
 27: 				context: uuid,
 28: 				event: "sendToPlugin",
 29: 				payload: {
 30: 					__type: "request",
 31: 					id: mockUUID,
 32: 					path: "public:/outbound/path-and-body",
 33: 					unidirectional: false,
 34: 					body: {
 35: 						name: "Elgato",
 36: 					},
 37: 				},
 38: 			});
 39: 		});
 40: 		test("request", async () => {
 41: 			const spyOnSend = jest.spyOn(connection, "send");
 42: 			const req = plugin.fetch({
 43: 				path: "/outbound/request",
 44: 				body: { name: "Elgato" },
 45: 				timeout: 1000,
 46: 				unidirectional: true,
 47: 			});
 48: 			jest.runAllTimers();
 49: 			await req;
 50: 			expect(spyOnSend).toHaveBeenCalledTimes(1);
 51: 			expect(spyOnSend).toHaveBeenCalledWith<[SendToPlugin<RawMessageRequest>]>({
 52: 				action: actionInfo.action,
 53: 				context: uuid,
 54: 				event: "sendToPlugin",
 55: 				payload: {
 56: 					__type: "request",
 57: 					id: mockUUID,
 58: 					path: "public:/outbound/request",
 59: 					unidirectional: true,
 60: 					body: {
 61: 						name: "Elgato",
 62: 					},
 63: 				},
 64: 			});
 65: 		});
 66: 	});
 67: 	it("receives onSendToPropertyInspector", async () => {
 68: 		const listener = jest.fn();
 69: 		const ev: DidReceivePluginMessage<PayloadOrSettings> = {
 70: 			action: "com.elgato.test.one",
 71: 			context: "action123",
 72: 			event: "sendToPropertyInspector",
 73: 			payload: {
 74: 				message: "Testing onMessage",
 75: 			},
 76: 		};
 77: 		const disposable = plugin.onSendToPropertyInspector(listener);
 78: 		connection.emit("sendToPropertyInspector", ev);
 79: 		expect(listener).toHaveBeenCalledTimes(1);
 80: 		expect(listener).toHaveBeenCalledWith<[SendToPropertyInspectorEvent<PayloadOrSettings, PayloadOrSettings>]>({
 81: 			action: {
 82: 				id: "action123",
 83: 				manifestId: "com.elgato.test.one",
 84: 				getSettings,
 85: 				setSettings,
 86: 			},
 87: 			payload: {
 88: 				message: "Testing onMessage",
 89: 			},
 90: 			type: "sendToPropertyInspector",
 91: 		});
 92: 		disposable.dispose();
 93: 		connection.emit("sendToPropertyInspector", ev);
 94: 		expect(listener).toHaveBeenCalledTimes(1);
 95: 	});
 96: 	it("registerRoute", () => {
 97: 		const spyOnRoute = jest.spyOn(router, "route");
 98: 		const handler = jest.fn();
 99: 		const options = {
100: 			filter: () => true,
101: 		};
102: 		plugin.registerRoute("/register", handler, options);
103: 		expect(spyOnRoute).toHaveBeenCalledTimes(1);
104: 		expect(spyOnRoute).toHaveBeenCalledWith("public:/register", handler, options);
105: 	});
106: 	it("receives request", async () => {
107: 		const awaiter = new PromiseCompletionSource();
108: 		const listener = jest.fn().mockImplementation(() => awaiter.setResult(true));
109: 		const ev = {
110: 			action: actionInfo.action,
111: 			context: uuid,
112: 			event: "sendToPropertyInspector",
113: 			payload: {
114: 				__type: "request",
115: 				id: "abc123",
116: 				path: "public:/receive",
117: 				unidirectional: false,
118: 				body: {
119: 					name: "Elgato",
120: 				},
121: 			},
122: 		} satisfies DidReceivePluginMessage<RawMessageRequest>;
123: 		const disposable = plugin.registerRoute("/receive", listener);
124: 		connection.emit("sendToPropertyInspector", ev);
125: 		await awaiter.promise;
126: 		expect(listener).toHaveBeenCalledTimes(1);
127: 		expect(listener).toHaveBeenCalledWith<[MessageRequest, MessageResponder]>(
128: 			{
129: 				action: {
130: 					id: uuid,
131: 					manifestId: actionInfo.action,
132: 					getSettings,
133: 					setSettings,
134: 				},
135: 				path: "public:/receive",
136: 				unidirectional: false,
137: 				body: {
138: 					name: "Elgato",
139: 				},
140: 			},
141: 			expect.any(MessageResponder),
142: 		);
143: 		disposable.dispose();
144: 		connection.emit("sendToPropertyInspector", ev);
145: 		expect(listener).toHaveBeenCalledTimes(1);
146: 	});
147: 	it("sends sendToPlugin", async () => {
148: 		await plugin.sendToPlugin({
149: 			message: "Testing sendToPlugin",
150: 		});
151: 		expect(connection.send).toHaveBeenCalledTimes(1);
152: 		expect(connection.send).toHaveBeenCalledWith<[SendToPlugin]>({
153: 			action: actionInfo.action,
154: 			context: uuid,
155: 			event: "sendToPlugin",
156: 			payload: {
157: 				message: "Testing sendToPlugin",
158: 			},
159: 		});
160: 	});
161: });
162: type PayloadOrSettings = {
163: 	message: string;
164: };
</file>

<file path="src/ui/__tests__/settings.test.ts">
  1: import type { DidReceiveGlobalSettingsEvent, DidReceiveSettingsEvent } from "..";
  2: import type {
  3: 	DidReceiveGlobalSettings,
  4: 	DidReceiveSettings,
  5: 	GetGlobalSettings,
  6: 	SetGlobalSettings,
  7: 	UIGetSettings,
  8: 	UISetSettings,
  9: } from "../../api";
 10: import { actionInfo } from "../../api/registration/__mocks__";
 11: import { PromiseCompletionSource } from "../../common/promises";
 12: import { connection } from "../connection";
 13: import {
 14: 	getGlobalSettings,
 15: 	getSettings,
 16: 	onDidReceiveGlobalSettings,
 17: 	onDidReceiveSettings,
 18: 	setGlobalSettings,
 19: 	setSettings,
 20: } from "../settings";
 21: jest.mock("../connection");
 22: describe("settings", () => {
 23: 	let uuid!: string;
 24: 	beforeAll(async () => ({ uuid } = await connection.getInfo()));
 25: 	it("can getGlobalSettings", async () => {
 26: 		const sendAwaiter = new PromiseCompletionSource<boolean>();
 27: 		const spyOnSend = jest.spyOn(connection, "send").mockImplementation(() => {
 28: 			sendAwaiter.setResult(true);
 29: 			return Promise.resolve();
 30: 		});
 31: 		const settings = getGlobalSettings<Settings>();
 32: 		await sendAwaiter.promise;
 33: 		expect(spyOnSend).toHaveBeenCalledTimes(1);
 34: 		expect(spyOnSend).toHaveBeenLastCalledWith({
 35: 			event: "getGlobalSettings",
 36: 			context: uuid,
 37: 		} satisfies GetGlobalSettings);
 38: 		expect(Promise.race([settings, false])).resolves.toBe(false);
 39: 		connection.emit("didReceiveGlobalSettings", {
 40: 			event: "didReceiveGlobalSettings",
 41: 			payload: {
 42: 				settings: {
 43: 					message: "Testing getGlobalSettings",
 44: 				},
 45: 			},
 46: 		} satisfies DidReceiveGlobalSettings<Settings>);
 47: 		await settings;
 48: 		expect(settings).resolves.toEqual<Settings>({
 49: 			message: "Testing getGlobalSettings",
 50: 		});
 51: 	});
 52: 	it("can getSettings", async () => {
 53: 		const sendAwaiter = new PromiseCompletionSource<boolean>();
 54: 		const spyOnSend = jest.spyOn(connection, "send").mockImplementation(() => {
 55: 			sendAwaiter.setResult(true);
 56: 			return Promise.resolve();
 57: 		});
 58: 		const settings = getSettings<Settings>();
 59: 		await sendAwaiter.promise;
 60: 		expect(spyOnSend).toHaveBeenCalledTimes(1);
 61: 		expect(spyOnSend).toHaveBeenLastCalledWith({
 62: 			event: "getSettings",
 63: 			action: actionInfo.action,
 64: 			context: uuid,
 65: 		} satisfies UIGetSettings);
 66: 		expect(Promise.race([settings, false])).resolves.toBe(false);
 67: 		connection.emit("didReceiveSettings", {
 68: 			event: "didReceiveSettings",
 69: 			action: actionInfo.action,
 70: 			context: "action123",
 71: 			device: "dev123",
 72: 			payload: {
 73: 				controller: "Encoder",
 74: 				coordinates: {
 75: 					column: 1,
 76: 					row: 0,
 77: 				},
 78: 				isInMultiAction: false,
 79: 				settings: {
 80: 					message: "Testing getSettings",
 81: 				},
 82: 			},
 83: 		} satisfies DidReceiveSettings<Settings>);
 84: 		await settings;
 85: 		expect(settings).resolves.toEqual<Settings>({
 86: 			message: "Testing getSettings",
 87: 		});
 88: 	});
 89: 	it("receives onDidReceiveGlobalSettings", async () => {
 90: 		const listener = jest.fn();
 91: 		const ev: DidReceiveGlobalSettings<Settings> = {
 92: 			event: "didReceiveGlobalSettings",
 93: 			payload: {
 94: 				settings: {
 95: 					message: "Testing didReceiveGlobalSettings",
 96: 				},
 97: 			},
 98: 		};
 99: 		const disposable = onDidReceiveGlobalSettings(listener);
100: 		connection.emit("didReceiveGlobalSettings", ev);
101: 		expect(listener).toHaveBeenCalledTimes(1);
102: 		expect(listener).toHaveBeenCalledWith<[DidReceiveGlobalSettingsEvent<Settings>]>({
103: 			settings: {
104: 				message: "Testing didReceiveGlobalSettings",
105: 			},
106: 			type: "didReceiveGlobalSettings",
107: 		});
108: 		disposable.dispose();
109: 		connection.emit("didReceiveGlobalSettings", ev);
110: 		expect(listener).toHaveBeenCalledTimes(1);
111: 	});
112: 	it("receives onDidReceiveSettings", async () => {
113: 		const listener = jest.fn();
114: 		const ev: DidReceiveSettings<Settings> = {
115: 			event: "didReceiveSettings",
116: 			action: "com.elgato.test.key",
117: 			context: "action123",
118: 			device: "dev123",
119: 			payload: {
120: 				controller: "Keypad",
121: 				coordinates: {
122: 					column: 2,
123: 					row: 2,
124: 				},
125: 				isInMultiAction: false,
126: 				settings: {
127: 					message: "Testing onDidReceiveSettings",
128: 				},
129: 			},
130: 		};
131: 		const disposable = onDidReceiveSettings(listener);
132: 		connection.emit("didReceiveSettings", ev);
133: 		expect(listener).toHaveBeenCalledTimes(1);
134: 		expect(listener).toHaveBeenCalledWith<[DidReceiveSettingsEvent<Settings>]>({
135: 			action: {
136: 				id: ev.context,
137: 				manifestId: ev.action,
138: 				getSettings,
139: 				setSettings,
140: 			},
141: 			payload: ev.payload,
142: 			type: "didReceiveSettings",
143: 		});
144: 		disposable.dispose();
145: 		connection.emit("didReceiveSettings", ev);
146: 		expect(listener).toHaveBeenCalledTimes(1);
147: 	});
148: 	it("sends setGlobalSettings", async () => {
149: 		await setGlobalSettings({
150: 			message: "Testing setGlobalSettings",
151: 		});
152: 		expect(connection.send).toHaveBeenCalledTimes(1);
153: 		expect(connection.send).toHaveBeenCalledWith<[SetGlobalSettings]>({
154: 			context: uuid,
155: 			event: "setGlobalSettings",
156: 			payload: {
157: 				message: "Testing setGlobalSettings",
158: 			},
159: 		});
160: 	});
161: 	it("sends setSettings", async () => {
162: 		await setSettings({
163: 			message: "Testing setSettings",
164: 		});
165: 		expect(connection.send).toHaveBeenCalledTimes(1);
166: 		expect(connection.send).toHaveBeenCalledWith<[UISetSettings]>({
167: 			action: actionInfo.action,
168: 			context: uuid,
169: 			event: "setSettings",
170: 			payload: {
171: 				message: "Testing setSettings",
172: 			},
173: 		});
174: 	});
175: });
176: type Settings = {
177: 	message: string;
178: };
</file>

<file path="src/ui/__tests__/system.test.ts">
 1: import type { OpenUrl } from "../../api";
 2: import { connection } from "../connection";
 3: import { openUrl } from "../system";
 4: jest.mock("../connection");
 5: describe("system", () => {
 6: 	it("sends openUrl", async () => {
 7: 		await openUrl("https://elgato.com");
 8: 		expect(connection.send).toHaveBeenCalledTimes(1);
 9: 		expect(connection.send).toHaveBeenCalledWith<[OpenUrl]>({
10: 			event: "openUrl",
11: 			payload: {
12: 				url: "https://elgato.com",
13: 			},
14: 		});
15: 	});
16: });
</file>

<file path="src/ui/action.ts">
1: import type { JsonObject } from "../common/json";
2: export type Action<T extends JsonObject = JsonObject> = {
3: 	readonly id: string;
4: 	readonly manifestId: string;
5: 	getSettings<U extends JsonObject = T>(): Promise<U>;
6: 	setSettings(settings: T): Promise<void>;
7: };
</file>

<file path="src/ui/connection.ts">
 1: import type { ActionInfo, ConnectElgatoStreamDeckSocketFn, RegistrationInfo, UICommand, UIEventMap } from "../api";
 2: import { EventEmitter } from "../common/event-emitter";
 3: import { PromiseCompletionSource } from "../common/promises";
 4: declare global {
 5: 	interface Window {
 6: 		connectElgatoStreamDeckSocket: ConnectElgatoStreamDeckSocketFn;
 7: 	}
 8: }
 9: class Connection extends EventEmitter<ExtendedUIEventMap> {
10: 	private canConnect = true;
11: 	private readonly connection = new PromiseCompletionSource<WebSocket>();
12: 	private readonly info = new PromiseCompletionSource<ConnectionInfo>();
13: 	constructor() {
14: 		super();
15: 		window.connectElgatoStreamDeckSocket = (
16: 			port: string,
17: 			uuid: string,
18: 			event: string,
19: 			info: string,
20: 			actionInfo: string,
21: 		): Promise<void> => {
22: 			return this.connect(port, uuid, event, JSON.parse(info), JSON.parse(actionInfo));
23: 		};
24: 	}
25: 	public async getInfo(): Promise<ConnectionInfo> {
26: 		return this.info.promise;
27: 	}
28: 	public async send(command: UICommand): Promise<void> {
29: 		const connection = await this.connection.promise;
30: 		const message = JSON.stringify(command);
31: 		connection.send(message);
32: 	}
33: 	private async connect(
34: 		port: string,
35: 		uuid: string,
36: 		event: string,
37: 		info: RegistrationInfo,
38: 		actionInfo: ActionInfo,
39: 	): Promise<void> {
40: 		if (this.canConnect) {
41: 			this.canConnect = false;
42: 			this.emit("connecting", info, actionInfo);
43: 			const webSocket = new WebSocket(`ws://127.0.0.1:${port}`);
44: 			webSocket.onmessage = (ev: MessageEvent<string>): void => this.tryEmit(ev);
45: 			webSocket.onopen = (): void => {
46: 				webSocket.send(JSON.stringify({ event, uuid }));
47: 				this.connection.setResult(webSocket);
48: 				this.emit("connected", info, actionInfo);
49: 				this.info.setResult({ uuid, info, actionInfo });
50: 			};
51: 		}
52: 		await this.connection.promise;
53: 	}
54: 	private tryEmit(ev: MessageEvent<string>): void {
55: 		const message = JSON.parse(ev.data);
56: 		if (message.event) {
57: 			this.emit(message.event, message);
58: 		}
59: 	}
60: }
61: export type ConnectionInfo = {
62: 	uuid: string;
63: 	info: RegistrationInfo;
64: 	actionInfo: ActionInfo;
65: };
66: type ExtendedUIEventMap = UIEventMap & {
67: 	connecting: [info: RegistrationInfo, actionInfo: ActionInfo];
68: 	connected: [info: RegistrationInfo, actionInfo: ActionInfo];
69: };
70: export const connection = new Connection();
</file>

<file path="src/ui/events.ts">
 1: import type { DidReceivePluginMessage, DidReceiveSettings } from "../api";
 2: import type { ActionEvent, Event } from "../common/events";
 3: import type { JsonObject, JsonValue } from "../common/json";
 4: import type { Action } from "./action";
 5: export { DidReceiveGlobalSettingsEvent } from "../common/events";
 6: export type SendToPropertyInspectorEvent<TPayload extends JsonValue, TSettings extends JsonObject> = Event<
 7: 	DidReceivePluginMessage<TPayload>
 8: > & {
 9: 	action: Action<TSettings>;
10: 	payload: TPayload;
11: };
12: export type DidReceiveSettingsEvent<TSettings extends JsonObject> = ActionEvent<
13: 	DidReceiveSettings<TSettings>,
14: 	Action<TSettings>
15: >;
</file>

<file path="src/ui/i18n.ts">
 1: import type { Language } from "../api";
 2: import { I18nProvider, parseLocalizations } from "../common/i18n";
 3: import type { JsonObject } from "../common/json";
 4: import { logger } from "./logging";
 5: const __cwd = cwd();
 6: export const i18n = new I18nProvider(
 7: 	(window.navigator.language ? window.navigator.language.split("-")[0] : "en") as Language,
 8: 	xmlHttpRequestLocaleProviderSync,
 9: );
10: export function xmlHttpRequestLocaleProviderSync(language: Language): JsonObject | null {
11: 	const filePath = `${__cwd}${language}.json`;
12: 	try {
13: 		const req = new XMLHttpRequest();
14: 		req.open("GET", filePath, false);
15: 		req.send();
16: 		return parseLocalizations(req.response);
17: 	} catch (err) {
18: 		if (err instanceof DOMException && err.name === "NOT_FOUND_ERR") {
19: 			console.warn(`Missing localization file: ${language}.json`);
20: 		} else {
21: 			logger.error(`Failed to load translations from ${filePath}`, err);
22: 		}
23: 		return null;
24: 	}
25: }
26: export function cwd(): string {
27: 	let path = "";
28: 	const segments = window.location.href.split("/");
29: 	for (let i = 0; i < segments.length - 1; i++) {
30: 		path += `${segments[i]}/`;
31: 		if (segments[i].endsWith(".sdPlugin")) {
32: 			break;
33: 		}
34: 	}
35: 	return path;
36: }
</file>

<file path="src/ui/index.ts">
 1: import { type ActionInfo, type RegistrationInfo } from "../api";
 2: import type { IDisposable } from "../common/disposable";
 3: import type { JsonObject } from "../common/json";
 4: import { connection } from "./connection";
 5: import { i18n } from "./i18n";
 6: import { logger } from "./logging";
 7: import { plugin } from "./plugin";
 8: import * as settings from "./settings";
 9: import * as system from "./system";
10: export {
11: 	DeviceType,
12: 	type ActionInfo,
13: 	type ConnectElgatoStreamDeckSocketFn,
14: 	type Controller,
15: 	type RegistrationInfo,
16: } from "../api";
17: export { Enumerable } from "../common/enumerable";
18: export { EventEmitter } from "../common/event-emitter";
19: export { type JsonObject, type JsonPrimitive, type JsonValue } from "../common/json";
20: export { LogLevel, type Logger } from "../common/logging";
21: export {
22: 	type MessageRequestOptions,
23: 	type MessageResponder,
24: 	type MessageResponse,
25: 	type RouteConfiguration,
26: 	type StatusCode,
27: } from "../common/messaging";
28: export type * from "./events";
29: export { type MessageHandler, type MessageRequest } from "./plugin";
30: const streamDeck = {
31: 	i18n,
32: 	logger,
33: 	plugin,
34: 	settings,
35: 	system,
36: 	onConnecting: <TSettings extends JsonObject = JsonObject>(
37: 		listener: (info: RegistrationInfo, actionInfo: ActionInfo<TSettings>) => void,
38: 	): IDisposable => {
39: 		return connection.disposableOn("connecting", listener);
40: 	},
41: 	onConnected: <TSettings extends JsonObject = JsonObject>(
42: 		listener: (info: RegistrationInfo, actionInfo: ActionInfo<TSettings>) => void,
43: 	): IDisposable => {
44: 		return connection.disposableOn("connected", listener);
45: 	},
46: };
47: export default streamDeck;
</file>

<file path="src/ui/logging.ts">
1: import { ConsoleTarget, createRoutedLogTarget, Logger, LogLevel } from "../common/logging";
2: import { router } from "./plugin";
3: export const logger = new Logger({
4: 	level: LogLevel.DEBUG,
5: 	targets: [new ConsoleTarget(), createRoutedLogTarget(router)],
6: });
</file>

<file path="src/ui/plugin.ts">
 1: import type { IDisposable } from "../common/disposable";
 2: import type { JsonObject, JsonValue } from "../common/json";
 3: import {
 4: 	MessageGateway,
 5: 	type MessageRequestOptions,
 6: 	type MessageResponder,
 7: 	type MessageResponse,
 8: 	PUBLIC_PATH_PREFIX,
 9: 	type RouteConfiguration,
10: 	type UnscopedMessageHandler,
11: 	type UnscopedMessageRequest,
12: } from "../common/messaging";
13: import type { Action } from "./action";
14: import { connection } from "./connection";
15: import type { SendToPropertyInspectorEvent } from "./events";
16: import { getSettings, setSettings } from "./settings";
17: const router = new MessageGateway<Action>(
18: 	async (payload: JsonValue) => {
19: 		await sendPayload(payload);
20: 		return true;
21: 	},
22: 	({ context: id, action: manifestId }) => ({ id, manifestId, getSettings, setSettings }) satisfies Action,
23: );
24: connection.on("sendToPropertyInspector", (ev) => router.process(ev));
25: class PluginController {
26: 	public async fetch<T extends JsonValue = JsonValue>(request: MessageRequestOptions): Promise<MessageResponse<T>>;
27: 	public async fetch<T extends JsonValue = JsonValue>(path: string, body?: JsonValue): Promise<MessageResponse<T>>;
28: 	public async fetch<T extends JsonValue = JsonValue>(
29: 		requestOrPath: MessageRequestOptions | string,
30: 		bodyOrUndefined?: JsonValue,
31: 	): Promise<MessageResponse<T>> {
32: 		if (typeof requestOrPath === "string") {
33: 			return router.fetch(`${PUBLIC_PATH_PREFIX}${requestOrPath}`, bodyOrUndefined);
34: 		} else {
35: 			return router.fetch({
36: 				...requestOrPath,
37: 				path: `${PUBLIC_PATH_PREFIX}${requestOrPath.path}`,
38: 			});
39: 		}
40: 	}
41: 	public onSendToPropertyInspector<TPayload extends JsonValue = JsonValue, TSettings extends JsonObject = JsonObject>(
42: 		listener: (ev: SendToPropertyInspectorEvent<TPayload, TSettings>) => void,
43: 	): IDisposable {
44: 		return router.disposableOn("unhandledMessage", (ev) => {
45: 			listener({
46: 				action: {
47: 					id: ev.context,
48: 					manifestId: ev.action,
49: 					getSettings,
50: 					setSettings,
51: 				},
52: 				payload: ev.payload as TPayload,
53: 				type: "sendToPropertyInspector",
54: 			});
55: 		});
56: 	}
57: 	public registerRoute<TBody extends JsonValue = JsonValue, TSettings extends JsonObject = JsonObject>(
58: 		path: string,
59: 		handler: MessageHandler<TBody, TSettings>,
60: 		options?: RouteConfiguration<Action>,
61: 	): IDisposable {
62: 		return router.route(`${PUBLIC_PATH_PREFIX}${path}`, handler, options);
63: 	}
64: 	public async sendToPlugin(payload: JsonValue): Promise<void> {
65: 		return sendPayload(payload);
66: 	}
67: }
68: async function sendPayload(payload: JsonValue): Promise<void> {
69: 	const {
70: 		uuid,
71: 		actionInfo: { action },
72: 	} = await connection.getInfo();
73: 	return connection.send({
74: 		event: "sendToPlugin",
75: 		action,
76: 		context: uuid,
77: 		payload,
78: 	});
79: }
80: export const plugin = new PluginController();
81: export { router, type PluginController };
82: export type MessageRequest<
83: 	TBody extends JsonValue = JsonValue,
84: 	TSettings extends JsonObject = JsonObject,
85: > = UnscopedMessageRequest<Action<TSettings>, TBody>;
86: export type MessageHandler<TBody extends JsonValue = JsonValue, TSettings extends JsonObject = JsonObject> = (
87: 	request: MessageRequest<TBody, TSettings>,
88: 	responder: MessageResponder,
89: ) => ReturnType<UnscopedMessageHandler<Action<TSettings>, TBody>>;
</file>

<file path="src/ui/settings.ts">
 1: import type { DidReceiveGlobalSettings, DidReceiveSettings } from "../api";
 2: import type { IDisposable } from "../common/disposable";
 3: import type { JsonObject } from "../common/json";
 4: import { connection } from "./connection";
 5: import type { DidReceiveGlobalSettingsEvent, DidReceiveSettingsEvent } from "./events";
 6: export async function getGlobalSettings<T extends JsonObject = JsonObject>(): Promise<T> {
 7: 	const { uuid } = await connection.getInfo();
 8: 	return new Promise((resolve) => {
 9: 		connection.once("didReceiveGlobalSettings", (ev: DidReceiveGlobalSettings<T>) => resolve(ev.payload.settings));
10: 		connection.send({
11: 			event: "getGlobalSettings",
12: 			context: uuid,
13: 		});
14: 	});
15: }
16: export async function getSettings<T extends JsonObject = JsonObject>(): Promise<T> {
17: 	const {
18: 		uuid,
19: 		actionInfo: { action },
20: 	} = await connection.getInfo();
21: 	return new Promise((resolve) => {
22: 		connection.once("didReceiveSettings", (ev: DidReceiveSettings<T>) => resolve(ev.payload.settings));
23: 		connection.send({
24: 			event: "getSettings",
25: 			action,
26: 			context: uuid,
27: 		});
28: 	});
29: }
30: export function onDidReceiveGlobalSettings<T extends JsonObject = JsonObject>(
31: 	listener: (ev: DidReceiveGlobalSettingsEvent<T>) => void,
32: ): IDisposable {
33: 	return connection.disposableOn("didReceiveGlobalSettings", (ev: DidReceiveGlobalSettings<T>) =>
34: 		listener({
35: 			settings: ev.payload.settings,
36: 			type: ev.event,
37: 		}),
38: 	);
39: }
40: export function onDidReceiveSettings<T extends JsonObject = JsonObject>(
41: 	listener: (ev: DidReceiveSettingsEvent<T>) => void,
42: ): IDisposable {
43: 	return connection.disposableOn("didReceiveSettings", (ev: DidReceiveSettings<T>) =>
44: 		listener({
45: 			action: {
46: 				id: ev.context,
47: 				manifestId: ev.action,
48: 				getSettings,
49: 				setSettings,
50: 			},
51: 			payload: ev.payload,
52: 			type: ev.event,
53: 		}),
54: 	);
55: }
56: export async function setGlobalSettings<T extends JsonObject>(settings: T): Promise<void> {
57: 	const { uuid } = await connection.getInfo();
58: 	return connection.send({
59: 		event: "setGlobalSettings",
60: 		context: uuid,
61: 		payload: settings,
62: 	});
63: }
64: export async function setSettings<T extends JsonObject>(settings: T): Promise<void> {
65: 	const {
66: 		uuid,
67: 		actionInfo: { action },
68: 	} = await connection.getInfo();
69: 	return connection.send({
70: 		event: "setSettings",
71: 		action,
72: 		context: uuid,
73: 		payload: settings,
74: 	});
75: }
</file>

<file path="src/ui/system.ts">
1: import { connection } from "./connection";
2: export function openUrl(url: string): Promise<void> {
3: 	return connection.send({
4: 		event: "openUrl",
5: 		payload: {
6: 			url,
7: 		},
8: 	});
9: }
</file>

<file path="src/ui/tsconfig.build.json">
 1: {
 2:     "extends": "./tsconfig.json",
 3:     "compilerOptions": {
 4:         "declaration": true,
 5:         "declarationDir": "../../dist/types"
 6:     },
 7:     "exclude": [
 8:         "**/__mocks__/",
 9:         "**/__tests__/"
10:     ]
11: }
</file>

<file path="src/ui/tsconfig.json">
 1: {
 2:     "compilerOptions": {
 3:         "customConditions": [
 4:             "browser"
 5:         ],
 6:         "esModuleInterop": true,
 7:         "forceConsistentCasingInFileNames": true,
 8:         "lib": [
 9:             "dom",
10:             "es2022"
11:         ],
12:         "module": "es2022",
13:         "moduleResolution": "Bundler",
14:         "skipLibCheck": true,
15:         "strict": true,
16:         "target": "es2022"
17:     },
18:     "include": [
19:         "./"
20:     ]
21: }
</file>

<file path="tests/__setup__/global.ts">
1: export default function (): void {
2: 	process.env.TZ = "UTC";
3: }
</file>

<file path="tests/utils.ts">
1: export type Expect<T extends true> = T;
2: export type Prettify<T> = { [k in keyof T]: T[k] extends object ? Prettify<T[k]> : T[k] } & {};
3: export type TypesAreEqual<T, U> =
4: 	(<G>() => G extends Prettify<T> ? 1 : 2) extends <G>() => G extends Prettify<U> ? 1 : 2 ? true : false;
</file>

<file path=".editorconfig">
 1: root = true
 2: 
 3: [*]
 4: charset = utf-8
 5: end_of_line = lf
 6: insert_final_newline = true
 7: indent_style = tab
 8: max_line_length = 120
 9: 
10: [*.{json,jsonc,md}]
11: indent_size = 4
12: indent_style = space
13: 
14: [*.{yaml,yml}]
15: indent_size = 2
16: indent_style = space
</file>

<file path=".gitignore">
1: # Node.js
2: node_modules/
3: 
4: # Tests
5: coverage/
6: 
7: # Build output
8: dist/
9: types/
</file>

<file path=".npmrc">
1: sign-git-tag=true
</file>

<file path="CHANGELOG.md">
  1: <!--
  2: 
  3: ## {version}
  4: 
  5: ‚ö†Ô∏è Breaking change
  6: ‚ú® New
  7: üêû Fix
  8: ‚ôªÔ∏è Refactor / Enhance / Update
  9: ‚¨ÜÔ∏è Upgrading
 10: 
 11: -->
 12: 
 13: # Change Log
 14: 
 15: ## 1.3.0
 16: 
 17: ### ‚ú® New
 18: 
 19: -   Add support for serializing enumerable collections.
 20: 
 21: ### ‚ôªÔ∏è Update
 22: 
 23: -   Improve documentation for profile switching.
 24: -   Update dependencies.
 25: 
 26: ## 1.2.1
 27: 
 28: ### ‚ôªÔ∏è Update
 29: 
 30: -   Update `@elgato/schemas` dependency.
 31: 
 32: ### üêû Fix
 33: 
 34: -   Fix Node.js engine requirements.
 35: 
 36: ## 1.2.0
 37: 
 38: ### ‚ú® New
 39: 
 40: -   Add support for Chinese (Traditional).
 41: 
 42: ### üêû Fix
 43: 
 44: -   Fix types of `EventEmitter` event arguments.
 45: 
 46: ## 1.1.0
 47: 
 48: ### ‚ú® New
 49: 
 50: -   Add [`.drop()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/drop), [`.flapMap()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/flatMap), [`.take()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/take), and [`.toArray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/toArray) iterator helper polyfills to `Enumerable`.
 51: 
 52: ### ‚ôªÔ∏è Update
 53: 
 54: -   Update `SingletonAction.actions` to return an `Enumerable`.
 55: 
 56: ## 1.0.1
 57: 
 58: ### ‚ôªÔ∏è Update
 59: 
 60: -   Update minimum allowed log level in production to be `DEBUG` to assist with debugging (default remains `INFO`).
 61: 
 62: ## 1.0.0
 63: 
 64: ### ‚ú® New
 65: 
 66: -   Add action tracking, allowing access to currently visible actions.
 67:     -   `streamDeck.actions` ‚Äî all visible actions.
 68:     -   `SingletonAction.actions` ‚Äî visible actions that match the action's UUID.
 69: -   Add `setTitle` to `DialAction`, allowing you to set the title of a layout.
 70: -   Add `Enumerable` class for creating readonly collections.
 71: -   Add device information to `Action` provided in event arguments.
 72: -   Add iterator helpers to `streamDeck.devices` and `streamDeck.actions`.
 73: 
 74: ### üêû Fix
 75: 
 76: -   Fix missing language support for Korean (ko).
 77: -   Fix TypeScript declaration incorrectly exporting types as classes.
 78: 
 79: ### ‚ôªÔ∏è Update
 80: 
 81: -   Remove `streamDeck.actions.createController` in favor of `streamDeck.actions.getActionById`.
 82: -   Remove `Action.sendToPropertyInspector` in favour of `streamDeck.ui.current.sendToPropertyInspector`.
 83: -   Remove `ev.deviceId` in favour of `ev.action.device.id`.
 84: -   Rename `onDidConnect` to `onConnected` within the UI.
 85: 
 86: ### ‚¨ÜÔ∏è Upgrading
 87: 
 88: -   For information on breaking changes, and migrating to the this version, read more about [upgrading to v1.0.0](/UPGRADE.md#v1-0-0).
 89: 
 90: ## 0.4.0-beta
 91: 
 92: ### ‚ú® New
 93: 
 94: -   Package can now be imported in both Node.js and the browser (in the scope of a property inspector).
 95: -   Add support for property inspector.
 96:     -   Add `streamDeck.onDidConnect` event listener.
 97:     -   Add `streamDeck.settings` namespace for interacting with settings.
 98:     -   Add `streamDeck.system` namespace for system-related operations.
 99:     -   Add `streamDeck.plugin` namespace for bi-direction communication with the plugin and the UI.
100: -   Add `isInMultiAction` to the property inspector's action information.
101: 
102: ### üêû Fix
103: 
104: -   `Coordinates` type could erroneously have a non-number type for `row`.
105: -   Fix support for allowed types within payloads.
106: -   Fix localization lookup to index from `Localization`.
107: -   Fix race condition when tracking the property inspector.
108: -   Fix `streamDeck.setGlobalSettings` to require settings that extend `JsonObject`.
109: 
110: ### ‚ôªÔ∏è Update
111: 
112: -   Update layout and manifest references to propagate from [`@elgato/schemas`](https://github.com/elgatosf/schemas).
113: -   Localization lookup will now return the key if the resource is not defined.
114: -   Update structure of JSON localizations.
115: -   Update `State` type to allow for more than two states.
116: -   Update routing to prevent exposure of internal messages.
117: -   Update build to export Stream Deck API types.
118: -   Update `ws` dependency.
119: 
120: ### ‚¨ÜÔ∏è Upgrading
121: 
122: -   For information on breaking changes, and migrating to the this version, read more about [upgrading to v0.4.0](/UPGRADE.md#v0-4-0).
123: 
124: ## 0.3.0
125: 
126: ### ‚ú® New
127: 
128: -   Add cross-compatible event emitter with type support.
129: -   Add pattern validation for manifest's `Version`.
130: -   Add validation of colors defined within the manifest.
131: 
132: ### üêû Fix
133: 
134: -   Fix `PayloadObject` not being exported; enables inheritance of actions.
135: -   Fix manifest layout not allowing `$A0` as a pre-defined value.
136: 
137: ### ‚ôªÔ∏è Update
138: 
139: -   Update manifest file path validation to prevent referencing a file outside of the plugin directory.
140: -   Update manifest file path validation to allow periods.
141: -   Update manifest UUID validation to allow more than 3 segments.
142: -   Update manifest UUID validation to prevent underscores.
143: -   Update documentation of `Actions[].Image` to reflect support for .gif files.
144: -   Update default export to be named (improving VSCode intellisense).
145: 
146: ### üóëÔ∏è Remove
147: 
148: -   Remove `$A2` incorrectly being listed as a pre-defined layout.
149: 
150: ## 0.2.0
151: 
152: ### ‚ú® New
153: 
154: #### Stream Deck 6.5
155: 
156: -   Add support for receiving messages via deep-linking.
157:     -   URL format: `streamdeck://plugins/message/<PLUGIN_UUID>/<MESSAGE>`
158:     -   Accessible as part of the `system` namespace, `streamDeck.system.onDidReceiveDeepLink`
159: -   Add support for switching to a specific profile page when calling `switchToProfile`.
160: -   Add `controller` information to `WillAppear` and `WillDisappear` events for multi-actions.
161: -   Add support for Node.js plugins with the `.cjs` or `.mjs` file extensions.
162: 
163: #### Node.js SDK
164: 
165: -   Add `profiles`, `settings`, `system`, and `ui` namespaces.
166: -   Add `streamDeck.actions.createController(id)` to enable the control of a contextualized action.
167: -   Add `streamDeck.devices.getDeviceBy(deviceId)` to enable the selection of a device by identifier.
168: -   Add `length`, `forEach`, and `[Symbol.iterator]` to `streamDeck.devices` to enable iteration.
169: 
170: ### ‚ôªÔ∏è Improvements
171: 
172: -   Refactor `streamDeck.devices` to namespace.
173: -   Update manifest JSON schema to support Stream Deck 6.5.
174: -   Improve enum support in manifest and layout JSON schemas.
175: -   Node.js runtime updated to v20.8.1.
176: 
177: ### üêû Bug Fixes
178: 
179: -   Correctly validate paths without extensions in manifest JSON schema.
180: -   Default `text-overflow` set to `ellipsis` in layout JSON schema.
181: 
182: ### ‚¨ÜÔ∏è Upgrading
183: 
184: -   For information on breaking changes, and migrating to the this version, read more about [upgrading to v0.2.0](/UPGRADE.md#v0-2-0).
185: 
186: ## 0.1.0
187: 
188: ### ‚ú® New
189: 
190: -   Add Stream Deck communication client (see `streamDeck.client`).
191: -   Add support for receiving all events (Stream Deck 6.4).
192: -   Add support for sending all commands (Stream Deck 6.4).
193: -   Add action routing (see `streamDeck.actions`).
194: -   Add centralized device information tracking (see `streamDeck.devices`).
195: -   Add local file-based logging framework (see `streamDeck.logger`).
196: -   Add localization support (see `streamDeck.i18n`).
197: -   Add manifest information (see `streamDeck.manifest`).
198: -   Add Stream Deck and plugin information (see `streamDeck.info`).
</file>

<file path="eslint.config.mjs">
  1: import eslint from "@eslint/js";
  2: import tsParser from "@typescript-eslint/parser";
  3: import jsdoc from "eslint-plugin-jsdoc";
  4: import globals from "globals";
  5: import tsEslint from "typescript-eslint";
  6: 
  7: export default [
  8: 	{
  9: 		ignores: [".github/", "dist/", "node_modules/", "types/", "*.mjs"],
 10: 	},
 11: 
 12: 	/**
 13: 	 * Recommended configurations.
 14: 	 */
 15: 	jsdoc.configs["flat/recommended-typescript"],
 16: 	eslint.configs.recommended,
 17: 	...tsEslint.configs.recommended,
 18: 
 19: 	/**
 20: 	 * Main configuration.
 21: 	 */
 22: 	{
 23: 		plugins: {
 24: 			jsdoc,
 25: 		},
 26: 		languageOptions: {
 27: 			globals: {
 28: 				...globals.node,
 29: 			},
 30: 			parser: tsParser,
 31: 		},
 32: 		rules: {
 33: 			indent: [
 34: 				"warn",
 35: 				"tab",
 36: 				{
 37: 					SwitchCase: 1,
 38: 				},
 39: 			],
 40: 			"jsdoc/check-tag-names": [
 41: 				"warn",
 42: 				{
 43: 					definedTags: ["jest-environment"],
 44: 				},
 45: 			],
 46: 			"jsdoc/no-undefined-types": 1,
 47: 			"jsdoc/require-jsdoc": [
 48: 				"warn",
 49: 				{
 50: 					contexts: [
 51: 						"ClassDeclaration",
 52: 						"PropertyDefinition",
 53: 						"MethodDefinition",
 54: 						"TSEnumDeclaration",
 55: 						"TSEnumMember",
 56: 						"TSPropertySignature",
 57: 						"TSTypeAliasDeclaration",
 58: 					],
 59: 				},
 60: 			],
 61: 			"@typescript-eslint/explicit-member-accessibility": [
 62: 				"error",
 63: 				{
 64: 					accessibility: "explicit",
 65: 
 66: 					overrides: {
 67: 						constructors: "no-public",
 68: 					},
 69: 				},
 70: 			],
 71: 			"@typescript-eslint/explicit-function-return-type": "warn",
 72: 			"@typescript-eslint/member-ordering": [
 73: 				"warn",
 74: 				{
 75: 					default: {
 76: 						memberTypes: [
 77: 							"public-static-field",
 78: 							"public-abstract-field",
 79: 							"public-field",
 80: 							"protected-static-field",
 81: 							"protected-abstract-field",
 82: 							"protected-field",
 83: 							"private-static-field",
 84: 							"private-field",
 85: 							"public-constructor",
 86: 							"protected-constructor",
 87: 							"private-constructor",
 88: 							"signature",
 89: 							"call-signature",
 90: 							"public-static-get",
 91: 							"public-static-set",
 92: 							"public-abstract-get",
 93: 							"public-abstract-set",
 94: 							"public-get",
 95: 							"public-set",
 96: 							"protected-static-get",
 97: 							"protected-static-set",
 98: 							"protected-abstract-get",
 99: 							"protected-abstract-set",
100: 							"protected-get",
101: 							"protected-set",
102: 							"private-static-get",
103: 							"private-static-set",
104: 							"private-get",
105: 							"private-set",
106: 							"public-static-method",
107: 							"public-abstract-method",
108: 							"public-method",
109: 							"protected-static-method",
110: 							"protected-abstract-method",
111: 							"protected-method",
112: 							"private-static-method",
113: 							"private-method",
114: 						],
115: 
116: 						order: "alphabetically",
117: 					},
118: 				},
119: 			],
120: 			"@typescript-eslint/sort-type-constituents": "warn",
121: 		},
122: 	},
123: 
124: 	/**
125: 	 * Tests and mocks.
126: 	 */
127: 	{
128: 		files: ["{src,tests}/**/__mocks__/*.ts", "{src,tests}/**/__tests__/*test.ts"],
129: 		rules: {
130: 			"jsdoc/require-jsdoc": [
131: 				"warn",
132: 				{
133: 					contexts: ["MethodDefinition"],
134: 				},
135: 			],
136: 			"@typescript-eslint/explicit-function-return-type": "off",
137: 			"@typescript-eslint/no-explicit-any": "off",
138: 			"@typescript-eslint/no-require-imports": "off",
139: 		},
140: 	},
141: ];
</file>

<file path="jest.config.js">
 1: const config = {
 2: 	clearMocks: true,
 3: 	collectCoverageFrom: ["src/**/*.ts", "!<rootDir>/node_modules/"],
 4: 	coverageReporters: ["json-summary", "text"],
 5: 	globalSetup: "./tests/__setup__/global.ts",
 6: 	maxWorkers: 1,
 7: 	modulePathIgnorePatterns: ["<rootDir>/src/.+/__mocks__/.*"],
 8: 	verbose: true,
 9: 	roots: ["src"],
10: 	transform: {
11: 		"^.+\\.ts$": [
12: 			"@swc/jest",
13: 			{
14: 				jsc: {
15: 					parser: {
16: 						syntax: "typescript",
17: 						decorators: true,
18: 					},
19: 					transform: {
20: 						decoratorVersion: "2022-03",
21: 					},
22: 				},
23: 			},
24: 		],
25: 	},
26: };
27: export default config;
</file>

<file path="LICENSE">
 1: MIT License
 2: 
 3: Copyright (c) 2024 Corsair Memory Inc.
 4: 
 5: Permission is hereby granted, free of charge, to any person obtaining a copy
 6: of this software and associated documentation files (the "Software"), to deal
 7: in the Software without restriction, including without limitation the rights
 8: to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9: copies of the Software, and to permit persons to whom the Software is
10: furnished to do so, subject to the following conditions:
11: 
12: The above copyright notice and this permission notice shall be included in all
13: copies or substantial portions of the Software.
14: 
15: THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16: IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17: FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18: AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19: LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20: OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21: SOFTWARE.
</file>

<file path="package.json">
 1: {
 2:     "name": "@elgato/streamdeck",
 3:     "version": "1.3.0",
 4:     "description": "The official Node.js SDK for creating Stream Deck plugins.",
 5:     "main": "./dist/index.js",
 6:     "type": "module",
 7:     "engines": {
 8:         "node": ">=20.5.1"
 9:     },
10:     "files": [
11:         "./dist/*.js",
12:         "./dist/*.d.ts",
13:         "./types/**/*d.ts"
14:     ],
15:     "exports": {
16:         ".": {
17:             "browser": {
18:                 "default": "./dist/browser.js",
19:                 "types": "./dist/browser.d.ts"
20:             },
21:             "default": {
22:                 "default": "./dist/index.js",
23:                 "types": "./dist/index.d.ts"
24:             }
25:         }
26:     },
27:     "scripts": {
28:         "build": "rm -rf ./dist && rollup --config rollup.config.mjs && npm run types",
29:         "watch": "rollup --config rollup.config.mjs --watch --watch.onEnd=\"npm run types\"",
30:         "types": "rm -rf ./types && mkdir types && cp -r ./dist/types ./",
31:         "lint": "eslint --max-warnings 0",
32:         "lint:fix": "prettier . --write",
33:         "preversion": "npm run build && npm test && npm run lint",
34:         "test": "jest",
35:         "test:coverage": "jest --coverage",
36:         "test:watch": "jest --watch"
37:     },
38:     "prettier": "@elgato/prettier-config",
39:     "repository": {
40:         "type": "git",
41:         "url": "git+https://github.com/elgatosf/streamdeck.git"
42:     },
43:     "keywords": [
44:         "elgato",
45:         "stream deck",
46:         "plugin",
47:         "sdk",
48:         "framework",
49:         "marketplace",
50:         "maker"
51:     ],
52:     "author": {
53:         "name": "Elgato",
54:         "url": "https://www.elgato.com"
55:     },
56:     "license": "MIT",
57:     "bugs": {
58:         "url": "https://github.com/elgatosf/streamdeck/issues"
59:     },
60:     "homepage": "https://github.com/elgatosf/streamdeck#readme",
61:     "devDependencies": {
62:         "@elgato/prettier-config": "^0.2.4",
63:         "@eslint/js": "^9.18.0",
64:         "@rollup/plugin-node-resolve": "^16.0.0",
65:         "@rollup/plugin-typescript": "^12.1.2",
66:         "@swc/core": "^1.10.9",
67:         "@swc/jest": "^0.2.37",
68:         "@tsconfig/node20": "^20.1.4",
69:         "@types/eslint__js": "^8.42.3",
70:         "@types/jest": "^29.5.14",
71:         "@types/node": "^22.10.10",
72:         "@types/ws": "^8.5.14",
73:         "@typescript-eslint/eslint-plugin": "^8.21.0",
74:         "@typescript-eslint/parser": "^8.21.0",
75:         "eslint": "^9.18.0",
76:         "eslint-plugin-jsdoc": "^50.6.2",
77:         "jest": "^29.7.0",
78:         "jest-environment-jsdom": "^29.7.0",
79:         "jest-websocket-mock": "^2.5.0",
80:         "prettier": "^3.4.2",
81:         "rollup": "^4.32.0",
82:         "typescript": "^5.7.3",
83:         "typescript-eslint": "^8.21.0"
84:     },
85:     "dependencies": {
86:         "@elgato/schemas": "^0.4.1",
87:         "ws": "^8.18.0"
88:     }
89: }
</file>

<file path="README.md">
  1: <div align="center">
  2: 
  3: [![Stream Deck SDK banner](https://images.ctfassets.net/8j9xr8kwdre8/1ihLKCwNWEfPixs27dq0c0/130be66a5173f332e4caa892a3462893/banner.png)](https://docs.elgato.com/sdk)
  4: 
  5: # Stream Deck SDK
  6: 
  7: [![SDK documentation](https://img.shields.io/badge/Documentation-2ea043?labelColor=grey&logo=gitbook&logoColor=white)](https://docs.elgato.com/sdk)
  8: [![Elgato homepage](https://img.shields.io/badge/Elgato-3431cf?labelColor=grey&logo=data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+RWxnYXRvPC90aXRsZT48cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJtMTMuODgxOCA4LjM5NjQuMDI2MS4wMTk2IDkuOTQ5NCA1LjcxNzJjLS40ODg0IDIuNzI5LTEuOTE5NiA1LjIyMjMtNC4wMzg0IDcuMDI1M0ExMS45MjYyIDExLjkyNjIgMCAwIDEgMTIuMDk3IDI0Yy0zLjE5MjUgMC02LjE5MzktMS4yNDc3LTguNDUyNy0zLjUxNDRDMS4zODY4IDE4LjIxODguMTQyNyAxNS4yMDQ0LjE0MjcgMTJjMC0zLjIwNDIgMS4yNDQtNi4yMTg3IDMuNTAxNS04LjQ4NTRDNS45MDE5IDEuMjQ4IDguOTAzMiAwIDEyLjA5NyAwYzIuNDM5NCAwIDQuNzg0Ny43MzMzIDYuNzgzIDIuMTE4NyAxLjk1MjYgMS4zNTQgMy40NDY2IDMuMjM1NyA0LjMyMjcgNS40NDIyLjExMTIuMjgyOS4yMTQ5LjU3MzYuMzA1MS44NjU3bC0yLjEyNTUgMS4yMzU5YTkuNDkyNCA5LjQ5MjQgMCAwIDAtLjI2MTktLjg2OTRjLTEuMzU0LTMuODMwMy00Ljk4MTMtNi40MDQ4LTkuMDIzNy02LjQwNDhDNi44MTcxIDIuMzg4MyAyLjUyMiA2LjcwMDUgMi41MjIgMTJjMCA1LjI5OTUgNC4yOTUgOS42MTE1IDkuNTc0OCA5LjYxMTUgMi4wNTIgMCA0LjAwODQtLjY0NDIgNS42NTk2LTEuODY0NyAxLjYxNzItMS4xOTU1IDIuODAzNi0yLjgzMzcgMy40MzA5LTQuNzM2NGwuMDA2NS0uMDQxOUw5LjU5MDYgOC4zMDQ4djcuMjI1Nmw0LjAwMDQtMi4zMTM4IDIuMDYgMS4xODExLTUuOTk2MiAzLjQ2ODgtMi4xMi0xLjIxMjZWNy4xOTQzbDIuMTE3NC0xLjIyNDUgNC4yMzA5IDIuNDI3OS0uMDAxMy0uMDAxMyIvPjwvc3ZnPg==)](https://elgato.com)
  9: [![Join the Marketplace Makers Discord](https://img.shields.io/badge/Marketplace%20Makers-5662f6?labelColor=grey&logo=discord&logoColor=white)](https://discord.gg/GehBUcu627)
 10: [![Stream Deck npm package](https://img.shields.io/npm/v/%40elgato/streamdeck?logo=npm&logoColor=white)](https://www.npmjs.com/package/@elgato/streamdeck)
 11: [![Build status](https://img.shields.io/github/actions/workflow/status/elgatosf/streamdeck/build.yml?branch=main&label=Build&logo=GitHub)](https://github.com/elgatosf/streamdeck/actions)
 12: 
 13: </div>
 14: 
 15: Welcome to the Stream Deck SDK ‚Äî Designed to make creating plugins for Stream Deck easy, the Stream Deck SDK provides everything you need to connect and communicate with Stream Deck app, letting you focus on the fun stuff.
 16: 
 17: > Creating Stream Deck plugins with Node.js requires Node.js v20. When installing Node.js, we recommended using a version manager such as [nvm](https://github.com/creationix/nvm) (macOS) or [nvm-windows](https://github.com/coreybutler/nvm-windows) (Windows).
 18: 
 19: ## üöÄ Quick Start
 20: 
 21: The [Stream Deck CLI](https://github.com/elgatosf/cli) provides commands for creating, testing, and bundling your plugins, and is the easiest way to get started building for Stream Deck. You can also [learn more about getting started](https://docs.elgato.com/streamdeck/sdk/introduction/getting-started) in our documentation.
 22: 
 23: 1. With Node.js installed, install the CLI.
 24: 
 25: ```bash
 26: npm install -g @elgato/cli@latest
 27: ```
 28: 
 29: 2. Once installed, run the `create` command to initialize the creation wizard.
 30: 
 31: ```bash
 32: streamdeck create
 33: ```
 34: 
 35: <p align="center">
 36:   <img src="./assets/cli-create.gif">
 37: </p>
 38: 
 39: ## üìÇ File Structure
 40: 
 41: After creating a plugin with `streamdeck create` you'll be provided with a local environment for building a plugin.
 42: 
 43: ```
 44: /
 45: ‚îú‚îÄ‚îÄ *.sdPlugin/
 46: ‚îÇ   ‚îú‚îÄ‚îÄ bin/
 47: ‚îÇ   ‚îú‚îÄ‚îÄ imgs/
 48: ‚îÇ   ‚îú‚îÄ‚îÄ logs/
 49: ‚îÇ   ‚îú‚îÄ‚îÄ ui/
 50: ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ increment-counter.html
 51: ‚îÇ   ‚îî‚îÄ‚îÄ manifest.json
 52: ‚îú‚îÄ‚îÄ src/
 53: ‚îÇ   ‚îú‚îÄ‚îÄ actions/
 54: ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ increment-counter.ts
 55: ‚îÇ   ‚îî‚îÄ‚îÄ plugin.ts
 56: ‚îú‚îÄ‚îÄ package.json
 57: ‚îú‚îÄ‚îÄ rollup.config.mjs
 58: ‚îî‚îÄ‚îÄ tsconfig.json
 59: ```
 60: 
 61: The `package.json` provides two scripts for building the plugin.
 62: 
 63: -   `npm run build` - builds the plugin.
 64: -   `npm run watch` - continuously watches for changes, and hot-reloads the plugin after build.
 65: 
 66: ## üéõÔ∏è Actions
 67: 
 68: Actions are the star of the show and enable users to interact with your plugin. Actions are represented as classes that inherit from `SingletonAction`, enabling your plugin to receive events from Stream Deck, for example key down, dial rotate, etc.
 69: 
 70: The following is an example of an action that listens for the `keyDown` event, and then sets the title of the source action.
 71: 
 72: ```typescript
 73: import { action, KeyDownEvent, SingletonAction } from "@elgato/streamdeck";
 74: 
 75: @action({ UUID: "com.elgato.hello-world.say-hello" })
 76: export class SayHelloAction extends SingletonAction {
 77:     /**
 78:      * Listen for the key down event that occurs when a user presses
 79:      * a Stream Deck button, and change the title of the action.
 80:      */
 81:     async onKeyDown(ev: KeyDownEvent) {
 82:         await ev.action.setTitle("Hello world");
 83:     }
 84: }
 85: ```
 86: 
 87: ## üîé Debugging
 88: 
 89: Plugins can be debugged using any Node.js debugger, for example Visual Studio Code, Chrome, etc., and by default will have debugging enabled when created with the Stream Deck CLI `streamdeck create` command.
 90: 
 91: You can configure debugging within the [manifest's Node.js configuration](https://docs.elgato.com/streamdeck/sdk/references/manifest#nodejs).
 92: 
 93: <!-- prettier-ignore -->
 94: ```jsonc
 95: {
 96:     // ...
 97:     "Nodejs": {
 98:         "Version": "20",
 99:         "Debug": "enabled"
100:     },
101: }
102: ```
103: 
104: <!-- prettier-ignore-end -->
105: 
106: There are four available options when configuring the `Debug` property within the manifest:
107: 
108: -   `"enabled"` - the plugin will run with [`--inspect`](https://nodejs.org/api/cli.html#--inspecthostport) allowing debuggers to connect.
109: -   `"break"` - the plugin will launch with [`--inspect-brk`](https://nodejs.org/api/cli.html#--inspect-brkhostport) and will await a debugger attaching before running.
110: -   `string` - a collection of [CLI arguments](https://nodejs.org/api/cli.html) supplied to the plugin.
111: -   `undefined` - debugging is disabled.
112: 
113: > When running the plugin in either debug mode `"enabled"` or `"break"`, a random available port will be allocated to the debug listener each time the plugin launches. If you wish to listen on a specific port, the `Debug` value can be set to a string of CLI arguments, for example to listen on port `12345`, the `Debug` value would be `--inspect=127.0.0.1:12345`.
114: 
115: ## üìñ Further Reading
116: 
117: -   [Making your first changes](https://docs.elgato.com/streamdeck/sdk/introduction/your-first-changes).
118: -   Learn about [key](https://docs.elgato.com/streamdeck/sdk/guides/keys) and [dial](https://docs.elgato.com/streamdeck/sdk/guides/dials) actions.
119: -   Understand your plugin's metadata within the [manifest JSON file](https://docs.elgato.com/streamdeck/sdk/references/manifest)
120: -   Bundle your plugin for [distribution](https://docs.elgato.com/streamdeck/sdk/guides/distribution).
121: -   Explore [Stream Deck plugin samples](https://github.com/elgatosf/streamdeck-plugin-samples)
</file>

<file path="rollup.config.mjs">
 1: import nodeResolve from "@rollup/plugin-node-resolve";
 2: import typescript from "@rollup/plugin-typescript";
 3: import { dirname, join, parse, resolve } from "node:path";
 4: import url from "node:url";
 5: 
 6: const isWatching = !!process.env.ROLLUP_WATCH;
 7: const banner = `/**!
 8:  * @author Elgato
 9:  * @module elgato/streamdeck
10:  * @license MIT
11:  * @copyright Copyright (c) Corsair Memory Inc.
12:  */`;
13: 
14: /**
15:  * Defines a rollup configuration for the specified input and output.
16:  * @param {string} input Path to the input TypeScript file, with "src/" omitted.
17:  * @param {string} output Path to the desired output JavaScript file, with "dist/" omitted.
18:  * @returns Rollup configuration.
19:  */
20: function defineConfig(input, output) {
21: 	return {
22: 		input: join("src", input),
23: 		output: {
24: 			banner,
25: 			file: join("dist", output),
26: 			sourcemap: isWatching,
27: 			sourcemapPathTransform: (relativeSourcePath, sourcemapPath) => {
28: 				return url.pathToFileURL(resolve(dirname(sourcemapPath), relativeSourcePath)).href;
29: 			},
30: 		},
31: 		external: ["ws", "@elgato/schemas/streamdeck/plugins"],
32: 		plugins: [
33: 			typescript({
34: 				tsconfig: join("src", dirname(input), "tsconfig.build.json"),
35: 				mapRoot: isWatching ? "./" : undefined,
36: 			}),
37: 			nodeResolve(),
38: 			{
39: 				name: "emit-dts",
40: 				generateBundle() {
41: 					const types = `"../types/${dirname(input)}"`;
42: 					this.emitFile({
43: 						fileName: `${parse(output).name}.d.ts`,
44: 						type: "asset",
45: 						source: `${banner}
46: import streamDeck from ${types};
47: 
48: export * from ${types};
49: export default streamDeck;
50: `,
51: 					});
52: 				},
53: 			},
54: 		],
55: 	};
56: }
57: 
58: /**
59:  * Rollup configuration.
60:  */
61: export default [defineConfig("plugin/index.ts", "index.js"), defineConfig("ui/index.ts", "browser.js")];
</file>

<file path="tsconfig.json">
 1: {
 2:     "extends": "@tsconfig/node20/tsconfig.json",
 3:     "compilerOptions": {
 4:         "customConditions": [
 5:             "node"
 6:         ],
 7:         "lib": [
 8:             "es2022",
 9:             "esnext.disposable"
10:         ],
11:         "module": "es2022",
12:         "moduleResolution": "Bundler"
13:     },
14:     "include": [
15:         "src/",
16:         "tests/"
17:     ],
18:     "exclude": [
19:         "src/ui",
20:         "node_modules/"
21:     ]
22: }
</file>

<file path="UPGRADE.md">
  1: # Upgrade Guide
  2: 
  3: ### Versions
  4: 
  5: -   [v1.0.0](#v1-0-0)
  6: -   [v0.4.0](#v0-4-0)
  7: -   [v0.2.0](#v0-2-0)
  8: 
  9: ## <a id="v1-0-0"></a>v1.0.0
 10: 
 11: -   [Keys and Actions](#keys-and-dials)
 12: -   [Action Controllers](#action-controllers)
 13: -   [Device ID in Events](#device-id-in-events)
 14: -   [sendToPropertyInspector](#sendtopropertyinspector)
 15: -   [UI Connection Events](#ui-connecting-events)
 16: 
 17: ### Keys and Dials
 18: 
 19: Actions provided to events have been improved to more accurately reflect methods and information available to them. For this reason, some methods may not be available until type-narrowing within events that apply to both keys and dials.
 20: 
 21: The following methods are now accessible through type-narrowing.
 22: 
 23: -   `KeyAction`, narrowed using `isKey()`, provides access to:
 24:     -   `setImage` (options)
 25:     -   `setState`
 26:     -   `setTitle` (options)
 27:     -   `showOk`
 28: -   `DialAction`, narrowed using `isDial()`, provides access to:
 29:     -   `setFeedback`
 30:     -   `setFeedbackLayout`
 31:     -   `setTriggerDescription`
 32: 
 33: **Before**
 34: 
 35: ```ts
 36: onWillAppear(ev: WillAppearEvent): void {
 37:     ev.action.setFeedback({
 38:         title: "Hello world"
 39:     });
 40:     ev.action.setState(0);
 41: }
 42: ```
 43: 
 44: **After**
 45: 
 46: ```ts
 47: onWillAppear(ev: WillAppearEvent): void {
 48:     if (ev.action.isDial()) { // <- Check the action is a dial.
 49:         ev.action.setFeedback({
 50:             title: "Hello world"
 51:         });
 52:     } else {
 53:         ev.action.setState(0) // <- Action is a key, as it is not a dial
 54:     }
 55: }
 56: ```
 57: 
 58: ### Action Controllers
 59: 
 60: Action controllers previously accessible via `streamDeck.actions.createController` have been superseded by visible actions, accessible via `streamDeck.actions.getActionById`.
 61: 
 62: **Before**
 63: 
 64: ```ts
 65: streamDeck.actions.createController(id);
 66: ```
 67: 
 68: **After**
 69: 
 70: ```ts
 71: streamDeck.actions.getActionById(id);
 72: ```
 73: 
 74: ### Device ID in Events
 75: 
 76: The device identifier in event arguments has been superseded by the device itself, accessible on the `action` instance.
 77: 
 78: **Before**
 79: 
 80: ```ts
 81: onWillAppear(ev: WillAppearEvent): void {
 82:     ev.deviceId;
 83: }
 84: ```
 85: 
 86: **After**
 87: 
 88: ```ts
 89: onWillAppear(ev: WillAppearEvent): void {
 90:     ev.action.device.id;
 91: }
 92: ```
 93: 
 94: ### sendToPropertyInspector
 95: 
 96: The `Action.sendToPropertyInspector` has been removed, in favour of sending message directly to the current property inspector, to prevent sending messages to actions without a property inspector active.
 97: 
 98: **Before**
 99: 
100: ```ts
101: onPropertyInspectorDidAppear(ev: PropertyInspectorDidAppearEvent): void {
102:     ev.action.sendToPropertyInspector(...);
103: }
104: ```
105: 
106: **After**
107: 
108: ```ts
109: onPropertyInspectorDidAppear(ev: PropertyInspectorDidAppearEvent): void {
110:     streamDeck.ui.current?.sendToPropertyInspector(...);
111: }
112: ```
113: 
114: ### UI Connecting Events
115: 
116: The `onDidConnect` event listener has been renamed within the UI to `onConnected`, and a new `onConnecting` event listener has been added to support the start of the connection being initialized.
117: 
118: **Before**
119: 
120: ```ts
121: streamDeck.onDidConnect(listener);
122: ```
123: 
124: **After**
125: 
126: ```ts
127: streamDeck.onConnected(listener);
128: ```
129: 
130: ## <a id="v0-4-0"></a>v0.4.0
131: 
132: -   [Localization JSON structure](#localization-json-structure)
133: -   [Localization lookup](#localization-lookup)
134: -   [`PayloadObject<T>`](#payloadobjectt)
135: -   [JSON schemas](#json-schemas)
136: 
137: ### Localization JSON structure
138: 
139: Localizations within JSON files must now be nested under a `Localization` object, for example.
140: 
141: **Before**
142: 
143: ```json
144: {
145:     "Hello world": "Hallo Welt"
146: }
147: ```
148: 
149: **v0.4.0**
150: 
151: ```json
152: {
153:     "Localization": {
154:         "Hello world": "Hallo Welt"
155:     }
156: }
157: ```
158: 
159: ### Localization lookup
160: 
161: Localization lookup will now return the `key` when the localization cannot be found, for example, given the localizations above:
162: 
163: **Before**
164: 
165: ```ts
166: import streamDeck from "@elgato/streamdeck";
167: 
168: streamDeck.i18n.translate("test"); // undefined
169: ```
170: 
171: **v0.4.0**
172: 
173: ```ts
174: import streamDeck from "@elgato/streamdeck";
175: 
176: streamDeck.i18n.translate("test"); // "test"
177: ```
178: 
179: ### `PayloadObject<T>`
180: 
181: The previous `PayloadObject<T>` has been deprecated in favour of the newer `JsonObject` type. The `JsonObject` is now the primary constraint for action settings types, and can be used to create base actions.
182: 
183: **Before**
184: 
185: ```ts
186: export class BaseAction<T extends PayloadObject<T>> extends SingletonAction<T> {
187: ```
188: 
189: **v0.4.0**
190: 
191: ```ts
192: export class BaseAction<T extends JsonObject> extends SingletonAction<T> {
193: ```
194: 
195: ### JSON schemas
196: 
197: Manifest and layout JSON schemas have been relocated to [`@elgato/schemas`](https://github.com/elgatosf/schemas), and are now publicly accessible:
198: 
199: -   [Manifest schema](https://schemas.elgato.com/streamdeck/plugins/manifest.json)
200: -   [Layout schema](https://schemas.elgato.com/streamdeck/plugins/layout.json)
201: 
202: **Before**
203: 
204: ```json
205: "$schema": "../node_modules/@elgato/streamdeck/schemas/manifest.json"
206: ```
207: 
208: **After**
209: 
210: ```json
211: "$schema": "https://schemas.elgato.com/streamdeck/plugins/manifest.json"
212: ```
213: 
214: ## <a id="v0-2-0"></a>v0.2.0
215: 
216: Namespaces have been introduced in place of the previous `streamDeck.client` object to provide better natural-grouping of functionality. Additionally, `streamDeck.devices` has been promoted to a namespace to allow for future enhancements, with devices remaining iterable.
217: 
218: Members previously accessed directly from `streamDeck.client` have been relocated to the following namespaces:
219: 
220: | Before, `streamDeck.client` member | v0.2.0 namespace                          |
221: | ---------------------------------- | ----------------------------------------- |
222: | `getGlobalSettings`                | `streamDeck.settings`                     |
223: | `getSettings`                      | `streamDeck.actions.createController(id)` |
224: | `onApplicationDidLaunch`           | `streamDeck.system`                       |
225: | `onApplicationDidTerminate`        | `streamDeck.system`                       |
226: | `onDeviceDidConnect`               | `streamDeck.devices`                      |
227: | `onDeviceDidDisconnect`            | `streamDeck.devices`                      |
228: | `onDialDown`                       | `streamDeck.actions`                      |
229: | `onDialRotate`                     | `streamDeck.actions`                      |
230: | `onDialUp`                         | `streamDeck.actions`                      |
231: | `onDidReceiveGlobalSettings`       | `streamDeck.settings`                     |
232: | `onDidReceiveSettings`             | `streamDeck.settings`                     |
233: | `onKeyDown`                        | `streamDeck.actions`                      |
234: | `onKeyUp`                          | `streamDeck.actions`                      |
235: | `onPropertyInspectorDidAppear`     | `streamDeck.ui`                           |
236: | `onPropertyInspectorDidDisappear`  | `streamDeck.ui`                           |
237: | `onSendToPlugin`                   | `streamDeck.ui`                           |
238: | `onSystemDidWakeUp`                | `streamDeck.system`                       |
239: | `onTitleParametersDidChange`       | `streamDeck.actions`                      |
240: | `onTouchTap`                       | `streamDeck.actions`                      |
241: | `onWillAppear`                     | `streamDeck.actions`                      |
242: | `onWillDisappear`                  | `streamDeck.actions`                      |
243: | `openUrl`                          | `streamDeck.system`                       |
244: | `sendToPropertyInspector`          | `streamDeck.actions.createController(id)` |
245: | `setFeedback`                      | `streamDeck.actions.createController(id)` |
246: | `setFeedbackLayout`                | `streamDeck.actions.createController(id)` |
247: | `setGlobalSettings`                | `streamDeck.settings`                     |
248: | `setImage`                         | `streamDeck.actions.createController(id)` |
249: | `setSettings`                      | `streamDeck.actions.createController(id)` |
250: | `setState`                         | `streamDeck.actions.createController(id)` |
251: | `setTitle`                         | `streamDeck.actions.createController(id)` |
252: | `setTriggerDescription`            | `streamDeck.actions.createController(id)` |
253: | `showAlert`                        | `streamDeck.actions.createController(id)` |
254: | `showOk`                           | `streamDeck.actions.createController(id)` |
255: | `switchToProfile`                  | `streamDeck.profiles`                     |
</file>

</files>
